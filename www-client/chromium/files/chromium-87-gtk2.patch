diff --git a/build/config/linux/gtk/gtk.gni b/build/config/linux/gtk/gtk.gni
index 0a3f35db9642..7a2a890aca75 100644
--- a/build/config/linux/gtk/gtk.gni
+++ b/build/config/linux/gtk/gtk.gni
@@ -9,7 +9,7 @@ declare_args() {
   use_gtk = is_desktop_linux && !is_chromecast
 
   # The (major) version of GTK to build against.
-  gtk_version = 3
+  gtk_version = 2
 }
 
-assert(gtk_version >= 3 && gtk_version <= 4)
+assert(gtk_version == 2)
diff --git a/chrome/browser/ui/views/chrome_browser_main_extra_parts_views_linux.cc b/chrome/browser/ui/views/chrome_browser_main_extra_parts_views_linux.cc
index 5a97d615a093..cc69617ddc10 100644
--- a/chrome/browser/ui/views/chrome_browser_main_extra_parts_views_linux.cc
+++ b/chrome/browser/ui/views/chrome_browser_main_extra_parts_views_linux.cc
@@ -88,7 +88,9 @@ void ChromeBrowserMainExtraPartsViewsLinux::ToolkitInitialized() {
 
   // Cursor theme changes are tracked by LinuxUI (via a CursorThemeManager
   // implementation). Start observing them once it's initialized.
+#if defined(USE_OZONE)
   ui::CursorFactory::GetInstance()->ObserveThemeChanges();
+#endif
 
   DCHECK(ui::LinuxInputMethodContextFactory::instance())
       << "LinuxUI must set LinuxInputMethodContextFactory instance.";
diff --git a/ui/gtk/BUILD.gn b/ui/gtk/BUILD.gn
index 3759400373b7..9231b2697d99 100644
--- a/ui/gtk/BUILD.gn
+++ b/ui/gtk/BUILD.gn
@@ -23,6 +23,10 @@ component("gtk_ui_delegate") {
 component("gtk") {
   public = [ "gtk_ui.h" ]
   sources = [
+    "chrome_gtk_frame.cc",
+    "chrome_gtk_frame.h",
+    "chrome_gtk_menu_subclasses.cc",
+    "chrome_gtk_menu_subclasses.h",
     "gtk_key_bindings_handler.cc",
     "gtk_key_bindings_handler.h",
     "gtk_ui.cc",
@@ -32,8 +36,6 @@ component("gtk") {
     "input_method_context_impl_gtk.h",
     "native_theme_gtk.cc",
     "native_theme_gtk.h",
-    "nav_button_provider_gtk.cc",
-    "nav_button_provider_gtk.h",
     "printing/print_dialog_gtk.cc",
     "printing/print_dialog_gtk.h",
     "printing/printing_gtk_util.cc",
@@ -44,8 +46,8 @@ component("gtk") {
     "select_file_dialog_impl_gtk.h",
     "select_file_dialog_impl_kde.cc",
     "settings_provider.h",
-    "settings_provider_gtk.cc",
-    "settings_provider_gtk.h",
+    "skia_utils_gtk.cc",
+    "skia_utils_gtk.h",
   ]
   defines = [ "IS_GTK_IMPL" ]
   configs += [ "//build/config/linux/pangocairo" ]
diff --git a/ui/gtk/chrome_gtk_frame.cc b/ui/gtk/chrome_gtk_frame.cc
new file mode 100644
index 000000000000..424ea4d2a843
--- /dev/null
+++ b/ui/gtk/chrome_gtk_frame.cc
@@ -0,0 +1,154 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/gtk/chrome_gtk_frame.h"
+
+G_GNUC_BEGIN_IGNORE_DEPRECATIONS
+
+G_BEGIN_DECLS
+
+// MetaFrames declaration
+G_DEFINE_TYPE(MetaFrames, meta_frames, GTK_TYPE_WINDOW)
+
+static void meta_frames_class_init(MetaFramesClass* frames_class) {
+  // Noop since we don't declare anything.
+}
+
+static void meta_frames_init(MetaFrames* button) {
+}
+
+
+// ChromeGtkFrame declaration
+G_DEFINE_TYPE(ChromeGtkFrame, chrome_gtk_frame, meta_frames_get_type())
+
+static void chrome_gtk_frame_class_init(ChromeGtkFrameClass* frame_class) {
+  GtkWidgetClass* widget_class = reinterpret_cast<GtkWidgetClass*>(frame_class);
+
+  // Frame tints:
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "frame-color",
+          "Frame Color",
+          "The color that the chrome frame will be. (If unspecified, "
+            " Chrome will take ChromeGtkFrame::bg[SELECTED] and slightly darken"
+            " it.)",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "inactive-frame-color",
+          "Inactive Frame Color",
+          "The color that the inactive chrome frame will be. (If"
+            " unspecified, Chrome will take ChromeGtkFrame::bg[INSENSITIVE]"
+            " and slightly darken it.)",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "incognito-frame-color",
+          "Incognito Frame Color",
+          "The color that the incognito frame will be. (If unspecified,"
+            " Chrome will take the frame color and tint it by Chrome's default"
+            " incognito tint.)",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "incognito-inactive-frame-color",
+          "Incognito Inactive Frame Color",
+          "The color that the inactive incognito frame will be. (If"
+            " unspecified, Chrome will take the frame color and tint it by"
+            " Chrome's default incognito tint.)",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+
+  // Frame gradient control:
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_int(
+          "frame-gradient-size",
+          "Chrome Frame Gradient Size",
+          "The size of the gradient on top of the frame image. Specify 0 to"
+            " make the frame a solid color.",
+          0,      // 0 disables the gradient
+          128,    // The frame image is only up to 128 pixels tall.
+          16,     // By default, gradients are 16 pixels high.
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "frame-gradient-color",
+          "Frame Gradient Color",
+          "The top color of the chrome frame gradient. (If unspecified,"
+            " chrome will create a lighter tint of frame-color",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "inactive-frame-gradient-color",
+          "Inactive Frame Gradient Color",
+          "The top color of the inactive chrome frame gradient. (If"
+            " unspecified, chrome will create a lighter tint of frame-color",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "incognito-frame-gradient-color",
+          "Incognito Frame Gradient Color",
+          "The top color of the incognito chrome frame gradient. (If"
+            " unspecified, chrome will create a lighter tint of frame-color",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "incognito-inactive-frame-gradient-color",
+          "Incognito Inactive Frame Gradient Color",
+          "The top color of the incognito inactive chrome frame gradient. (If"
+            " unspecified, chrome will create a lighter tint of frame-color",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+
+  // Scrollbar color properties:
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "scrollbar-slider-prelight-color",
+          "Scrollbar Slider Prelight Color",
+          "The color applied to the mouse is above the tab",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "scrollbar-slider-normal-color",
+          "Scrollbar Slider Normal Color",
+          "The color applied to the slider normally",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "scrollbar-trough-color",
+          "Scrollbar Trough Color",
+          "The background color of the slider track",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+}
+
+static void chrome_gtk_frame_init(ChromeGtkFrame* frame) {
+}
+
+GtkWidget* chrome_gtk_frame_new(void) {
+  return GTK_WIDGET(g_object_new(chrome_gtk_frame_get_type(), "type",
+                                 GTK_WINDOW_TOPLEVEL, nullptr));
+}
+
+G_END_DECLS
diff --git a/ui/gtk/chrome_gtk_frame.h b/ui/gtk/chrome_gtk_frame.h
new file mode 100644
index 000000000000..2d783453ced0
--- /dev/null
+++ b/ui/gtk/chrome_gtk_frame.h
@@ -0,0 +1,54 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_UI_LIBGTKUI_CHROME_GTK_FRAME_H_
+#define CHROME_BROWSER_UI_LIBGTKUI_CHROME_GTK_FRAME_H_
+
+#include <gtk/gtk.h>
+
+G_BEGIN_DECLS
+
+// This file declares two subclasses of GtkWindow for easier gtk+ theme
+// integration.
+//
+// The first is "MetaFrames," which is (was?) the name of a gobject class in
+// the metacity window manager. To actually get at those values, we need to
+// have an object whose gobject class name string matches the definitions in
+// the gtkrc file. MetaFrames derives from GtkWindow.
+//
+// Metaframes can not be instantiated. It has no constructor; instantiate
+// ChromeGtkFrame instead.
+typedef struct _MetaFrames       MetaFrames;
+typedef struct _MetaFramesClass  MetaFramesClass;
+
+struct _MetaFrames {
+  GtkWindow window;
+};
+
+struct _MetaFramesClass {
+  GtkWindowClass parent_class;
+};
+
+
+// The second is ChromeGtkFrame, which defines a number of optional style
+// properties so theme authors can control how chromium appears in gtk-theme
+// mode.  It derives from MetaFrames in chrome so older themes that declare a
+// MetaFrames theme will still work. New themes should target this class.
+typedef struct _ChromeGtkFrame       ChromeGtkFrame;
+typedef struct _ChromeGtkFrameClass  ChromeGtkFrameClass;
+
+struct _ChromeGtkFrame {
+  MetaFrames frames;
+};
+
+struct _ChromeGtkFrameClass {
+  MetaFramesClass frames_class;
+};
+
+// Creates a GtkWindow object the the class name "ChromeGtkFrame".
+GtkWidget* chrome_gtk_frame_new();
+
+G_END_DECLS
+
+#endif  // CHROME_BROWSER_UI_LIBGTKUI_CHROME_GTK_FRAME_H_
diff --git a/ui/gtk/chrome_gtk_menu_subclasses.cc b/ui/gtk/chrome_gtk_menu_subclasses.cc
new file mode 100644
index 000000000000..adb5d8a9ec40
--- /dev/null
+++ b/ui/gtk/chrome_gtk_menu_subclasses.cc
@@ -0,0 +1,29 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/gtk/chrome_gtk_menu_subclasses.h"
+
+G_DEFINE_TYPE(GtkCustomMenu, gtk_custom_menu, GTK_TYPE_MENU)
+
+static void gtk_custom_menu_init(GtkCustomMenu* menu) {
+}
+
+static void gtk_custom_menu_class_init(GtkCustomMenuClass* klass) {
+}
+
+GtkWidget* gtk_custom_menu_new() {
+  return GTK_WIDGET(g_object_new(gtk_custom_menu_get_type(), nullptr));
+}
+
+G_DEFINE_TYPE(GtkCustomMenuItem, gtk_custom_menu_item, GTK_TYPE_MENU_ITEM)
+
+static void gtk_custom_menu_item_init(GtkCustomMenuItem* item) {
+}
+
+static void gtk_custom_menu_item_class_init(GtkCustomMenuItemClass* klass) {
+}
+
+GtkWidget* gtk_custom_menu_item_new() {
+  return GTK_WIDGET(g_object_new(gtk_custom_menu_item_get_type(), nullptr));
+}
diff --git a/ui/gtk/chrome_gtk_menu_subclasses.h b/ui/gtk/chrome_gtk_menu_subclasses.h
new file mode 100644
index 000000000000..fd999576543a
--- /dev/null
+++ b/ui/gtk/chrome_gtk_menu_subclasses.h
@@ -0,0 +1,47 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_UI_LIBGTKUI_CHROME_GTK_MENU_SUBCLASSES_H_
+#define CHROME_BROWSER_UI_LIBGTKUI_CHROME_GTK_MENU_SUBCLASSES_H_
+
+#include <gtk/gtk.h>
+
+// This file declares two subclasses of Gtk's menu classes. We do this because
+// when we were a GTK app proper, we had classes with the same names, and gtk
+// theme authors started writing themes and styling chrome's menus by targeting
+// these classes. We have to fetch our colors from these theme classes in
+// specific because several newer GTK+2 themes are pixmap based and they
+// specifically give real colors only to these classes.
+
+G_BEGIN_DECLS
+
+typedef struct _GtkCustomMenu GtkCustomMenu;
+typedef struct _GtkCustomMenuClass GtkCustomMenuClass;
+
+struct _GtkCustomMenu {
+  GtkMenu menu;
+};
+
+struct _GtkCustomMenuClass {
+  GtkMenuClass parent_class;
+};
+
+GtkWidget* gtk_custom_menu_new();
+
+typedef struct _GtkCustomMenuItem GtkCustomMenuItem;
+typedef struct _GtkCustomMenuItemClass GtkCustomMenuItemClass;
+
+struct _GtkCustomMenuItem {
+  GtkMenuItem menu_item;
+};
+
+struct _GtkCustomMenuItemClass {
+  GtkMenuItemClass parent_class;
+};
+
+GtkWidget* gtk_custom_menu_item_new();
+
+G_END_DECLS
+
+#endif  // CHROME_BROWSER_UI_LIBGTKUI_CHROME_GTK_MENU_SUBCLASSES_H_
diff --git a/ui/gtk/gtk_key_bindings_handler.cc b/ui/gtk/gtk_key_bindings_handler.cc
index c663a2074628..ee276c737727 100644
--- a/ui/gtk/gtk_key_bindings_handler.cc
+++ b/ui/gtk/gtk_key_bindings_handler.cc
@@ -66,7 +66,7 @@ bool GtkKeyBindingsHandler::MatchEvent(
   // If this key event matches a predefined key binding, corresponding signal
   // will be emitted.
 
-  gtk_bindings_activate_event(G_OBJECT(handler_), &gdk_event->key);
+  gtk_bindings_activate_event(GTK_OBJECT(handler_), &gdk_event->key);
   gdk_event_free(gdk_event);
 
   bool matched = !edit_commands_.empty();
diff --git a/ui/gtk/gtk_ui.cc b/ui/gtk/gtk_ui.cc
index 9905c4f0b355..6d5c6b441725 100644
--- a/ui/gtk/gtk_ui.cc
+++ b/ui/gtk/gtk_ui.cc
@@ -48,6 +48,8 @@
 #include "ui/gtk/gtk_key_bindings_handler.h"
 #include "ui/gtk/gtk_ui_delegate.h"
 #include "ui/gtk/gtk_util.h"
+#include "ui/gtk/chrome_gtk_frame.h"
+#include "ui/gtk/skia_utils_gtk.h"
 #include "ui/gtk/input_method_context_impl_gtk.h"
 #include "ui/gtk/native_theme_gtk.h"
 #include "ui/gtk/nav_button_provider_gtk.h"
@@ -128,52 +130,45 @@ class GtkButtonImageSource : public gfx::ImageSkiaSource {
         width, height, width * 4);
     cairo_t* cr = cairo_create(surface);
 
-    ScopedStyleContext context = GetStyleContextFromCss("GtkButton#button");
-    GtkStateFlags state_flags = StateToStateFlags(state_);
-    if (focus_) {
-      state_flags =
-          static_cast<GtkStateFlags>(state_flags | GTK_STATE_FLAG_FOCUSED);
-    }
-    gtk_style_context_set_state(context, state_flags);
-    gtk_render_background(context, cr, 0, 0, width, height);
-    gtk_render_frame(context, cr, 0, 0, width, height);
-    if (focus_) {
-      gfx::Rect focus_rect(width, height);
-
-#if !GTK_CHECK_VERSION(3, 90, 0)
-      if (!GtkCheckVersion(3, 14)) {
-        gint focus_pad;
-        gtk_style_context_get_style(context, "focus-padding", &focus_pad,
-                                    nullptr);
-        focus_rect.Inset(focus_pad, focus_pad);
-
-        if (state_ == ui::NativeTheme::kPressed) {
-          gint child_displacement_x, child_displacement_y;
-          gboolean displace_focus;
-          gtk_style_context_get_style(
-              context, "child-displacement-x", &child_displacement_x,
-              "child-displacement-y", &child_displacement_y, "displace-focus",
-              &displace_focus, nullptr);
-          if (displace_focus)
-            focus_rect.Offset(child_displacement_x, child_displacement_y);
-        }
-      }
-#endif
-
-      if (!GtkCheckVersion(3, 20)) {
-        GtkBorder border;
-#if GTK_CHECK_VERSION(3, 90, 0)
-        gtk_style_context_get_border(context, &border);
-#else
-        gtk_style_context_get_border(context, state_flags, &border);
-#endif
-        focus_rect.Inset(border.left, border.top, border.right, border.bottom);
-      }
-
-      gtk_render_focus(context, cr, focus_rect.x(), focus_rect.y(),
-                       focus_rect.width(), focus_rect.height());
+    // Create a temporary GTK button to snapshot
+    GtkWidget* window = gtk_offscreen_window_new();
+    GtkWidget* button = gtk_toggle_button_new();
+
+    if (state_ == ui::NativeTheme::kPressed)
+      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), true);
+    else if (state_ == ui::NativeTheme::kDisabled)
+      gtk_widget_set_sensitive(button, false);
+
+    gtk_widget_set_size_request(button, width, height);
+    gtk_container_add(GTK_CONTAINER(window), button);
+
+    gtk_widget_show_all(window);
+
+    if (focus_)
+      GTK_WIDGET_SET_FLAGS(button, GTK_HAS_FOCUS);
+
+    int w, h;
+    GdkPixmap* pixmap;
+
+    {
+      // http://crbug.com/346740
+      ANNOTATE_SCOPED_MEMORY_LEAK;
+      pixmap = gtk_widget_get_snapshot(button, nullptr);
     }
 
+    gdk_drawable_get_size(GDK_DRAWABLE(pixmap), &w, &h);
+    GdkColormap* colormap = gdk_drawable_get_colormap(pixmap);
+    GdkPixbuf* pixbuf = gdk_pixbuf_get_from_drawable(
+        nullptr, GDK_DRAWABLE(pixmap), colormap, 0, 0, 0, 0, w, h);
+
+    gdk_cairo_set_source_pixbuf(cr, pixbuf, 0, 0);
+    cairo_paint(cr);
+
+    g_object_unref(pixbuf);
+    g_object_unref(pixmap);
+
+    gtk_widget_destroy(window);
+
     cairo_destroy(cr);
     cairo_surface_destroy(surface);
 
@@ -234,8 +229,6 @@ int indicators_count;
 const char kUnknownContentType[] = "application/octet-stream";
 
 std::unique_ptr<SettingsProvider> CreateSettingsProvider(GtkUi* gtk_ui) {
-  if (GtkCheckVersion(3, 14))
-    return std::make_unique<SettingsProviderGtk>(gtk_ui);
 #if defined(USE_GIO)
   return std::make_unique<SettingsProviderGSettings>(gtk_ui);
 #else
@@ -293,8 +286,6 @@ gfx::FontRenderParams GetGtkFontRenderParams() {
 }
 
 views::LinuxUI::WindowFrameAction GetDefaultMiddleClickAction() {
-  if (GtkCheckVersion(3, 14))
-    return views::LinuxUI::WindowFrameAction::kNone;
   std::unique_ptr<base::Environment> env(base::Environment::Create());
   switch (base::nix::GetDesktopEnvironment(env.get())) {
     case base::nix::DESKTOP_ENVIRONMENT_KDE4:
@@ -385,7 +376,7 @@ GtkUi::GtkUi(ui::GtkUiDelegate* delegate) : delegate_(delegate) {
   env->SetVar("NO_AT_BRIDGE", "1");
   GtkInitFromCommandLine(*base::CommandLine::ForCurrentProcess());
   native_theme_ = NativeThemeGtk::instance();
-  fake_window_ = gtk_window_new(GTK_WINDOW_TOPLEVEL);
+  fake_window_ = chrome_gtk_frame_new();
   gtk_widget_realize(fake_window_);
 }
 
@@ -726,8 +717,6 @@ bool GtkUi::AnimationsEnabled() const {
 }
 
 std::unique_ptr<views::NavButtonProvider> GtkUi::CreateNavButtonProvider() {
-  if (GtkCheckVersion(3, 14))
-    return std::make_unique<gtk::NavButtonProviderGtk>();
   return nullptr;
 }
 
@@ -827,7 +816,7 @@ void GtkUi::OnThemeChanged(GtkSettings* settings, GtkParamSpec* param) {
   colors_.clear();
   custom_frame_colors_.clear();
   native_frame_colors_.clear();
-  native_theme_->OnThemeChanged(settings, param);
+  //native_theme_->OnThemeChanged(settings, param);
   LoadGtkValues();
   native_theme_->NotifyObservers();
 }
@@ -854,6 +843,19 @@ void GtkUi::OnDeviceScaleFactorMaybeChanged(void*, GParamSpec*) {
   UpdateDeviceScaleFactor();
 }
 
+bool GtkUi::GetChromeStyleColor(const char* style_property,
+                                SkColor* ret_color) const {
+  GdkColor* style_color = nullptr;
+  gtk_widget_style_get(fake_window_, style_property, &style_color, nullptr);
+  if (style_color) {
+    *ret_color = GdkColorToSkColor(*style_color);
+    gdk_color_free(style_color);
+    return true;
+  }
+
+  return false;
+}
+
 void GtkUi::LoadGtkValues() {
   // TODO(thomasanderson): GtkThemeService had a comment here about having to
   // muck with the raw Prefs object to remove prefs::kCurrentThemeImages or else
@@ -864,20 +866,22 @@ void GtkUi::LoadGtkValues() {
 }
 
 void GtkUi::UpdateColors() {
-  SkColor location_bar_border = GetBorderColor("GtkEntry#entry");
+  // GetTextAAColor(GetEntry(), NORMAL) ~= GetBorderColor("GtkEntry#entry")
+  SkColor location_bar_border = native_theme_->GetSystemColor(
+    ui::NativeTheme::kColorId_UnfocusedBorderColor);
   if (SkColorGetA(location_bar_border))
     colors_[ThemeProperties::COLOR_LOCATION_BAR_BORDER] = location_bar_border;
 
-  inactive_selection_bg_color_ = GetSelectionBgColor(
-      GtkCheckVersion(3, 20) ? "GtkTextView#textview.view:backdrop "
-                               "#text:backdrop #selection:backdrop"
-                             : "GtkTextView.view:selected:backdrop");
-  inactive_selection_fg_color_ =
-      GetFgColor(GtkCheckVersion(3, 20) ? "GtkTextView#textview.view:backdrop "
-                                          "#text:backdrop #selection:backdrop"
-                                        : "GtkTextView.view:selected:backdrop");
+  // GetBgColor(GetEntry(), SELECTED) =~ GetSelectionBgColor("GtkTextView.view:selected:backdrop");
+  inactive_selection_bg_color_ = native_theme_->GetSystemColor(
+    ui::NativeTheme::kColorId_TextfieldSelectionBackgroundFocused);
+  // GetTextColor(GetEntry(), SELECTED) ~= GetFgColor("GtkTextView.view:selected:backdrop");
+  inactive_selection_fg_color_ = native_theme_->GetSystemColor(
+    ui::NativeTheme::kColorId_TextfieldSelectionColor);
 
-  SkColor tab_border = GetBorderColor("GtkButton#button");
+  // GetBgColor(GetLabel(), INSENSITIVE) =~ GetBorderColor("GtkButton#button");
+  SkColor tab_border = native_theme_->GetSystemColor(
+    ui::NativeTheme::kColorId_ButtonBorderColor);
   // Separates the toolbar from the bookmark bar or butter bars.
   colors_[ThemeProperties::COLOR_TOOLBAR_CONTENT_AREA_SEPARATOR] = tab_border;
   // Separates entries in the downloads bar.
@@ -888,10 +892,12 @@ void GtkUi::UpdateColors() {
           ui::NativeTheme::kColorId_TextfieldDefaultBackground);
   colors_[ThemeProperties::COLOR_NTP_TEXT] = native_theme_->GetSystemColor(
       ui::NativeTheme::kColorId_TextfieldDefaultColor);
-  colors_[ThemeProperties::COLOR_NTP_HEADER] =
-      GetBorderColor("GtkButton#button");
+  // GetBgColor(GetLabel(), INSENSITIVE) =~ GetBorderColor("GtkButton#button")
+  colors_[ThemeProperties::COLOR_NTP_HEADER] = native_theme_->GetSystemColor(
+    ui::NativeTheme::kColorId_ButtonBorderColor);
 
-  SkColor tab_text_color = GetFgColor("GtkLabel");
+  SkColor tab_text_color = native_theme_->GetSystemColor(
+    ui::NativeTheme::kColorId_DefaultIconColor); // GetTextColor(GetLabel, NORMAL)
   colors_[ThemeProperties::COLOR_TOOLBAR_BUTTON_ICON] = tab_text_color;
   colors_[ThemeProperties::COLOR_TOOLBAR_BUTTON_ICON_HOVERED] = tab_text_color;
   colors_[ThemeProperties::COLOR_TOOLBAR_BUTTON_ICON_PRESSED] = tab_text_color;
@@ -927,15 +933,12 @@ void GtkUi::UpdateColors() {
   for (bool custom_frame : {false, true}) {
     ColorMap& color_map =
         custom_frame ? custom_frame_colors_ : native_frame_colors_;
-    const std::string header_selector =
-        custom_frame ? "#headerbar.header-bar.titlebar" : "GtkMenuBar#menubar";
-    const std::string header_selector_inactive = header_selector + ":backdrop";
     const SkColor frame_color =
-        SkColorSetA(GetBgColor(header_selector), SK_AlphaOPAQUE);
+      native_theme_->GetSystemColor(ui::NativeTheme::kColorId_WindowBackground);
     const SkColor frame_color_incognito =
         color_utils::HSLShift(frame_color, kDefaultTintFrameIncognito);
-    const SkColor frame_color_inactive =
-        SkColorSetA(GetBgColor(header_selector_inactive), SK_AlphaOPAQUE);
+    const SkColor frame_color_inactive = native_theme_->GetSystemColor(
+      ui::NativeTheme::kColorId_NotificationDefaultBackground);
     const SkColor frame_color_incognito_inactive =
         color_utils::HSLShift(frame_color_inactive, kDefaultTintFrameIncognito);
 
@@ -948,8 +951,9 @@ void GtkUi::UpdateColors() {
 
     // Compose the window color on the frame color to ensure the resulting tab
     // color is opaque.
+    auto tmp = native_theme_->GetSystemColor(ui::NativeTheme::kColorId_DialogBackground);
     SkColor tab_color =
-        color_utils::GetResultingPaintColor(GetBgColor(""), frame_color);
+      color_utils::GetResultingPaintColor(tmp, frame_color);
 
     color_map[ThemeProperties::COLOR_TOOLBAR] = tab_color;
     color_map[ThemeProperties::COLOR_DOWNLOAD_SHELF] = tab_color;
@@ -960,10 +964,10 @@ void GtkUi::UpdateColors() {
     color_map[ThemeProperties::COLOR_TAB_BACKGROUND_ACTIVE_FRAME_INACTIVE] =
         tab_color;
 
-    const SkColor background_tab_text_color =
-        GetFgColor(header_selector + " GtkLabel.title");
-    const SkColor background_tab_text_color_inactive =
-        GetFgColor(header_selector_inactive + " GtkLabel.title");
+    const SkColor background_tab_text_color = native_theme_->GetSystemColor(
+      ui::NativeTheme::kColorId_LabelEnabledColor);
+    const SkColor background_tab_text_color_inactive = native_theme_->GetSystemColor(
+      ui::NativeTheme::kColorId_LabelDisabledColor);
 
     color_map[ThemeProperties::COLOR_TAB_FOREGROUND_INACTIVE_FRAME_ACTIVE] =
         background_tab_text_color;
@@ -993,11 +997,9 @@ void GtkUi::UpdateColors() {
 
     // These colors represent the border drawn around tabs and between
     // the tabstrip and toolbar.
-    SkColor toolbar_top_separator = GetBorderColor(
-        header_selector + " GtkSeparator#separator.vertical.titlebutton");
-    SkColor toolbar_top_separator_inactive =
-        GetBorderColor(header_selector +
-                       ":backdrop GtkSeparator#separator.vertical.titlebutton");
+    SkColor toolbar_top_separator = native_theme_->GetSystemColor(
+      ui::NativeTheme::kColorId_MenuSeparatorColor);
+    SkColor toolbar_top_separator_inactive = toolbar_top_separator;
 
     auto toolbar_top_separator_has_good_contrast = [&]() {
       // This constant is copied from chrome/browser/themes/theme_service.cc.
@@ -1013,13 +1015,6 @@ void GtkUi::UpdateColors() {
                  kMinContrastRatio;
     };
 
-    if (!toolbar_top_separator_has_good_contrast()) {
-      toolbar_top_separator =
-          GetBorderColor(header_selector + " GtkButton#button");
-      toolbar_top_separator_inactive =
-          GetBorderColor(header_selector + ":backdrop GtkButton#button");
-    }
-
     // If we can't get a contrasting stroke from the theme, have ThemeService
     // provide a stroke color for us.
     if (toolbar_top_separator_has_good_contrast()) {
@@ -1081,20 +1076,10 @@ float GtkUi::GetRawDeviceScaleFactor() {
   if (display::Display::HasForceDeviceScaleFactor())
     return display::Display::GetForcedDeviceScaleFactor();
 
-  GdkScreen* screen = gdk_screen_get_default();
-  float scale = gtk_widget_get_scale_factor(fake_window_);
-  DCHECK_GT(scale, 0.0);
-
-  gdouble resolution = gdk_screen_get_resolution(screen);
-  // TODO(https://crbug.com/1033552): Remove this hack once the Trusty bots are
-  // fixed to have a resolution of 96, or when the Trusty bots are removed
-  // altogether.
-  if (std::abs(resolution - 95.8486) < 0.001)
-    resolution = 96;
-  if (resolution > 0)
-    scale *= resolution / kDefaultDPI;
-
-  return scale;
+  GtkSettings* gtk_settings = gtk_settings_get_default();
+  gint gtk_dpi = -1;
+  g_object_get(gtk_settings, "gtk-xft-dpi", &gtk_dpi, nullptr);
+  return gtk_dpi / (1024 * kDefaultDPI);
 }
 
 void GtkUi::UpdateDeviceScaleFactor() {
diff --git a/ui/gtk/gtk_ui.h b/ui/gtk/gtk_ui.h
index 84032b302718..413beb4410b6 100644
--- a/ui/gtk/gtk_ui.h
+++ b/ui/gtk/gtk_ui.h
@@ -146,6 +146,10 @@ class GtkUi : public views::LinuxUI {
   // Updates |default_font_*|.
   void UpdateDefaultFont();
 
+  // Gets a ChromeGtkFrame theme color; returns true on success.  No-op on gtk3.
+  bool GetChromeStyleColor(const char* sytle_property,
+                           SkColor* ret_color) const;
+
   float GetRawDeviceScaleFactor();
 
   // Not owned by GtkUi.
diff --git a/ui/gtk/gtk_ui_delegate.h b/ui/gtk/gtk_ui_delegate.h
index 9daed0a8f461..038a4e310ded 100644
--- a/ui/gtk/gtk_ui_delegate.h
+++ b/ui/gtk/gtk_ui_delegate.h
@@ -9,7 +9,7 @@
 #include "ui/gfx/native_widget_types.h"
 
 using GdkKeymap = struct _GdkKeymap;
-using GdkWindow = struct _GdkWindow;
+using GdkWindow = struct _GdkDrawable;
 using GtkWindow = struct _GtkWindow;
 
 namespace ui {
diff --git a/ui/gtk/gtk_util.cc b/ui/gtk/gtk_util.cc
index 6cd7e64be6ca..b4b21177f1cc 100644
--- a/ui/gtk/gtk_util.cc
+++ b/ui/gtk/gtk_util.cc
@@ -32,9 +32,6 @@
 #include "ui/ozone/public/ozone_platform.h"
 #include "ui/views/linux_ui/linux_ui.h"
 
-WEAK_GTK_FN(gtk_widget_path_iter_set_object_name);
-WEAK_GTK_FN(gtk_widget_path_iter_set_state);
-
 namespace {
 
 const char kAuraTransientParent[] = "aura-transient-parent";
@@ -47,9 +44,6 @@ void CommonInitFromCommandLine(const base::CommandLine& command_line) {
   // This prevent GTK from calling setlocale(LC_ALL, ""), which potentially
   // overwrites the LC_NUMERIC locale to something other than "C".
   gtk_disable_setlocale();
-#if GTK_CHECK_VERSION(3, 90, 0)
-  gtk_init();
-#else
   const std::vector<std::string>& args = command_line.argv();
   int argc = args.size();
   std::unique_ptr<char*[]> argv(new char*[argc + 1]);
@@ -69,7 +63,6 @@ void CommonInitFromCommandLine(const base::CommandLine& command_line) {
   for (size_t i = 0; i < args.size(); ++i) {
     free(argv[i]);
   }
-#endif
 }
 
 GdkModifierType GetIbusFlags(const ui::KeyEvent& key_event) {
@@ -190,380 +183,6 @@ void ParseButtonLayout(const std::string& button_string,
   }
 }
 
-namespace {
-
-float GetDeviceScaleFactor() {
-  views::LinuxUI* linux_ui = views::LinuxUI::instance();
-  return linux_ui ? linux_ui->GetDeviceScaleFactor() : 1;
-}
-
-}  // namespace
-
-CairoSurface::CairoSurface(SkBitmap& bitmap)
-    : surface_(cairo_image_surface_create_for_data(
-          static_cast<unsigned char*>(bitmap.getAddr(0, 0)),
-          CAIRO_FORMAT_ARGB32,
-          bitmap.width(),
-          bitmap.height(),
-          cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32, bitmap.width()))),
-      cairo_(cairo_create(surface_)) {}
-
-CairoSurface::CairoSurface(const gfx::Size& size)
-    : surface_(cairo_image_surface_create(CAIRO_FORMAT_ARGB32,
-                                          size.width(),
-                                          size.height())),
-      cairo_(cairo_create(surface_)) {
-  DCHECK(cairo_surface_status(surface_) == CAIRO_STATUS_SUCCESS);
-  // Clear the surface.
-  cairo_save(cairo_);
-  cairo_set_source_rgba(cairo_, 0, 0, 0, 0);
-  cairo_set_operator(cairo_, CAIRO_OPERATOR_SOURCE);
-  cairo_paint(cairo_);
-  cairo_restore(cairo_);
-}
-
-CairoSurface::~CairoSurface() {
-  cairo_destroy(cairo_);
-  cairo_surface_destroy(surface_);
-}
-
-SkColor CairoSurface::GetAveragePixelValue(bool frame) {
-  cairo_surface_flush(surface_);
-  SkColor* data =
-      reinterpret_cast<SkColor*>(cairo_image_surface_get_data(surface_));
-  int width = cairo_image_surface_get_width(surface_);
-  int height = cairo_image_surface_get_height(surface_);
-  DCHECK(4 * width == cairo_image_surface_get_stride(surface_));
-  long a = 0, r = 0, g = 0, b = 0;
-  unsigned int max_alpha = 0;
-  for (int i = 0; i < width * height; i++) {
-    SkColor color = data[i];
-    max_alpha = std::max(SkColorGetA(color), max_alpha);
-    a += SkColorGetA(color);
-    r += SkColorGetR(color);
-    g += SkColorGetG(color);
-    b += SkColorGetB(color);
-  }
-  if (a == 0)
-    return SK_ColorTRANSPARENT;
-  return SkColorSetARGB(frame ? max_alpha : a / (width * height), r * 255 / a,
-                        g * 255 / a, b * 255 / a);
-}
-
-bool GtkCheckVersion(int major, int minor, int micro) {
-  static auto version =
-      std::make_tuple(gtk_get_major_version(), gtk_get_minor_version(),
-                      gtk_get_micro_version());
-  return version >= std::make_tuple(major, minor, micro);
-}
-
-GtkStateFlags StateToStateFlags(ui::NativeTheme::State state) {
-  switch (state) {
-    case ui::NativeTheme::kDisabled:
-      return GTK_STATE_FLAG_INSENSITIVE;
-    case ui::NativeTheme::kHovered:
-      return GTK_STATE_FLAG_PRELIGHT;
-    case ui::NativeTheme::kNormal:
-      return GTK_STATE_FLAG_NORMAL;
-    case ui::NativeTheme::kPressed:
-      return static_cast<GtkStateFlags>(GTK_STATE_FLAG_PRELIGHT |
-                                        GTK_STATE_FLAG_ACTIVE);
-    default:
-      NOTREACHED();
-      return GTK_STATE_FLAG_NORMAL;
-  }
-}
-
-SkColor GdkRgbaToSkColor(const GdkRGBA& color) {
-  return SkColorSetARGB(color.alpha * 255, color.red * 255, color.green * 255,
-                        color.blue * 255);
-}
-
-NO_SANITIZE("cfi-icall")
-ScopedStyleContext AppendCssNodeToStyleContext(GtkStyleContext* context,
-                                               const std::string& css_node) {
-  GtkWidgetPath* path =
-      context ? gtk_widget_path_copy(gtk_style_context_get_path(context))
-              : gtk_widget_path_new();
-
-  enum {
-    CSS_TYPE,
-    CSS_NAME,
-    CSS_OBJECT_NAME,
-    CSS_CLASS,
-    CSS_PSEUDOCLASS,
-    CSS_NONE,
-  } part_type = CSS_TYPE;
-  static const struct {
-    const char* name;
-    GtkStateFlags state_flag;
-  } pseudo_classes[] = {
-      {"active", GTK_STATE_FLAG_ACTIVE},
-      {"hover", GTK_STATE_FLAG_PRELIGHT},
-      {"selected", GTK_STATE_FLAG_SELECTED},
-      {"disabled", GTK_STATE_FLAG_INSENSITIVE},
-      {"indeterminate", GTK_STATE_FLAG_INCONSISTENT},
-      {"focus", GTK_STATE_FLAG_FOCUSED},
-      {"backdrop", GTK_STATE_FLAG_BACKDROP},
-      {"link", GTK_STATE_FLAG_LINK},
-      {"visited", GTK_STATE_FLAG_VISITED},
-      {"checked", GTK_STATE_FLAG_CHECKED},
-  };
-  GtkStateFlags state = GTK_STATE_FLAG_NORMAL;
-  base::StringTokenizer t(css_node, ".:#()");
-  t.set_options(base::StringTokenizer::RETURN_DELIMS);
-  while (t.GetNext()) {
-    if (t.token_is_delim()) {
-      if (t.token_begin() == css_node.begin()) {
-        // Special case for the first token.
-        gtk_widget_path_append_type(path, G_TYPE_NONE);
-      }
-      switch (*t.token_begin()) {
-        case '(':
-          part_type = CSS_NAME;
-          break;
-        case ')':
-          part_type = CSS_NONE;
-          break;
-        case '#':
-          part_type = CSS_OBJECT_NAME;
-          break;
-        case '.':
-          part_type = CSS_CLASS;
-          break;
-        case ':':
-          part_type = CSS_PSEUDOCLASS;
-          break;
-        default:
-          NOTREACHED();
-      }
-    } else {
-      switch (part_type) {
-        case CSS_NAME:
-          gtk_widget_path_iter_set_name(path, -1, t.token().c_str());
-          break;
-        case CSS_OBJECT_NAME:
-          if (GtkCheckVersion(3, 20)) {
-            DCHECK(gtk_widget_path_iter_set_object_name);
-            gtk_widget_path_iter_set_object_name(path, -1, t.token().c_str());
-          } else {
-            gtk_widget_path_iter_add_class(path, -1, t.token().c_str());
-          }
-          break;
-        case CSS_TYPE: {
-          GType type = g_type_from_name(t.token().c_str());
-          DCHECK(type);
-          gtk_widget_path_append_type(path, type);
-          if (GtkCheckVersion(3, 20) && t.token() == "GtkLabel") {
-            DCHECK(gtk_widget_path_iter_set_object_name);
-            gtk_widget_path_iter_set_object_name(path, -1, "label");
-          }
-          break;
-        }
-        case CSS_CLASS:
-          gtk_widget_path_iter_add_class(path, -1, t.token().c_str());
-          break;
-        case CSS_PSEUDOCLASS: {
-          GtkStateFlags state_flag = GTK_STATE_FLAG_NORMAL;
-          for (const auto& pseudo_class_entry : pseudo_classes) {
-            if (strcmp(pseudo_class_entry.name, t.token().c_str()) == 0) {
-              state_flag = pseudo_class_entry.state_flag;
-              break;
-            }
-          }
-          state = static_cast<GtkStateFlags>(state | state_flag);
-          break;
-        }
-        case CSS_NONE:
-          NOTREACHED();
-      }
-    }
-  }
-
-  // Always add a "chromium" class so that themes can style chromium
-  // widgets specially if they want to.
-  gtk_widget_path_iter_add_class(path, -1, "chromium");
-
-  if (GtkCheckVersion(3, 14)) {
-    DCHECK(gtk_widget_path_iter_set_state);
-    gtk_widget_path_iter_set_state(path, -1, state);
-  }
-
-  ScopedStyleContext child_context(gtk_style_context_new());
-  gtk_style_context_set_path(child_context, path);
-  if (GtkCheckVersion(3, 14)) {
-    gtk_style_context_set_state(child_context, state);
-  } else {
-    GtkStateFlags child_state = state;
-    if (context) {
-      child_state = static_cast<GtkStateFlags>(
-          child_state | gtk_style_context_get_state(context));
-    }
-    gtk_style_context_set_state(child_context, child_state);
-  }
-  gtk_style_context_set_scale(child_context, std::ceil(GetDeviceScaleFactor()));
-  gtk_style_context_set_parent(child_context, context);
-  gtk_widget_path_unref(path);
-  return child_context;
-}
-
-ScopedStyleContext GetStyleContextFromCss(const std::string& css_selector) {
-  // Prepend a window node to the selector since all widgets must live
-  // in a window, but we don't want to specify that every time.
-  auto context =
-      AppendCssNodeToStyleContext(nullptr, "GtkWindow#window.background");
-
-  for (const auto& widget_type :
-       base::SplitString(css_selector, base::kWhitespaceASCII,
-                         base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY)) {
-    context = AppendCssNodeToStyleContext(context, widget_type);
-  }
-  return context;
-}
-
-SkColor GetFgColorFromStyleContext(GtkStyleContext* context) {
-  GdkRGBA color;
-#if GTK_CHECK_VERSION(3, 90, 0)
-  gtk_style_context_get_color(context, &color);
-#else
-  gtk_style_context_get_color(context, gtk_style_context_get_state(context),
-                              &color);
-#endif
-  return GdkRgbaToSkColor(color);
-}
-
-SkColor GetBgColorFromStyleContext(GtkStyleContext* context) {
-  // Backgrounds are more general than solid colors (eg. gradients),
-  // but chromium requires us to boil this down to one color.  We
-  // cannot use the background-color here because some themes leave it
-  // set to a garbage color because a background-image will cover it
-  // anyway.  So we instead render the background into a 24x24 bitmap,
-  // removing any borders, and hope that we get a good color.
-  ApplyCssToContext(context,
-                    "* {"
-                    "border-radius: 0px;"
-                    "border-style: none;"
-                    "box-shadow: none;"
-                    "}");
-  gfx::Size size(24, 24);
-  CairoSurface surface(size);
-  RenderBackground(size, surface.cairo(), context);
-  return surface.GetAveragePixelValue(false);
-}
-
-SkColor GetFgColor(const std::string& css_selector) {
-  return GetFgColorFromStyleContext(GetStyleContextFromCss(css_selector));
-}
-
-ScopedCssProvider GetCssProvider(const std::string& css) {
-  GtkCssProvider* provider = gtk_css_provider_new();
-#if GTK_CHECK_VERSION(3, 90, 0)
-  gtk_css_provider_load_from_data(provider, css.c_str(), -1);
-#else
-  GError* error = nullptr;
-  gtk_css_provider_load_from_data(provider, css.c_str(), -1, &error);
-  DCHECK(!error);
-#endif
-  return ScopedCssProvider(provider);
-}
-
-void ApplyCssProviderToContext(GtkStyleContext* context,
-                               GtkCssProvider* provider) {
-  while (context) {
-    gtk_style_context_add_provider(context, GTK_STYLE_PROVIDER(provider),
-                                   G_MAXUINT);
-    context = gtk_style_context_get_parent(context);
-  }
-}
-
-void ApplyCssToContext(GtkStyleContext* context, const std::string& css) {
-  auto provider = GetCssProvider(css);
-  ApplyCssProviderToContext(context, provider);
-}
-
-void RenderBackground(const gfx::Size& size,
-                      cairo_t* cr,
-                      GtkStyleContext* context) {
-  if (!context)
-    return;
-  RenderBackground(size, cr, gtk_style_context_get_parent(context));
-  gtk_render_background(context, cr, 0, 0, size.width(), size.height());
-}
-
-SkColor GetBgColor(const std::string& css_selector) {
-  return GetBgColorFromStyleContext(GetStyleContextFromCss(css_selector));
-}
-
-SkColor GetBorderColor(const std::string& css_selector) {
-  // Borders have the same issue as backgrounds, due to the
-  // border-image property.
-  auto context = GetStyleContextFromCss(css_selector);
-  gfx::Size size(24, 24);
-  CairoSurface surface(size);
-  gtk_render_frame(context, surface.cairo(), 0, 0, size.width(), size.height());
-  return surface.GetAveragePixelValue(true);
-}
-
-SkColor GetSelectionBgColor(const std::string& css_selector) {
-  auto context = GetStyleContextFromCss(css_selector);
-  if (GtkCheckVersion(3, 20))
-    return GetBgColorFromStyleContext(context);
-  // This is verbatim how Gtk gets the selection color on versions before 3.20.
-  GdkRGBA selection_color;
-  G_GNUC_BEGIN_IGNORE_DEPRECATIONS;
-#if GTK_CHECK_VERSION(3, 90, 0)
-  gtk_style_context_get_background_color(context, &selection_color);
-#else
-  gtk_style_context_get_background_color(
-      context, gtk_style_context_get_state(context), &selection_color);
-#endif
-  G_GNUC_END_IGNORE_DEPRECATIONS;
-  return GdkRgbaToSkColor(selection_color);
-}
-
-bool ContextHasClass(GtkStyleContext* context, const std::string& style_class) {
-  return gtk_style_context_has_class(context, style_class.c_str()) ||
-         gtk_widget_path_iter_has_class(gtk_style_context_get_path(context), -1,
-                                        style_class.c_str());
-}
-
-SkColor GetSeparatorColor(const std::string& css_selector) {
-  if (!GtkCheckVersion(3, 20))
-    return GetFgColor(css_selector);
-
-  auto context = GetStyleContextFromCss(css_selector);
-  int w = 1, h = 1;
-  GtkBorder border, padding;
-#if GTK_CHECK_VERSION(3, 90, 0)
-  gtk_style_context_get(context, "min-width", &w, "min-height", &h, nullptr);
-  gtk_style_context_get_border(context, &border);
-  gtk_style_context_get_padding(context, &padding);
-#else
-  gtk_style_context_get(context, gtk_style_context_get_state(context),
-                        "min-width", &w, "min-height", &h, nullptr);
-  GtkStateFlags state = gtk_style_context_get_state(context);
-  gtk_style_context_get_border(context, state, &border);
-  gtk_style_context_get_padding(context, state, &padding);
-#endif
-  w += border.left + padding.left + padding.right + border.right;
-  h += border.top + padding.top + padding.bottom + border.bottom;
-
-  bool horizontal = ContextHasClass(context, "horizontal");
-  if (horizontal) {
-    w = 24;
-    h = std::max(h, 1);
-  } else {
-    DCHECK(ContextHasClass(context, "vertical"));
-    h = 24;
-    w = std::max(w, 1);
-  }
-
-  CairoSurface surface(gfx::Size(w, h));
-  gtk_render_background(context, surface.cairo(), 0, 0, w, h);
-  gtk_render_frame(context, surface.cairo(), 0, 0, w, h);
-  return surface.GetAveragePixelValue(false);
-}
-
 std::string GetGtkSettingsStringProperty(GtkSettings* settings,
                                          const gchar* prop_name) {
   GValue layout = G_VALUE_INIT;
@@ -591,12 +210,12 @@ GdkEvent* GdkEventFromKeyEvent(const ui::KeyEvent& key_event) {
 
   // Get keyval and state
   GdkModifierType state = ExtractGdkEventStateFromKeyEvent(key_event);
-  guint keyval = GDK_KEY_VoidSymbol;
+  guint keyval = 0;
   GdkModifierType consumed;
   gdk_keymap_translate_keyboard_state(keymap, hw_code, state, group, &keyval,
                                       nullptr, nullptr, &consumed);
   gdk_keymap_add_virtual_modifiers(keymap, &state);
-  DCHECK(keyval != GDK_KEY_VoidSymbol);
+  DCHECK(keyval != 0);
 
   // Build GdkEvent
   GdkEvent* gdk_event = gdk_event_new(event_type);
diff --git a/ui/gtk/gtk_util.h b/ui/gtk/gtk_util.h
index 1512a55ed7b0..3ac20c975965 100644
--- a/ui/gtk/gtk_util.h
+++ b/ui/gtk/gtk_util.h
@@ -58,121 +58,6 @@ void ParseButtonLayout(const std::string& button_string,
                        std::vector<views::FrameButton>* leading_buttons,
                        std::vector<views::FrameButton>* trailing_buttons);
 
-class CairoSurface {
- public:
-  // Attaches a cairo surface to an SkBitmap so that GTK can render
-  // into it.  |bitmap| must outlive this CairoSurface.
-  explicit CairoSurface(SkBitmap& bitmap);
-
-  // Creates a new cairo surface with the given size.  The memory for
-  // this surface is deallocated when this CairoSurface is destroyed.
-  explicit CairoSurface(const gfx::Size& size);
-
-  ~CairoSurface();
-
-  // Get the drawing context for GTK to use.
-  cairo_t* cairo() { return cairo_; }
-
-  // Returns the average of all pixels in the surface.  If |frame| is
-  // true, the resulting alpha will be the average alpha, otherwise it
-  // will be the max alpha across all pixels.
-  SkColor GetAveragePixelValue(bool frame);
-
- private:
-  cairo_surface_t* surface_;
-  cairo_t* cairo_;
-};
-
-// Returns true iff the runtime version of Gtk used meets
-// |major|.|minor|.|micro|.
-bool GtkCheckVersion(int major, int minor = 0, int micro = 0);
-
-using ScopedStyleContext = ScopedGObject<GtkStyleContext>;
-using ScopedCssProvider = ScopedGObject<GtkCssProvider>;
-
-}  // namespace gtk
-
-// Template override cannot be in the gtk namespace.
-template <>
-inline void gtk::ScopedStyleContext::Unref() {
-  // Versions of GTK earlier than 3.15.4 had a bug where a g_assert
-  // would be triggered when trying to free a GtkStyleContext that had
-  // a parent whose only reference was the child context in question.
-  // This is a hack to work around that case.  See GTK commit
-  // "gtkstylecontext: Don't try to emit a signal when finalizing".
-  GtkStyleContext* context = obj_;
-  while (context) {
-    GtkStyleContext* parent = gtk_style_context_get_parent(context);
-    if (parent && G_OBJECT(context)->ref_count == 1 &&
-        !gtk::GtkCheckVersion(3, 15, 4)) {
-      g_object_ref(parent);
-      gtk_style_context_set_parent(context, nullptr);
-      g_object_unref(context);
-    } else {
-      g_object_unref(context);
-      return;
-    }
-    context = parent;
-  }
-}
-
-namespace gtk {
-
-// Converts ui::NativeTheme::State to GtkStateFlags.
-GtkStateFlags StateToStateFlags(ui::NativeTheme::State state);
-
-SkColor GdkRgbaToSkColor(const GdkRGBA& color);
-
-// If |context| is nullptr, creates a new top-level style context
-// specified by parsing |css_node|.  Otherwise, creates the child
-// context with |context| as the parent.
-ScopedStyleContext AppendCssNodeToStyleContext(GtkStyleContext* context,
-                                               const std::string& css_node);
-
-// Parses |css_selector| into a GtkStyleContext.  The format is a
-// sequence of whitespace-separated objects.  Each object may have at
-// most one object name at the beginning of the string, and any number
-// of '.'-prefixed classes and ':'-prefixed pseudoclasses.  An example
-// is "GtkButton.button.suggested-action:hover:active".  The caller
-// must g_object_unref() the returned context.
-ScopedStyleContext GetStyleContextFromCss(const std::string& css_selector);
-
-SkColor GetFgColorFromStyleContext(GtkStyleContext* context);
-
-SkColor GetBgColorFromStyleContext(GtkStyleContext* context);
-
-// Overrides properties on |context| and all its parents with those
-// provided by |css|.
-void ApplyCssToContext(GtkStyleContext* context, const std::string& css);
-
-// Get the 'color' property from the style context created by
-// GetStyleContextFromCss(|css_selector|).
-SkColor GetFgColor(const std::string& css_selector);
-
-ScopedCssProvider GetCssProvider(const std::string& css);
-
-// Renders the backgrounds of all ancestors of |context|, then renders
-// the background for |context| itself.
-void RenderBackground(const gfx::Size& size,
-                      cairo_t* cr,
-                      GtkStyleContext* context);
-
-// Renders a background from the style context created by
-// GetStyleContextFromCss(|css_selector|) into a 24x24 bitmap and
-// returns the average color.
-SkColor GetBgColor(const std::string& css_selector);
-
-// Renders the border from the style context created by
-// GetStyleContextFromCss(|css_selector|) into a 24x24 bitmap and
-// returns the average color.
-SkColor GetBorderColor(const std::string& css_selector);
-
-// On Gtk3.20 or later, behaves like GetBgColor.  Otherwise, returns
-// the background-color property.
-SkColor GetSelectionBgColor(const std::string& css_selector);
-
-// Get the color of the GtkSeparator specified by |css_selector|.
-SkColor GetSeparatorColor(const std::string& css_selector);
 
 // Get a GtkSettings property as a C++ string.
 std::string GetGtkSettingsStringProperty(GtkSettings* settings,
diff --git a/ui/gtk/input_method_context_impl_gtk.cc b/ui/gtk/input_method_context_impl_gtk.cc
index b3b03c560ec3..c67c173fb9ec 100644
--- a/ui/gtk/input_method_context_impl_gtk.cc
+++ b/ui/gtk/input_method_context_impl_gtk.cc
@@ -115,7 +115,7 @@ bool InputMethodContextImplGtk::DispatchKeyEvent(
   gint win_y = 0;
   gdk_window_get_origin(target_window, &win_x, &win_y);
 
-  gint factor = gdk_window_get_scale_factor(target_window);
+  gint factor = 1; // fuck HiDPI
   gint caret_x = last_caret_bounds_.x() / factor;
   gint caret_y = last_caret_bounds_.y() / factor;
   gint caret_w = last_caret_bounds_.width() / factor;
diff --git a/ui/gtk/input_method_context_impl_gtk.h b/ui/gtk/input_method_context_impl_gtk.h
index 3423c5a7f0b5..dd87daa55910 100644
--- a/ui/gtk/input_method_context_impl_gtk.h
+++ b/ui/gtk/input_method_context_impl_gtk.h
@@ -12,7 +12,7 @@
 #include "ui/base/ime/linux/linux_input_method_context.h"
 #include "ui/gfx/geometry/rect.h"
 
-typedef struct _GdkWindow GdkWindow;
+typedef struct _GdkDrawable GdkWindow;
 typedef struct _GtkIMContext GtkIMContext;
 
 namespace gtk {
diff --git a/ui/gtk/native_theme_gtk.cc b/ui/gtk/native_theme_gtk.cc
index a77c5718649d..cb7f15924b0e 100644
--- a/ui/gtk/native_theme_gtk.cc
+++ b/ui/gtk/native_theme_gtk.cc
@@ -6,362 +6,335 @@
 
 #include <gtk/gtk.h>
 
+#include "ui/gtk/chrome_gtk_frame.h"
+#include "ui/gtk/chrome_gtk_menu_subclasses.h"
+#include "ui/gtk/gtk_ui.h"
+#include "ui/gtk/gtk_util.h"
+#include "ui/gtk/skia_utils_gtk.h"
+#include "third_party/skia/include/core/SkColor.h"
 #include "ui/gfx/color_palette.h"
 #include "ui/gfx/color_utils.h"
 #include "ui/gfx/geometry/rect.h"
-#include "ui/gfx/skbitmap_operations.h"
+#include "ui/gfx/geometry/size.h"
 #include "ui/gfx/skia_util.h"
 #include "ui/gtk/gtk_util.h"
+#include "ui/native_theme/common_theme.h"
+#include "ui/native_theme/native_theme_aura.h"
 
 namespace gtk {
 
 namespace {
 
-enum BackgroundRenderMode {
-  BG_RENDER_NORMAL,
-  BG_RENDER_NONE,
-  BG_RENDER_RECURSIVE,
+enum WidgetState {
+  NORMAL = 0,
+  ACTIVE = 1,
+  PRELIGHT = 2,
+  SELECTED = 3,
+  INSENSITIVE = 4,
 };
 
-ScopedStyleContext GetTooltipContext() {
-  return AppendCssNodeToStyleContext(
-      nullptr, GtkCheckVersion(3, 20) ? "#tooltip.background"
-                                      : "GtkWindow#window.background.tooltip");
+// Same order as enum WidgetState above
+const GtkStateType stateMap[] = {
+    GTK_STATE_NORMAL,   GTK_STATE_ACTIVE,      GTK_STATE_PRELIGHT,
+    GTK_STATE_SELECTED, GTK_STATE_INSENSITIVE,
+};
+
+SkColor GetFgColor(GtkWidget* widget, WidgetState state) {
+  return GdkColorToSkColor(gtk_rc_get_style(widget)->fg[stateMap[state]]);
+}
+SkColor GetBgColor(GtkWidget* widget, WidgetState state) {
+  return GdkColorToSkColor(gtk_rc_get_style(widget)->bg[stateMap[state]]);
 }
 
-SkBitmap GetWidgetBitmap(const gfx::Size& size,
-                         GtkStyleContext* context,
-                         BackgroundRenderMode bg_mode,
-                         bool render_frame) {
-  DCHECK(bg_mode != BG_RENDER_NONE || render_frame);
-  SkBitmap bitmap;
-  bitmap.allocN32Pixels(size.width(), size.height());
-  bitmap.eraseColor(0);
+SkColor GetTextColor(GtkWidget* widget, WidgetState state) {
+  return GdkColorToSkColor(gtk_rc_get_style(widget)->text[stateMap[state]]);
+}
+SkColor GetTextAAColor(GtkWidget* widget, WidgetState state) {
+  return GdkColorToSkColor(gtk_rc_get_style(widget)->text_aa[stateMap[state]]);
+}
+SkColor GetBaseColor(GtkWidget* widget, WidgetState state) {
+  return GdkColorToSkColor(gtk_rc_get_style(widget)->base[stateMap[state]]);
+}
+
+}  // namespace
+
+// static
+NativeThemeGtk* NativeThemeGtk::instance() {
+  static base::NoDestructor<NativeThemeGtk> s_native_theme;
+  return s_native_theme.get();
+}
 
-  CairoSurface surface(bitmap);
-  cairo_t* cr = surface.cairo();
+// Constructors automatically called
+NativeThemeGtk::NativeThemeGtk() {}
+// This doesn't actually get called
+NativeThemeGtk::~NativeThemeGtk() {}
 
-  switch (bg_mode) {
-    case BG_RENDER_NORMAL:
-      gtk_render_background(context, cr, 0, 0, size.width(), size.height());
+void NativeThemeGtk::PaintMenuPopupBackground(
+    cc::PaintCanvas* canvas,
+    const gfx::Size& size,
+    const MenuBackgroundExtraParams& menu_background,
+    ColorScheme color_scheme) const {
+  if (menu_background.corner_radius > 0) {
+    cc::PaintFlags flags;
+    flags.setStyle(cc::PaintFlags::kFill_Style);
+    flags.setAntiAlias(true);
+    flags.setColor(GetSystemColor(kColorId_MenuBackgroundColor));
+
+    SkPath path;
+    SkRect rect = SkRect::MakeWH(SkIntToScalar(size.width()),
+                                 SkIntToScalar(size.height()));
+    SkScalar radius = SkIntToScalar(menu_background.corner_radius);
+    SkScalar radii[8] = {radius, radius, radius, radius,
+                         radius, radius, radius, radius};
+    path.addRoundRect(rect, radii);
+
+    canvas->drawPath(path, flags);
+  } else {
+    canvas->drawColor(GetSystemColor(kColorId_MenuBackgroundColor),
+                      SkBlendMode::kSrc);
+  }
+}
+
+void NativeThemeGtk::PaintMenuItemBackground(
+    cc::PaintCanvas* canvas,
+    State state,
+    const gfx::Rect& rect,
+    const MenuItemExtraParams& menu_item,
+    ColorScheme color_scheme) const {
+  SkColor color;
+  cc::PaintFlags flags;
+  switch (state) {
+    case NativeTheme::kNormal:
+    case NativeTheme::kDisabled:
+      color = GetSystemColor(NativeTheme::kColorId_MenuBackgroundColor);
+      flags.setColor(color);
       break;
-    case BG_RENDER_RECURSIVE:
-      RenderBackground(size, cr, context);
+    case NativeTheme::kHovered:
+      color =
+          GetSystemColor(NativeTheme::kColorId_FocusedMenuItemBackgroundColor);
+      flags.setColor(color);
       break;
-    case BG_RENDER_NONE:
+    default:
+      NOTREACHED() << "Invalid state " << state;
       break;
   }
-  if (render_frame)
-    gtk_render_frame(context, cr, 0, 0, size.width(), size.height());
-  bitmap.setImmutable();
-  return bitmap;
-}
-
-void PaintWidget(cc::PaintCanvas* canvas,
-                 const gfx::Rect& rect,
-                 GtkStyleContext* context,
-                 BackgroundRenderMode bg_mode,
-                 bool render_frame) {
-  canvas->drawImage(cc::PaintImage::CreateFromBitmap(GetWidgetBitmap(
-                        rect.size(), context, bg_mode, render_frame)),
-                    rect.x(), rect.y());
+  if (menu_item.corner_radius > 0) {
+    const SkScalar radius = SkIntToScalar(menu_item.corner_radius);
+    canvas->drawRoundRect(gfx::RectToSkRect(rect), radius, radius, flags);
+    return;
+  }
+  canvas->drawRect(gfx::RectToSkRect(rect), flags);
 }
 
-base::Optional<SkColor> SkColorFromColorId(
+SkColor NativeThemeGtk::GetSystemColor(
     ui::NativeTheme::ColorId color_id,
-    const ui::NativeTheme* base_theme,
-    ui::NativeTheme::ColorScheme color_scheme) {
+    ui::NativeTheme::ColorScheme color_scheme) const {
   switch (color_id) {
     // Windows
     case ui::NativeTheme::kColorId_WindowBackground:
+      return GetBgColor(GetWindow(), SELECTED);
+
     // Dialogs
     case ui::NativeTheme::kColorId_DialogBackground:
     case ui::NativeTheme::kColorId_BubbleBackground:
     // Notifications
     case ui::NativeTheme::kColorId_NotificationDefaultBackground:
-      return GetBgColor("");
+      return GetBgColor(GetWindow(), NORMAL);
     case ui::NativeTheme::kColorId_DialogForeground:
     case ui::NativeTheme::kColorId_BubbleForeground:
-      return GetFgColor("GtkLabel");
+      return GetFgColor(GetLabel(), NORMAL);
     case ui::NativeTheme::kColorId_BubbleFooterBackground:
-      return GetBgColor("#statusbar");
+      return GetBgColor(GetLabel(), NORMAL);
 
     // FocusableBorder
     case ui::NativeTheme::kColorId_FocusedBorderColor:
-      // GetBorderColor("GtkEntry#entry:focus") is correct here.  The focus ring
-      // around widgets is usually a lighter version of the "canonical theme
-      // color" - orange on Ambiance, blue on Adwaita, etc.  However, Chrome
-      // lightens the color we give it, so it would look wrong if we give it an
-      // already-lightened color.  This workaround returns the theme color
-      // directly, taken from a selected table row.  This has matched the theme
-      // color on every theme that I've tested.
-      return GetBgColor(
-          "GtkTreeView#treeview.view "
-          "GtkTreeView#treeview.view.cell:selected:focus");
+      return GetTextColor(GetMenuItem(), SELECTED);
     case ui::NativeTheme::kColorId_UnfocusedBorderColor:
-      return GetBorderColor("GtkEntry#entry");
+      return GetTextAAColor(GetEntry(), NORMAL);
 
     // Menu
     case ui::NativeTheme::kColorId_MenuBackgroundColor:
     case ui::NativeTheme::kColorId_HighlightedMenuItemBackgroundColor:
     case ui::NativeTheme::kColorId_MenuItemInitialAlertBackgroundColor:
     case ui::NativeTheme::kColorId_MenuItemTargetAlertBackgroundColor:
-      return GetBgColor("GtkMenu#menu");
+      return GetBgColor(GetMenuItem(), NORMAL);
     case ui::NativeTheme::kColorId_MenuBorderColor:
-      return GetBorderColor("GtkMenu#menu");
+      return GetTextColor(GetMenuItem(), INSENSITIVE);
     case ui::NativeTheme::kColorId_FocusedMenuItemBackgroundColor:
-      return GetBgColor("GtkMenu#menu GtkMenuItem#menuitem:hover");
+      return GetBgColor(GetMenuItem(), SELECTED);
     case ui::NativeTheme::kColorId_EnabledMenuItemForegroundColor:
     case ui::NativeTheme::kColorId_MenuDropIndicator:
     case ui::NativeTheme::kColorId_HighlightedMenuItemForegroundColor:
-      return GetFgColor("GtkMenu#menu GtkMenuItem#menuitem GtkLabel");
+      return GetTextColor(GetMenuItem(), NORMAL);
     case ui::NativeTheme::kColorId_SelectedMenuItemForegroundColor:
-      return GetFgColor("GtkMenu#menu GtkMenuItem#menuitem:hover GtkLabel");
+      return GetTextColor(GetMenuItem(), SELECTED);
     case ui::NativeTheme::kColorId_DisabledMenuItemForegroundColor:
-      return GetFgColor("GtkMenu#menu GtkMenuItem#menuitem:disabled GtkLabel");
+      return GetTextColor(GetMenuItem(), INSENSITIVE);
     case ui::NativeTheme::kColorId_MenuItemMinorTextColor:
-      if (GtkCheckVersion(3, 20)) {
-        return GetFgColor("GtkMenu#menu GtkMenuItem#menuitem #accelerator");
-      }
-      return GetFgColor(
-          "GtkMenu#menu GtkMenuItem#menuitem GtkLabel.accelerator");
+      return GetTextColor(GetMenuItem(), INSENSITIVE);
     case ui::NativeTheme::kColorId_MenuSeparatorColor:
-      if (GtkCheckVersion(3, 20)) {
-        return GetSeparatorColor(
-            "GtkMenu#menu GtkSeparator#separator.horizontal");
-      }
-      return GetFgColor("GtkMenu#menu GtkMenuItem#menuitem.separator");
+      return GetTextColor(GetMenuItem(), INSENSITIVE);
 
     // Dropdown
     case ui::NativeTheme::kColorId_DropdownBackgroundColor:
-      return GetBgColor(
-          "GtkComboBoxText#combobox GtkWindow#window.background.popup "
-          "GtkTreeMenu#menu(gtk-combobox-popup-menu) GtkMenuItem#menuitem "
-          "GtkCellView#cellview");
+      return GetBgColor(GetMenuItem(), NORMAL);
     case ui::NativeTheme::kColorId_DropdownForegroundColor:
-      return GetFgColor(
-          "GtkComboBoxText#combobox GtkWindow#window.background.popup "
-          "GtkTreeMenu#menu(gtk-combobox-popup-menu) GtkMenuItem#menuitem "
-          "GtkCellView#cellview");
+      return GetFgColor(GetMenuItem(), NORMAL);
     case ui::NativeTheme::kColorId_DropdownSelectedBackgroundColor:
-      return GetBgColor(
-          "GtkComboBoxText#combobox GtkWindow#window.background.popup "
-          "GtkTreeMenu#menu(gtk-combobox-popup-menu) "
-          "GtkMenuItem#menuitem:hover GtkCellView#cellview");
+      return GetBgColor(GetMenuItem(), SELECTED);
     case ui::NativeTheme::kColorId_DropdownSelectedForegroundColor:
-      return GetFgColor(
-          "GtkComboBoxText#combobox GtkWindow#window.background.popup "
-          "GtkTreeMenu#menu(gtk-combobox-popup-menu) "
-          "GtkMenuItem#menuitem:hover GtkCellView#cellview");
+      return GetFgColor(GetMenuItem(), SELECTED);
 
     // Label
     case ui::NativeTheme::kColorId_LabelEnabledColor:
-      return GetFgColor("GtkLabel");
+      return GetTextColor(GetLabel(), NORMAL);
     case ui::NativeTheme::kColorId_LabelDisabledColor:
     case ui::NativeTheme::kColorId_LabelSecondaryColor:
-      return GetFgColor("GtkLabel:disabled");
+      return GetTextColor(GetLabel(), INSENSITIVE);
     case ui::NativeTheme::kColorId_LabelTextSelectionColor:
-      return GetFgColor(GtkCheckVersion(3, 20) ? "GtkLabel #selection"
-                                               : "GtkLabel:selected");
+      return GetTextColor(GetLabel(), SELECTED);
     case ui::NativeTheme::kColorId_LabelTextSelectionBackgroundFocused:
-      return GetSelectionBgColor(GtkCheckVersion(3, 20) ? "GtkLabel #selection"
-                                                        : "GtkLabel:selected");
+      return GetBaseColor(GetLabel(), SELECTED);
 
     // Link
     case ui::NativeTheme::kColorId_LinkDisabled:
       return SkColorSetA(
-          base_theme->GetSystemColor(ui::NativeTheme::kColorId_LinkEnabled,
-                                     color_scheme),
+          GetSystemColor(ui::NativeTheme::kColorId_LinkEnabled, color_scheme),
           0xBB);
     case ui::NativeTheme::kColorId_LinkPressed:
-      if (GtkCheckVersion(3, 12))
-        return GetFgColor("GtkLabel.link:link:hover:active");
-      FALLTHROUGH;
     case ui::NativeTheme::kColorId_LinkEnabled: {
-      if (GtkCheckVersion(3, 12))
-        return GetFgColor("GtkLabel.link:link");
-#if !GTK_CHECK_VERSION(3, 90, 0)
-      auto link_context = GetStyleContextFromCss("GtkLabel.view");
-      GdkColor* color;
-      gtk_style_context_get_style(link_context, "link-color", &color, nullptr);
-      if (color) {
-        SkColor ret_color =
-            SkColorSetRGB(color->red >> 8, color->green >> 8, color->blue >> 8);
-        // gdk_color_free() was deprecated in Gtk3.14.  This code path is only
-        // taken on versions earlier than Gtk3.12, but the compiler doesn't know
-        // that, so silence the deprecation warnings.
-        G_GNUC_BEGIN_IGNORE_DEPRECATIONS;
-        gdk_color_free(color);
-        G_GNUC_END_IGNORE_DEPRECATIONS;
-        return ret_color;
+      SkColor link_color = SK_ColorTRANSPARENT;
+      GdkColor* style_color = nullptr;
+      gtk_widget_style_get(GetWindow(), "link-color", &style_color, nullptr);
+      if (style_color) {
+        link_color = GdkColorToSkColor(*style_color);
+        gdk_color_free(style_color);
       }
-#endif
+      if (link_color != SK_ColorTRANSPARENT)
+        return link_color;
       // Default color comes from gtklinkbutton.c.
       return SkColorSetRGB(0x00, 0x00, 0xEE);
     }
 
     // Scrollbar
     case ui::NativeTheme::kColorId_OverlayScrollbarThumbBackground:
-      return GetBgColor("#GtkScrollbar#scrollbar #trough");
+      return GetBgColor(GetButton(), NORMAL);
     case ui::NativeTheme::kColorId_OverlayScrollbarThumbForeground:
-      return GetBgColor("#GtkScrollbar#scrollbar #slider");
+      return GetBgColor(GetButton(), PRELIGHT);
 
     // Slider
     case ui::NativeTheme::kColorId_SliderThumbDefault:
-      return GetBgColor("GtkScale#scale #highlight");
     case ui::NativeTheme::kColorId_SliderTroughDefault:
-      return GetBgColor("GtkScale#scale #trough");
     case ui::NativeTheme::kColorId_SliderThumbMinimal:
-      return GetBgColor("GtkScale#scale:disabled #highlight");
     case ui::NativeTheme::kColorId_SliderTroughMinimal:
-      return GetBgColor("GtkScale#scale:disabled #trough");
+      return GetBgColor(GetButton(), PRELIGHT);
 
     // Separator
     case ui::NativeTheme::kColorId_SeparatorColor:
-      return GetSeparatorColor("GtkSeparator#separator.horizontal");
+      return GetFgColor(GetSeparator(), INSENSITIVE);
 
     // Button
     case ui::NativeTheme::kColorId_ButtonColor:
-      return GetBgColor("GtkButton#button");
+      return GetBgColor(GetButton(), NORMAL);
     case ui::NativeTheme::kColorId_ButtonEnabledColor:
     case ui::NativeTheme::kColorId_ButtonUncheckedColor:
-      return GetFgColor("GtkButton#button.text-button GtkLabel");
+      return GetTextColor(GetButton(), NORMAL);
     case ui::NativeTheme::kColorId_ButtonDisabledColor:
-      return GetFgColor("GtkButton#button.text-button:disabled GtkLabel");
-    // TODO(thomasanderson): Add this once this CL lands:
-    // https://chromium-review.googlesource.com/c/chromium/src/+/2053144
-    // case ui::NativeTheme::kColorId_ButtonHoverColor:
-    //   return GetBgColor("GtkButton#button:hover");
+      return GetTextColor(GetButton(), INSENSITIVE);
 
     // ProminentButton
     case ui::NativeTheme::kColorId_ButtonCheckedColor:
     case ui::NativeTheme::kColorId_ProminentButtonColor:
     case ui::NativeTheme::kColorId_ProminentButtonFocusedColor:
-      return GetBgColor(
-          "GtkTreeView#treeview.view "
-          "GtkTreeView#treeview.view.cell:selected:focus");
+      return GetBgColor(GetLabel(), SELECTED);
     case ui::NativeTheme::kColorId_TextOnProminentButtonColor:
-      return GetFgColor(
-          "GtkTreeView#treeview.view "
-          "GtkTreeView#treeview.view.cell:selected:focus GtkLabel");
+      return GetTextColor(GetLabel(), SELECTED);
     case ui::NativeTheme::kColorId_ProminentButtonDisabledColor:
-      return GetBgColor("GtkButton#button.text-button:disabled");
+      return GetBgColor(GetLabel(), INSENSITIVE);
     case ui::NativeTheme::kColorId_ButtonBorderColor:
-      return GetBorderColor("GtkButton#button.text-button");
-    // TODO(thomasanderson): Add this once this CL lands:
-    // https://chromium-review.googlesource.com/c/chromium/src/+/2053144
-    // case ui::NativeTheme::kColorId_ProminentButtonHoverColor:
-    //   return GetBgColor(
-    //       "GtkTreeView#treeview.view "
-    //       "GtkTreeView#treeview.view.cell:selected:focus:hover");
+      return GetBgColor(GetLabel(), INSENSITIVE);
 
     // ToggleButton
     case ui::NativeTheme::kColorId_ToggleButtonTrackColorOff:
-      return GetBgColor("GtkButton#button.text-button.toggle");
+      return GetBgColor(GetButton(), NORMAL);
     case ui::NativeTheme::kColorId_ToggleButtonTrackColorOn:
-      return GetBgColor("GtkButton#button.text-button.toggle:checked");
+      return GetBgColor(GetButton(), SELECTED);
 
     // TabbedPane
     case ui::NativeTheme::kColorId_TabTitleColorActive:
-      return GetFgColor("GtkLabel");
+      return GetTextColor(GetEntry(), NORMAL);
     case ui::NativeTheme::kColorId_TabTitleColorInactive:
-      return GetFgColor("GtkLabel:disabled");
+      return GetTextColor(GetLabel(), INSENSITIVE);
     case ui::NativeTheme::kColorId_TabBottomBorder:
-      return GetBorderColor(GtkCheckVersion(3, 20) ? "GtkFrame#frame #border"
-                                                   : "GtkFrame#frame");
+      return GetTextColor(GetEntry(), NORMAL);
     case ui::NativeTheme::kColorId_TabHighlightBackground:
-      return GetBgColor("GtkNotebook#notebook #tab:checked");
+      return GetBgColor(GetEntry(), NORMAL);
     case ui::NativeTheme::kColorId_TabHighlightFocusedBackground:
-      return GetBgColor("GtkNotebook#notebook:focus #tab:checked");
+      return GetBgColor(GetEntry(), PRELIGHT);
 
     // Textfield
     case ui::NativeTheme::kColorId_TextfieldDefaultColor:
-      return GetFgColor(GtkCheckVersion(3, 20)
-                            ? "GtkTextView#textview.view #text"
-                            : "GtkTextView.view");
+      return GetTextColor(GetEntry(), NORMAL);
     case ui::NativeTheme::kColorId_TextfieldDefaultBackground:
-      return GetBgColor(GtkCheckVersion(3, 20) ? "GtkTextView#textview.view"
-                                               : "GtkTextView.view");
+      return GetBaseColor(GetEntry(), NORMAL);
     case ui::NativeTheme::kColorId_TextfieldPlaceholderColor:
-      if (!GtkCheckVersion(3, 90)) {
-        auto context = GetStyleContextFromCss("GtkEntry#entry");
-        // This is copied from gtkentry.c.
-        GdkRGBA fg = {0.5, 0.5, 0.5};
-        gtk_style_context_lookup_color(context, "placeholder_text_color", &fg);
-        return GdkRgbaToSkColor(fg);
-      }
-      return GetFgColor("GtkEntry#entry #text #placeholder");
+      return GetTextColor(GetEntry(), INSENSITIVE);
     case ui::NativeTheme::kColorId_TextfieldReadOnlyColor:
-      return GetFgColor(GtkCheckVersion(3, 20)
-                            ? "GtkTextView#textview.view:disabled #text"
-                            : "GtkTextView.view:disabled");
+      return GetTextColor(GetEntry(), INSENSITIVE);
     case ui::NativeTheme::kColorId_TextfieldReadOnlyBackground:
-      return GetBgColor(GtkCheckVersion(3, 20)
-                            ? "GtkTextView#textview.view:disabled"
-                            : "GtkTextView.view:disabled");
+      return GetBgColor(GetEntry(), INSENSITIVE);
     case ui::NativeTheme::kColorId_TextfieldSelectionColor:
-      return GetFgColor(GtkCheckVersion(3, 20)
-                            ? "GtkTextView#textview.view #text #selection"
-                            : "GtkTextView.view:selected");
+      return GetTextColor(GetEntry(), SELECTED);
     case ui::NativeTheme::kColorId_TextfieldSelectionBackgroundFocused:
-      return GetSelectionBgColor(
-          GtkCheckVersion(3, 20) ? "GtkTextView#textview.view #text #selection"
-                                 : "GtkTextView.view:selected");
+      return GetBaseColor(GetEntry(), SELECTED);
 
     // Tooltips
     case ui::NativeTheme::kColorId_TooltipBackground:
-      return GetBgColorFromStyleContext(GetTooltipContext());
+      return GetBgColor(GetTooltip(), NORMAL);
     case ui::NativeTheme::kColorId_TooltipIcon:
-      return GetFgColor("GtkButton#button.image-button");
+      return GetFgColor(GetTooltip(), NORMAL);
     case ui::NativeTheme::kColorId_TooltipIconHovered:
-      return GetFgColor("GtkButton#button.image-button:hover");
-    case ui::NativeTheme::kColorId_TooltipText: {
-      auto context = GetTooltipContext();
-      context = AppendCssNodeToStyleContext(context, "GtkLabel");
-      return GetFgColorFromStyleContext(context);
-    }
+      return GetFgColor(GetTooltip(), PRELIGHT);
+    case ui::NativeTheme::kColorId_TooltipText:
+      return GetTextColor(GetTooltip(), NORMAL);
 
     // Trees and Tables (implemented on GTK using the same class)
     case ui::NativeTheme::kColorId_TableBackground:
     case ui::NativeTheme::kColorId_TableBackgroundAlternate:
     case ui::NativeTheme::kColorId_TreeBackground:
-      return GetBgColor(
-          "GtkTreeView#treeview.view GtkTreeView#treeview.view.cell");
+      return GetBgColor(GetTree(), NORMAL);
     case ui::NativeTheme::kColorId_TableText:
     case ui::NativeTheme::kColorId_TreeText:
     case ui::NativeTheme::kColorId_TableGroupingIndicatorColor:
-      return GetFgColor(
-          "GtkTreeView#treeview.view GtkTreeView#treeview.view.cell GtkLabel");
+      return GetFgColor(GetTree(), NORMAL);
     case ui::NativeTheme::kColorId_TableSelectedText:
     case ui::NativeTheme::kColorId_TableSelectedTextUnfocused:
     case ui::NativeTheme::kColorId_TreeSelectedText:
     case ui::NativeTheme::kColorId_TreeSelectedTextUnfocused:
-      return GetFgColor(
-          "GtkTreeView#treeview.view "
-          "GtkTreeView#treeview.view.cell:selected:focus GtkLabel");
+      return GetTextColor(GetTree(), NORMAL);
     case ui::NativeTheme::kColorId_TableSelectionBackgroundFocused:
     case ui::NativeTheme::kColorId_TableSelectionBackgroundUnfocused:
     case ui::NativeTheme::kColorId_TreeSelectionBackgroundFocused:
     case ui::NativeTheme::kColorId_TreeSelectionBackgroundUnfocused:
-      return GetBgColor(
-          "GtkTreeView#treeview.view "
-          "GtkTreeView#treeview.view.cell:selected:focus");
+      return GetBgColor(GetTree(), SELECTED);
 
     // Table Header
     case ui::NativeTheme::kColorId_TableHeaderText:
-      return GetFgColor("GtkTreeView#treeview.view GtkButton#button GtkLabel");
+      return GetTextColor(GetTree(), NORMAL);
     case ui::NativeTheme::kColorId_TableHeaderBackground:
-      return GetBgColor("GtkTreeView#treeview.view GtkButton#button");
+      return GetBgColor(GetTree(), NORMAL);
     case ui::NativeTheme::kColorId_TableHeaderSeparator:
-      return GetBorderColor("GtkTreeView#treeview.view GtkButton#button");
+      return GetFgColor(GetSeparator(), INSENSITIVE);
 
     // Throbber
-    // TODO(thomasanderson): Render GtkSpinner directly.
     case ui::NativeTheme::kColorId_ThrobberSpinningColor:
-      return GetFgColor("GtkSpinner#spinner");
+      return GetSystemColor(kColorId_TextfieldSelectionBackgroundFocused);
     case ui::NativeTheme::kColorId_ThrobberWaitingColor:
+      return color_utils::AlphaBlend(
+          GetSystemColor(kColorId_TextfieldSelectionBackgroundFocused),
+          GetBgColor(GetWindow(), NORMAL), SkAlpha(0x80));
     case ui::NativeTheme::kColorId_ThrobberLightColor:
-      return GetFgColor("GtkSpinner#spinner:disabled");
+      return GetSystemColor(kColorId_TextfieldSelectionBackgroundFocused);
 
     // Alert icons
     // Fallback to the same colors as Aura.
@@ -372,19 +345,17 @@ base::Optional<SkColor> SkColorFromColorId(
       // color (the GTK window bg color) to determine if the dark
       // or light native theme should be used for the icons.
       ui::NativeTheme* fallback_theme =
-          color_utils::IsDark(GetBgColor(""))
+          color_utils::IsDark(GetTextColor(GetEntry(), NORMAL))
               ? ui::NativeTheme::GetInstanceForDarkUI()
               : ui::NativeTheme::GetInstanceForNativeUi();
       return fallback_theme->GetSystemColor(color_id);
     }
 
     case ui::NativeTheme::kColorId_MenuIconColor:
-      if (GtkCheckVersion(3, 20))
-        return GetFgColor("GtkMenu#menu GtkMenuItem#menuitem #radio");
-      return GetFgColor("GtkMenu#menu GtkMenuItem#menuitem.radio");
+      return GetFgColor(GetMenu(), NORMAL);
 
     case ui::NativeTheme::kColorId_DefaultIconColor:
-      return GetFgColor("GtkButton#button.flat.scale GtkImage#image");
+      return GetTextColor(GetLabel(), NORMAL);
 
     case ui::NativeTheme::kColorId_NumColors:
       NOTREACHED();
@@ -393,328 +364,102 @@ base::Optional<SkColor> SkColorFromColorId(
     default:
       break;
   }
-  return base::nullopt;
-}
-
-}  // namespace
 
-// static
-NativeThemeGtk* NativeThemeGtk::instance() {
-  static base::NoDestructor<NativeThemeGtk> s_native_theme;
-  return s_native_theme.get();
+  return gfx::kPlaceholderColor;
 }
 
-NativeThemeGtk::NativeThemeGtk() {
-  // These types are needed by g_type_from_name(), but may not be registered at
-  // this point.  We need the g_type_class magic to make sure the compiler
-  // doesn't optimize away this code.
-  g_type_class_unref(g_type_class_ref(gtk_button_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_entry_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_frame_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_header_bar_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_image_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_info_bar_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_label_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_menu_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_menu_bar_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_menu_item_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_range_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_scrollbar_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_scrolled_window_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_separator_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_spinner_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_text_view_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_toggle_button_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_tree_view_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_window_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_combo_box_text_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_cell_view_get_type()));
+GtkWidget* NativeThemeGtk::GetWindow() const {
+  static GtkWidget* fake_window = nullptr;
 
-  // Initialize the GtkTreeMenu type.  _gtk_tree_menu_get_type() is private, so
-  // we need to initialize it indirectly.
-  ScopedGObject<GtkTreeModel> model{
-      GTK_TREE_MODEL(gtk_tree_store_new(1, G_TYPE_STRING))};
-  ScopedGObject<GtkWidget> combo{gtk_combo_box_new_with_model(model)};
+  if (!fake_window) {
+    fake_window = chrome_gtk_frame_new();
+    gtk_widget_realize(fake_window);
+  }
 
-  OnThemeChanged(gtk_settings_get_default(), nullptr);
+  return fake_window;
 }
 
-NativeThemeGtk::~NativeThemeGtk() {
-  NOTREACHED();
-}
+GtkWidget* NativeThemeGtk::GetEntry() const {
+  static GtkWidget* fake_entry = nullptr;
 
-void NativeThemeGtk::SetThemeCssOverride(ScopedCssProvider provider) {
-  if (theme_css_override_) {
-    gtk_style_context_remove_provider_for_screen(
-        gdk_screen_get_default(),
-        GTK_STYLE_PROVIDER(theme_css_override_.get()));
-  }
-  theme_css_override_ = std::move(provider);
-  if (theme_css_override_) {
-    gtk_style_context_add_provider_for_screen(
-        gdk_screen_get_default(), GTK_STYLE_PROVIDER(theme_css_override_.get()),
-        GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
+  if (!fake_entry) {
+    fake_entry = gtk_entry_new();
+
+    // The fake entry needs to be in the window so it can be realized so we can
+    // use the computed parts of the style.
+    gtk_container_add(GTK_CONTAINER(GetWindow()), fake_entry);
+    gtk_widget_realize(fake_entry);
   }
+
+  return fake_entry;
 }
 
-void NativeThemeGtk::OnThemeChanged(GtkSettings* settings,
-                                    GtkParamSpec* param) {
-  SetThemeCssOverride(ScopedCssProvider());
-  for (auto& color : color_cache_)
-    color = base::nullopt;
+GtkWidget* NativeThemeGtk::GetLabel() const {
+  static GtkWidget* fake_label = nullptr;
 
-  // Hack to workaround a bug on GNOME standard themes which would
-  // cause black patches to be rendered on GtkFileChooser dialogs.
-  std::string theme_name =
-      GetGtkSettingsStringProperty(settings, "gtk-theme-name");
-  if (!GtkCheckVersion(3, 14)) {
-    if (theme_name == "Adwaita") {
-      SetThemeCssOverride(GetCssProvider(
-          "GtkFileChooser GtkPaned { background-color: @theme_bg_color; }"));
-    } else if (theme_name == "HighContrast") {
-      SetThemeCssOverride(GetCssProvider(
-          "GtkFileChooser GtkPaned { background-color: @theme_base_color; }"));
-    }
-  }
+  if (!fake_label)
+    fake_label = gtk_label_new("");
 
-  // GTK has a dark mode setting called "gtk-application-prefer-dark-theme", but
-  // this is really only used for themes that have a dark or light variant that
-  // gets toggled based on this setting (eg. Adwaita).  Most dark themes do not
-  // have a light variant and aren't affected by the setting.  Because of this,
-  // experimentally check if the theme is dark by checking if the window
-  // background color is dark.
-  set_use_dark_colors(
-      color_utils::IsDark(GetSystemColor(kColorId_WindowBackground)));
-  set_preferred_color_scheme(CalculatePreferredColorScheme());
+  return fake_label;
+}
 
-  // GTK doesn't have a native high contrast setting.  Rather, it's implied by
-  // the theme name.  The only high contrast GTK themes that I know of are
-  // HighContrast (GNOME) and ContrastHighInverse (MATE).  So infer the contrast
-  // based on if the theme name contains both "high" and "contrast",
-  // case-insensitive.
-  std::transform(theme_name.begin(), theme_name.end(), theme_name.begin(),
-                 ::tolower);
-  set_high_contrast(theme_name.find("high") != std::string::npos &&
-                    theme_name.find("contrast") != std::string::npos);
+GtkWidget* NativeThemeGtk::GetButton() const {
+  static GtkWidget* fake_button = nullptr;
 
-  NotifyObservers();
-}
+  if (!fake_button)
+    fake_button = gtk_button_new();
 
-SkColor NativeThemeGtk::GetSystemColor(ColorId color_id,
-                                       ColorScheme color_scheme) const {
-  base::Optional<SkColor> color = color_cache_[color_id];
-  if (!color) {
-    color = SkColorFromColorId(color_id, this, color_scheme);
-    if (!color)
-      color = ui::NativeThemeBase::GetSystemColor(color_id, color_scheme);
-    color_cache_[color_id] = color;
-  }
-  DCHECK(color);
-  return color.value();
+  return fake_button;
 }
 
-void NativeThemeGtk::PaintArrowButton(
-    cc::PaintCanvas* canvas,
-    const gfx::Rect& rect,
-    Part direction,
-    State state,
-    ColorScheme color_scheme,
-    const ScrollbarArrowExtraParams& arrow) const {
-  auto context = GetStyleContextFromCss(
-      GtkCheckVersion(3, 20)
-          ? "GtkScrollbar#scrollbar #contents GtkButton#button"
-          : "GtkRange.scrollbar.button");
-  GtkStateFlags state_flags = StateToStateFlags(state);
-  gtk_style_context_set_state(context, state_flags);
+GtkWidget* NativeThemeGtk::GetTree() const {
+  static GtkWidget* fake_tree = nullptr;
 
-  switch (direction) {
-    case kScrollbarUpArrow:
-      gtk_style_context_add_class(context, GTK_STYLE_CLASS_TOP);
-      break;
-    case kScrollbarRightArrow:
-      gtk_style_context_add_class(context, GTK_STYLE_CLASS_RIGHT);
-      break;
-    case kScrollbarDownArrow:
-      gtk_style_context_add_class(context, GTK_STYLE_CLASS_BOTTOM);
-      break;
-    case kScrollbarLeftArrow:
-      gtk_style_context_add_class(context, GTK_STYLE_CLASS_LEFT);
-      break;
-    default:
-      NOTREACHED();
-  }
+  if (!fake_tree)
+    fake_tree = gtk_tree_view_new();
 
-  PaintWidget(canvas, rect, context, BG_RENDER_NORMAL, true);
-  PaintArrow(canvas, rect, direction, GetFgColorFromStyleContext(context));
+  return fake_tree;
 }
 
-void NativeThemeGtk::PaintScrollbarTrack(
-    cc::PaintCanvas* canvas,
-    Part part,
-    State state,
-    const ScrollbarTrackExtraParams& extra_params,
-    const gfx::Rect& rect,
-    ColorScheme color_scheme) const {
-  PaintWidget(
-      canvas, rect,
-      GetStyleContextFromCss(GtkCheckVersion(3, 20)
-                                 ? "GtkScrollbar#scrollbar #contents #trough"
-                                 : "GtkScrollbar.scrollbar.trough"),
-      BG_RENDER_NORMAL, true);
-}
+GtkWidget* NativeThemeGtk::GetTooltip() const {
+  static GtkWidget* fake_tooltip = nullptr;
 
-void NativeThemeGtk::PaintScrollbarThumb(
-    cc::PaintCanvas* canvas,
-    Part part,
-    State state,
-    const gfx::Rect& rect,
-    NativeTheme::ScrollbarOverlayColorTheme theme,
-    ColorScheme color_scheme) const {
-  auto context = GetStyleContextFromCss(
-      GtkCheckVersion(3, 20)
-          ? "GtkScrollbar#scrollbar #contents #trough #slider"
-          : "GtkScrollbar.scrollbar.slider");
-  gtk_style_context_set_state(context, StateToStateFlags(state));
-  PaintWidget(canvas, rect, context, BG_RENDER_NORMAL, true);
-}
+  if (!fake_tooltip) {
+    fake_tooltip = gtk_window_new(GTK_WINDOW_TOPLEVEL);
+    gtk_widget_set_name(fake_tooltip, "gtk-tooltip");
+    gtk_widget_realize(fake_tooltip);
+  }
 
-void NativeThemeGtk::PaintScrollbarCorner(cc::PaintCanvas* canvas,
-                                          State state,
-                                          const gfx::Rect& rect,
-                                          ColorScheme color_scheme) const {
-  auto context = GetStyleContextFromCss(
-      GtkCheckVersion(3, 19, 2)
-          ? "GtkScrolledWindow#scrolledwindow #junction"
-          : "GtkScrolledWindow.scrolledwindow.scrollbars-junction");
-  PaintWidget(canvas, rect, context, BG_RENDER_NORMAL, true);
+  return fake_tooltip;
 }
 
-void NativeThemeGtk::PaintMenuPopupBackground(
-    cc::PaintCanvas* canvas,
-    const gfx::Size& size,
-    const MenuBackgroundExtraParams& menu_background,
-    ColorScheme color_scheme) const {
-  PaintWidget(canvas, gfx::Rect(size), GetStyleContextFromCss("GtkMenu#menu"),
-              BG_RENDER_RECURSIVE, false);
-}
+GtkWidget* NativeThemeGtk::GetMenu() const {
+  static GtkWidget* fake_menu = nullptr;
 
-void NativeThemeGtk::PaintMenuItemBackground(
-    cc::PaintCanvas* canvas,
-    State state,
-    const gfx::Rect& rect,
-    const MenuItemExtraParams& menu_item,
-    ColorScheme color_scheme) const {
-  auto context = GetStyleContextFromCss("GtkMenu#menu GtkMenuItem#menuitem");
-  gtk_style_context_set_state(context, StateToStateFlags(state));
-  PaintWidget(canvas, rect, context, BG_RENDER_NORMAL, true);
+  if (!fake_menu)
+    fake_menu = gtk_custom_menu_new();
+
+  return fake_menu;
 }
 
-void NativeThemeGtk::PaintMenuSeparator(
-    cc::PaintCanvas* canvas,
-    State state,
-    const gfx::Rect& rect,
-    const MenuSeparatorExtraParams& menu_separator,
-    ColorScheme color_scheme) const {
-  // TODO(estade): use GTK to draw vertical separators too. See
-  // crbug.com/710183
-  if (menu_separator.type == ui::VERTICAL_SEPARATOR) {
-    cc::PaintFlags paint;
-    paint.setStyle(cc::PaintFlags::kFill_Style);
-    paint.setColor(GetSystemColor(ui::NativeTheme::kColorId_MenuSeparatorColor,
-                                  color_scheme));
-    canvas->drawRect(gfx::RectToSkRect(rect), paint);
-    return;
-  }
+GtkWidget* NativeThemeGtk::GetMenuItem() const {
+  static GtkWidget* fake_menu_item = nullptr;
 
-  auto separator_offset = [&](int separator_thickness) {
-    switch (menu_separator.type) {
-      case ui::LOWER_SEPARATOR:
-        return rect.height() - separator_thickness;
-      case ui::UPPER_SEPARATOR:
-        return 0;
-      default:
-        return (rect.height() - separator_thickness) / 2;
-    }
-  };
-  if (GtkCheckVersion(3, 20)) {
-    auto context = GetStyleContextFromCss(
-        "GtkMenu#menu GtkSeparator#separator.horizontal");
-    GtkBorder margin, border, padding;
-    int min_height = 1;
-#if GTK_CHECK_VERSION(3, 90, 0)
-    gtk_style_context_get_margin(context, &margin);
-    gtk_style_context_get_border(context, &border);
-    gtk_style_context_get_padding(context, &padding);
-    gtk_style_context_get(context, "min-height", &min_height, nullptr);
-#else
-    GtkStateFlags state = gtk_style_context_get_state(context);
-    gtk_style_context_get_margin(context, state, &margin);
-    gtk_style_context_get_border(context, state, &border);
-    gtk_style_context_get_padding(context, state, &padding);
-    gtk_style_context_get(context, state, "min-height", &min_height, nullptr);
-#endif
-    int w = rect.width() - margin.left - margin.right;
-    int h = std::max(
-        min_height + padding.top + padding.bottom + border.top + border.bottom,
-        1);
-    int x = margin.left;
-    int y = separator_offset(h);
-    PaintWidget(canvas, gfx::Rect(x, y, w, h), context, BG_RENDER_NORMAL, true);
-  } else {
-#if !GTK_CHECK_VERSION(3, 90, 0)
-    auto context = GetStyleContextFromCss(
-        "GtkMenu#menu GtkMenuItem#menuitem.separator.horizontal");
-    gboolean wide_separators = false;
-    gint separator_height = 0;
-    gtk_style_context_get_style(context, "wide-separators", &wide_separators,
-                                "separator-height", &separator_height, nullptr);
-    // This code was adapted from gtk/gtkmenuitem.c.  For some reason,
-    // padding is used as the margin.
-    GtkBorder padding;
-    gtk_style_context_get_padding(context, gtk_style_context_get_state(context),
-                                  &padding);
-    int w = rect.width() - padding.left - padding.right;
-    int x = rect.x() + padding.left;
-    int h = wide_separators ? separator_height : 1;
-    int y = rect.y() + separator_offset(h);
-    if (wide_separators) {
-      PaintWidget(canvas, gfx::Rect(x, y, w, h), context, BG_RENDER_NONE, true);
-    } else {
-      cc::PaintFlags flags;
-      flags.setColor(GetFgColorFromStyleContext(context));
-      flags.setAntiAlias(true);
-      flags.setStrokeWidth(1);
-      canvas->drawLine(x + 0.5f, y + 0.5f, x + w + 0.5f, y + 0.5f, flags);
-    }
-#endif
+  if (!fake_menu_item) {
+    fake_menu_item = gtk_custom_menu_item_new();
+    gtk_menu_shell_append(GTK_MENU_SHELL(GetMenu()), fake_menu_item);
   }
-}
 
-void NativeThemeGtk::PaintFrameTopArea(
-    cc::PaintCanvas* canvas,
-    State state,
-    const gfx::Rect& rect,
-    const FrameTopAreaExtraParams& frame_top_area,
-    ColorScheme color_scheme) const {
-  auto context = GetStyleContextFromCss(frame_top_area.use_custom_frame
-                                            ? "#headerbar.header-bar.titlebar"
-                                            : "GtkMenuBar#menubar");
-  ApplyCssToContext(context, "* { border-radius: 0px; border-style: none; }");
-  gtk_style_context_set_state(context, frame_top_area.is_active
-                                           ? GTK_STATE_FLAG_NORMAL
-                                           : GTK_STATE_FLAG_BACKDROP);
+  return fake_menu_item;
+}
 
-  SkBitmap bitmap =
-      GetWidgetBitmap(rect.size(), context, BG_RENDER_RECURSIVE, false);
+GtkWidget* NativeThemeGtk::GetSeparator() const {
+  static GtkWidget* fake_separator = nullptr;
 
-  if (frame_top_area.incognito) {
-    bitmap = SkBitmapOperations::CreateHSLShiftedBitmap(
-        bitmap, kDefaultTintFrameIncognito);
-    bitmap.setImmutable();
-  }
+  if (!fake_separator)
+    fake_separator = gtk_hseparator_new();
 
-  canvas->drawImage(cc::PaintImage::CreateFromBitmap(std::move(bitmap)),
-                    rect.x(), rect.y());
+  return fake_separator;
 }
 
-}  // namespace gtk
+}  // namespace libgtkui
diff --git a/ui/gtk/native_theme_gtk.h b/ui/gtk/native_theme_gtk.h
index af2d80892dfd..7194238a9608 100644
--- a/ui/gtk/native_theme_gtk.h
+++ b/ui/gtk/native_theme_gtk.h
@@ -12,14 +12,10 @@
 #include "ui/base/glib/scoped_gobject.h"
 #include "ui/native_theme/native_theme_base.h"
 
-typedef struct _GtkCssProvider GtkCssProvider;
-typedef struct _GtkParamSpec GtkParamSpec;
-typedef struct _GtkSettings GtkSettings;
+typedef struct _GtkWidget GtkWidget;
 
 namespace gtk {
 
-using ScopedCssProvider = ScopedGObject<GtkCssProvider>;
-
 // A version of NativeTheme that uses GTK-rendered widgets.
 class NativeThemeGtk : public ui::NativeThemeBase {
  public:
@@ -29,50 +25,16 @@ class NativeThemeGtk : public ui::NativeThemeBase {
   SkColor GetSystemColor(
       ColorId color_id,
       ColorScheme color_scheme = ColorScheme::kDefault) const override;
-  void PaintArrowButton(cc::PaintCanvas* canvas,
-                        const gfx::Rect& rect,
-                        Part direction,
-                        State state,
-                        ColorScheme color_scheme,
-                        const ScrollbarArrowExtraParams& arrow) const override;
-  void PaintScrollbarTrack(cc::PaintCanvas* canvas,
-                           Part part,
-                           State state,
-                           const ScrollbarTrackExtraParams& extra_params,
-                           const gfx::Rect& rect,
-                           ColorScheme color_scheme) const override;
-  void PaintScrollbarThumb(cc::PaintCanvas* canvas,
-                           Part part,
-                           State state,
-                           const gfx::Rect& rect,
-                           NativeTheme::ScrollbarOverlayColorTheme theme,
-                           ColorScheme color_scheme) const override;
-  void PaintScrollbarCorner(cc::PaintCanvas* canvas,
-                            State state,
-                            const gfx::Rect& rect,
-                            ColorScheme color_scheme) const override;
   void PaintMenuPopupBackground(
       cc::PaintCanvas* canvas,
       const gfx::Size& size,
       const MenuBackgroundExtraParams& menu_background,
       ColorScheme color_scheme) const override;
-  void PaintMenuSeparator(cc::PaintCanvas* canvas,
-                          State state,
-                          const gfx::Rect& rect,
-                          const MenuSeparatorExtraParams& menu_separator,
-                          ColorScheme color_scheme) const override;
   void PaintMenuItemBackground(cc::PaintCanvas* canvas,
                                State state,
                                const gfx::Rect& rect,
                                const MenuItemExtraParams& menu_item,
                                ColorScheme color_scheme) const override;
-  void PaintFrameTopArea(cc::PaintCanvas* canvas,
-                         State state,
-                         const gfx::Rect& rect,
-                         const FrameTopAreaExtraParams& frame_top_area,
-                         ColorScheme color_scheme) const override;
-
-  void OnThemeChanged(GtkSettings* settings, GtkParamSpec* param);
 
  private:
   friend class base::NoDestructor<NativeThemeGtk>;
@@ -80,11 +42,16 @@ class NativeThemeGtk : public ui::NativeThemeBase {
   NativeThemeGtk();
   ~NativeThemeGtk() override;
 
-  void SetThemeCssOverride(ScopedCssProvider provider);
-
-  mutable base::Optional<SkColor> color_cache_[kColorId_NumColors];
-
-  ScopedCssProvider theme_css_override_;
+  // Returns various widgets for theming use.
+  GtkWidget* GetWindow() const;
+  GtkWidget* GetEntry() const;
+  GtkWidget* GetLabel() const;
+  GtkWidget* GetButton() const;
+  GtkWidget* GetTree() const;
+  GtkWidget* GetTooltip() const;
+  GtkWidget* GetMenu() const;
+  GtkWidget* GetMenuItem() const;
+  GtkWidget* GetSeparator() const;
 
   DISALLOW_COPY_AND_ASSIGN(NativeThemeGtk);
 };
diff --git a/ui/gtk/printing/print_dialog_gtk.cc b/ui/gtk/printing/print_dialog_gtk.cc
index f2ed36e1258f..d365afc75a92 100644
--- a/ui/gtk/printing/print_dialog_gtk.cc
+++ b/ui/gtk/printing/print_dialog_gtk.cc
@@ -529,7 +529,7 @@ void PrintDialogGtk::OnResponse(GtkWidget* dialog, int response_id) {
 
 static void OnJobCompletedThunk(GtkPrintJob* print_job,
                                 gpointer user_data,
-                                const GError* error) {
+                                GError* error) {
   static_cast<PrintDialogGtk*>(user_data)->OnJobCompleted(print_job, error);
 }
 void PrintDialogGtk::SendDocumentToPrinter(
diff --git a/ui/gtk/skia_utils_gtk.cc b/ui/gtk/skia_utils_gtk.cc
new file mode 100644
index 000000000000..bea308b6e2cc
--- /dev/null
+++ b/ui/gtk/skia_utils_gtk.cc
@@ -0,0 +1,129 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/check_op.h"
+#include "base/notreached.h"
+#include "ui/gtk/skia_utils_gtk.h"
+
+#include <gdk/gdk.h>
+
+#include "base/logging.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "third_party/skia/include/core/SkUnPreMultiply.h"
+
+namespace gtk {
+
+// GDK_COLOR_RGB multiplies by 257 (= 0x10001) to distribute the bits evenly
+// See: http://www.mindcontrol.org/~hplus/graphics/expand-bits.html
+// To get back, we can just right shift by eight
+// (or, formulated differently, i == (i*257)/256 for all i < 256).
+
+SkColor GdkColorToSkColor(GdkColor color) {
+  return SkColorSetRGB(color.red >> 8, color.green >> 8, color.blue >> 8);
+}
+
+GdkColor SkColorToGdkColor(SkColor color) {
+  GdkColor gdk_color = {
+      0, static_cast<guint16>(SkColorGetR(color) * kSkiaToGDKMultiplier),
+      static_cast<guint16>(SkColorGetG(color) * kSkiaToGDKMultiplier),
+      static_cast<guint16>(SkColorGetB(color) * kSkiaToGDKMultiplier)};
+  return gdk_color;
+}
+
+const SkBitmap GdkPixbufToImageSkia(GdkPixbuf* pixbuf) {
+  // TODO(erg): What do we do in the case where the pixbuf fails these dchecks?
+  // I would prefer to use our gtk based canvas, but that would require
+  // recompiling half of our skia extensions with gtk support, which we can't
+  // do in this build.
+  DCHECK_EQ(GDK_COLORSPACE_RGB, gdk_pixbuf_get_colorspace(pixbuf));
+
+  int n_channels = gdk_pixbuf_get_n_channels(pixbuf);
+  int w = gdk_pixbuf_get_width(pixbuf);
+  int h = gdk_pixbuf_get_height(pixbuf);
+
+  SkBitmap ret;
+  ret.allocN32Pixels(w, h);
+  ret.eraseColor(0);
+
+  uint32_t* skia_data = static_cast<uint32_t*>(ret.getAddr(0, 0));
+
+  if (n_channels == 4) {
+    int total_length = w * h;
+    guchar* gdk_pixels = gdk_pixbuf_get_pixels(pixbuf);
+
+    // Now here's the trick: we need to convert the gdk data (which is RGBA and
+    // isn't premultiplied) to skia (which can be anything and premultiplied).
+    for (int i = 0; i < total_length; ++i, gdk_pixels += 4) {
+      const unsigned char& red = gdk_pixels[0];
+      const unsigned char& green = gdk_pixels[1];
+      const unsigned char& blue = gdk_pixels[2];
+      const unsigned char& alpha = gdk_pixels[3];
+
+      skia_data[i] = SkPreMultiplyARGB(alpha, red, green, blue);
+    }
+  } else if (n_channels == 3) {
+    // Because GDK makes rowstrides word aligned, we need to do something a bit
+    // more complex when a pixel isn't perfectly a word of memory.
+    int rowstride = gdk_pixbuf_get_rowstride(pixbuf);
+    guchar* gdk_pixels = gdk_pixbuf_get_pixels(pixbuf);
+    for (int y = 0; y < h; ++y) {
+      int row = y * rowstride;
+
+      for (int x = 0; x < w; ++x) {
+        guchar* pixel = gdk_pixels + row + (x * 3);
+        const unsigned char& red = pixel[0];
+        const unsigned char& green = pixel[1];
+        const unsigned char& blue = pixel[2];
+
+        skia_data[y * w + x] = SkPreMultiplyARGB(255, red, green, blue);
+      }
+    }
+  } else {
+    NOTREACHED();
+  }
+
+  return ret;
+}
+
+GdkPixbuf* GdkPixbufFromSkBitmap(const SkBitmap& bitmap) {
+  if (bitmap.isNull())
+    return nullptr;
+
+  int width = bitmap.width();
+  int height = bitmap.height();
+
+  GdkPixbuf* pixbuf =
+      gdk_pixbuf_new(GDK_COLORSPACE_RGB,  // The only colorspace gtk supports.
+                     TRUE,                // There is an alpha channel.
+                     8, width, height);
+
+  // SkBitmaps are premultiplied, we need to unpremultiply them.
+  const int kBytesPerPixel = 4;
+  uint8_t* divided = gdk_pixbuf_get_pixels(pixbuf);
+
+  for (int y = 0, i = 0; y < height; y++) {
+    for (int x = 0; x < width; x++) {
+      uint32_t pixel = bitmap.getAddr32(0, y)[x];
+
+      int alpha = SkColorGetA(pixel);
+      if (alpha != 0 && alpha != 255) {
+        SkColor unmultiplied = SkUnPreMultiply::PMColorToColor(pixel);
+        divided[i + 0] = SkColorGetR(unmultiplied);
+        divided[i + 1] = SkColorGetG(unmultiplied);
+        divided[i + 2] = SkColorGetB(unmultiplied);
+        divided[i + 3] = alpha;
+      } else {
+        divided[i + 0] = SkColorGetR(pixel);
+        divided[i + 1] = SkColorGetG(pixel);
+        divided[i + 2] = SkColorGetB(pixel);
+        divided[i + 3] = alpha;
+      }
+      i += kBytesPerPixel;
+    }
+  }
+
+  return pixbuf;
+}
+
+}  // namespace libgtkui
diff --git a/ui/gtk/skia_utils_gtk.h b/ui/gtk/skia_utils_gtk.h
new file mode 100644
index 000000000000..0672b982a8ec
--- /dev/null
+++ b/ui/gtk/skia_utils_gtk.h
@@ -0,0 +1,48 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_UI_LIBGTKUI_SKIA_UTILS_GTK_H_
+#define CHROME_BROWSER_UI_LIBGTKUI_SKIA_UTILS_GTK_H_
+
+#include <gtk/gtk.h>
+#include <stdint.h>
+
+#include "third_party/skia/include/core/SkColor.h"
+
+typedef struct _GdkColor GdkColor;
+
+class SkBitmap;
+
+// Define a macro for creating GdkColors from RGB values.  This is a macro to
+// allow static construction of literals, etc.  Use this like:
+//   GdkColor white = GDK_COLOR_RGB(0xff, 0xff, 0xff);
+#define GDK_COLOR_RGB(r, g, b)               \
+  {                                          \
+    0,                                       \
+    r * ::libgtkui::kSkiaToGDKMultiplier,    \
+    g * ::libgtkui::kSkiaToGDKMultiplier,    \
+    b * ::libgtkui::kSkiaToGDKMultiplier,    \
+  }
+
+namespace gtk {
+
+// Multiply uint8_t color components by this.
+const int kSkiaToGDKMultiplier = 257;
+
+// Converts GdkColors to the ARGB layout Skia expects.
+SkColor GdkColorToSkColor(GdkColor color);
+
+// Converts ARGB to GdkColor.
+GdkColor SkColorToGdkColor(SkColor color);
+
+const SkBitmap GdkPixbufToImageSkia(GdkPixbuf* pixbuf);
+
+// Convert and copy a SkBitmap to a GdkPixbuf. NOTE: this uses BGRAToRGBA, so
+// it is an expensive operation.  The returned GdkPixbuf will have a refcount of
+// 1, and the caller is responsible for unrefing it when done.
+GdkPixbuf* GdkPixbufFromSkBitmap(const SkBitmap& bitmap);
+
+}  // namespace libgtkui
+
+#endif  // CHROME_BROWSER_UI_LIBGTKUI_SKIA_UTILS_GTK_H_
diff --git a/ui/gtk/x/gtk_event_loop_x11.cc b/ui/gtk/x/gtk_event_loop_x11.cc
index b4ba3eb52bb5..71aa91f75f12 100644
--- a/ui/gtk/x/gtk_event_loop_x11.cc
+++ b/ui/gtk/x/gtk_event_loop_x11.cc
@@ -16,7 +16,7 @@
 #include "ui/gfx/x/x11.h"
 
 extern "C" {
-Window gdk_x11_window_get_xid(GdkWindow* window);
+XID gdk_x11_drawable_get_xid(GdkDrawable *drawable);
 }
 
 namespace ui {
@@ -83,7 +83,7 @@ void GtkEventLoopX11::ProcessGdkEventKey(const GdkEventKey& gdk_event_key) {
       .time = static_cast<x11::Time>(gdk_event_key.time),
       .root = ui::GetX11RootWindow(),
       .event = static_cast<x11::Window>(
-          gdk_x11_window_get_xid(gdk_event_key.window)),
+          gdk_x11_drawable_get_xid(gdk_event_key.window)),
       .same_screen = true,
   };
   x11::Event event(key, false);
diff --git a/ui/gtk/x/gtk_ui_delegate_x11.cc b/ui/gtk/x/gtk_ui_delegate_x11.cc
index 88c6e46c14c4..a136936b6ad8 100644
--- a/ui/gtk/x/gtk_ui_delegate_x11.cc
+++ b/ui/gtk/x/gtk_ui_delegate_x11.cc
@@ -22,7 +22,7 @@ GdkWindow* gdk_x11_window_foreign_new_for_display(GdkDisplay* display,
 GdkWindow* gdk_x11_window_lookup_for_display(GdkDisplay* display,
                                              Window window);
 
-Window gdk_x11_window_get_xid(GdkWindow* window);
+XID gdk_x11_drawable_get_xid(GdkDrawable *drawable);
 }
 
 namespace ui {
@@ -30,7 +30,6 @@ namespace ui {
 GtkUiDelegateX11::GtkUiDelegateX11(x11::Connection* connection)
     : connection_(connection) {
   DCHECK(connection_);
-  gdk_set_allowed_backends("x11");
 }
 
 GtkUiDelegateX11::~GtkUiDelegateX11() = default;
@@ -58,7 +57,7 @@ GdkWindow* GtkUiDelegateX11::GetGdkWindow(gfx::AcceleratedWidget window_id) {
 
 bool GtkUiDelegateX11::SetGdkWindowTransientFor(GdkWindow* window,
                                                 gfx::AcceleratedWidget parent) {
-  auto x11_window = static_cast<x11::Window>(gdk_x11_window_get_xid(window));
+  auto x11_window = static_cast<x11::Window>(gdk_x11_drawable_get_xid(window));
   SetProperty(x11_window, x11::Atom::WM_TRANSIENT_FOR, x11::Atom::WINDOW,
               parent);
 
