diff --git a/build/config/linux/gtk/BUILD.gn b/build/config/linux/gtk/BUILD.gn
index ecf95dda763b4..5cc6a042655d7 100644
--- a/build/config/linux/gtk/BUILD.gn
+++ b/build/config/linux/gtk/BUILD.gn
@@ -10,7 +10,7 @@ assert(is_linux, "This file should only be referenced on Linux")
 declare_args() {
   # The (major) version of GTK to build against.  A different version may be
   # loaded at runtime.
-  gtk_version = 3
+  gtk_version = 2
 }
 
 # GN doesn't check visibility for configs so we give this an obviously internal
@@ -22,13 +22,8 @@ pkg_config("gtk_internal_config") {
   packages = [
     "gmodule-2.0",
     "gthread-2.0",
+    "gtk+-2.0",
   ]
-  if (gtk_version == 3) {
-    packages += [ "gtk+-3.0" ]
-  } else {
-    assert(gtk_version == 4)
-    packages += [ "gtk4" ]
-  }
 }
 
 group("gtk") {
@@ -54,12 +49,7 @@ group("gtk") {
 
 # Depend on "gtkprint" to get this.
 pkg_config("gtkprint_internal_config") {
-  if (gtk_version == 3) {
-    packages = [ "gtk+-unix-print-3.0" ]
-  } else {
-    assert(gtk_version == 4)
-    packages = [ "gtk4-unix-print" ]
-  }
+  packages = [ "gtk+-unix-print-2.0" ]
 }
 
 group("gtkprint") {
diff --git a/ui/base/x/x11_util.cc b/ui/base/x/x11_util.cc
index 47bc0b93c92b6..223c69420bb8b 100644
--- a/ui/base/x/x11_util.cc
+++ b/ui/base/x/x11_util.cc
@@ -49,6 +49,7 @@
 #include "ui/gfx/x/connection.h"
 #include "ui/gfx/x/screensaver.h"
 #include "ui/gfx/x/shm.h"
+#include "ui/gfx/x/sync.h"
 #include "ui/gfx/x/x11_atom_cache.h"
 #include "ui/gfx/x/xproto.h"
 #include "ui/gfx/x/xproto_util.h"
diff --git a/ui/gtk/BUILD.gn b/ui/gtk/BUILD.gn
index bef73bd7a6dfc..dfbc4504c63b8 100644
--- a/ui/gtk/BUILD.gn
+++ b/ui/gtk/BUILD.gn
@@ -13,35 +13,14 @@ import("//tools/generate_stubs/rules.gni")
 assert(is_linux || is_chromeos_lacros || is_chromeos,
        "This file should only be referenced on Linux")
 
-source_set("gtk_types") {
-  visibility = [ ":gtk_stubs" ]
-  public = [ "gtk_types.h" ]
-}
-
-generate_stubs("gtk_stubs") {
-  visibility = [ ":gtk" ]
-  sigs = [
-    "gdk_pixbuf.sigs",
-    "gdk.sigs",
-    "gsk.sigs",
-    "gtk.sigs",
-    "gio.sigs",
-  ]
-  extra_header = "gtk.fragment"
-  output_name = "gtk_stubs"
-  public_deps = [
-    ":gtk_types",
-    "//build/config/linux/gtk",
-    "//build/config/linux/gtk:gtkprint",
-  ]
-  logging_function = "LogNoop()"
-  logging_include = "ui/gtk/log_noop.h"
-}
-
 component("gtk") {
   public = [ "gtk_ui_factory.h" ]
 
   sources = [
+    "chrome_gtk_frame.cc",
+    "chrome_gtk_frame.h",
+    "chrome_gtk_menu_subclasses.cc",
+    "chrome_gtk_menu_subclasses.h",
     "gtk_color_mixers.cc",
     "gtk_color_mixers.h",
     "gtk_compat.cc",
@@ -58,8 +37,6 @@ component("gtk") {
     "input_method_context_impl_gtk.h",
     "native_theme_gtk.cc",
     "native_theme_gtk.h",
-    "nav_button_provider_gtk.cc",
-    "nav_button_provider_gtk.h",
     "printing/print_dialog_gtk.cc",
     "printing/print_dialog_gtk.h",
     "printing/printing_gtk_util.cc",
@@ -72,8 +49,8 @@ component("gtk") {
     "select_file_dialog_impl_portal.cc",
     "select_file_dialog_impl_portal.h",
     "settings_provider.h",
-    "settings_provider_gtk.cc",
-    "settings_provider_gtk.h",
+    "skia_utils_gtk.cc",
+    "skia_utils_gtk.h",
   ]
   defines = [ "IS_GTK_IMPL" ]
   configs += [ "//build/config/linux/pangocairo" ]
@@ -90,7 +67,7 @@ component("gtk") {
   }
 
   deps = [
-    ":gtk_stubs",
+    "//build/config/linux/gtk:gtkprint",
     "//base",
     "//components/dbus/thread_linux",
     "//dbus",
diff --git a/ui/gtk/chrome_gtk_frame.cc b/ui/gtk/chrome_gtk_frame.cc
new file mode 100644
index 0000000000000..424ea4d2a843a
--- /dev/null
+++ b/ui/gtk/chrome_gtk_frame.cc
@@ -0,0 +1,154 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/gtk/chrome_gtk_frame.h"
+
+G_GNUC_BEGIN_IGNORE_DEPRECATIONS
+
+G_BEGIN_DECLS
+
+// MetaFrames declaration
+G_DEFINE_TYPE(MetaFrames, meta_frames, GTK_TYPE_WINDOW)
+
+static void meta_frames_class_init(MetaFramesClass* frames_class) {
+  // Noop since we don't declare anything.
+}
+
+static void meta_frames_init(MetaFrames* button) {
+}
+
+
+// ChromeGtkFrame declaration
+G_DEFINE_TYPE(ChromeGtkFrame, chrome_gtk_frame, meta_frames_get_type())
+
+static void chrome_gtk_frame_class_init(ChromeGtkFrameClass* frame_class) {
+  GtkWidgetClass* widget_class = reinterpret_cast<GtkWidgetClass*>(frame_class);
+
+  // Frame tints:
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "frame-color",
+          "Frame Color",
+          "The color that the chrome frame will be. (If unspecified, "
+            " Chrome will take ChromeGtkFrame::bg[SELECTED] and slightly darken"
+            " it.)",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "inactive-frame-color",
+          "Inactive Frame Color",
+          "The color that the inactive chrome frame will be. (If"
+            " unspecified, Chrome will take ChromeGtkFrame::bg[INSENSITIVE]"
+            " and slightly darken it.)",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "incognito-frame-color",
+          "Incognito Frame Color",
+          "The color that the incognito frame will be. (If unspecified,"
+            " Chrome will take the frame color and tint it by Chrome's default"
+            " incognito tint.)",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "incognito-inactive-frame-color",
+          "Incognito Inactive Frame Color",
+          "The color that the inactive incognito frame will be. (If"
+            " unspecified, Chrome will take the frame color and tint it by"
+            " Chrome's default incognito tint.)",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+
+  // Frame gradient control:
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_int(
+          "frame-gradient-size",
+          "Chrome Frame Gradient Size",
+          "The size of the gradient on top of the frame image. Specify 0 to"
+            " make the frame a solid color.",
+          0,      // 0 disables the gradient
+          128,    // The frame image is only up to 128 pixels tall.
+          16,     // By default, gradients are 16 pixels high.
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "frame-gradient-color",
+          "Frame Gradient Color",
+          "The top color of the chrome frame gradient. (If unspecified,"
+            " chrome will create a lighter tint of frame-color",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "inactive-frame-gradient-color",
+          "Inactive Frame Gradient Color",
+          "The top color of the inactive chrome frame gradient. (If"
+            " unspecified, chrome will create a lighter tint of frame-color",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "incognito-frame-gradient-color",
+          "Incognito Frame Gradient Color",
+          "The top color of the incognito chrome frame gradient. (If"
+            " unspecified, chrome will create a lighter tint of frame-color",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "incognito-inactive-frame-gradient-color",
+          "Incognito Inactive Frame Gradient Color",
+          "The top color of the incognito inactive chrome frame gradient. (If"
+            " unspecified, chrome will create a lighter tint of frame-color",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+
+  // Scrollbar color properties:
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "scrollbar-slider-prelight-color",
+          "Scrollbar Slider Prelight Color",
+          "The color applied to the mouse is above the tab",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "scrollbar-slider-normal-color",
+          "Scrollbar Slider Normal Color",
+          "The color applied to the slider normally",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "scrollbar-trough-color",
+          "Scrollbar Trough Color",
+          "The background color of the slider track",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+}
+
+static void chrome_gtk_frame_init(ChromeGtkFrame* frame) {
+}
+
+GtkWidget* chrome_gtk_frame_new(void) {
+  return GTK_WIDGET(g_object_new(chrome_gtk_frame_get_type(), "type",
+                                 GTK_WINDOW_TOPLEVEL, nullptr));
+}
+
+G_END_DECLS
diff --git a/ui/gtk/chrome_gtk_frame.h b/ui/gtk/chrome_gtk_frame.h
new file mode 100644
index 0000000000000..2d783453ced07
--- /dev/null
+++ b/ui/gtk/chrome_gtk_frame.h
@@ -0,0 +1,54 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_UI_LIBGTKUI_CHROME_GTK_FRAME_H_
+#define CHROME_BROWSER_UI_LIBGTKUI_CHROME_GTK_FRAME_H_
+
+#include <gtk/gtk.h>
+
+G_BEGIN_DECLS
+
+// This file declares two subclasses of GtkWindow for easier gtk+ theme
+// integration.
+//
+// The first is "MetaFrames," which is (was?) the name of a gobject class in
+// the metacity window manager. To actually get at those values, we need to
+// have an object whose gobject class name string matches the definitions in
+// the gtkrc file. MetaFrames derives from GtkWindow.
+//
+// Metaframes can not be instantiated. It has no constructor; instantiate
+// ChromeGtkFrame instead.
+typedef struct _MetaFrames       MetaFrames;
+typedef struct _MetaFramesClass  MetaFramesClass;
+
+struct _MetaFrames {
+  GtkWindow window;
+};
+
+struct _MetaFramesClass {
+  GtkWindowClass parent_class;
+};
+
+
+// The second is ChromeGtkFrame, which defines a number of optional style
+// properties so theme authors can control how chromium appears in gtk-theme
+// mode.  It derives from MetaFrames in chrome so older themes that declare a
+// MetaFrames theme will still work. New themes should target this class.
+typedef struct _ChromeGtkFrame       ChromeGtkFrame;
+typedef struct _ChromeGtkFrameClass  ChromeGtkFrameClass;
+
+struct _ChromeGtkFrame {
+  MetaFrames frames;
+};
+
+struct _ChromeGtkFrameClass {
+  MetaFramesClass frames_class;
+};
+
+// Creates a GtkWindow object the the class name "ChromeGtkFrame".
+GtkWidget* chrome_gtk_frame_new();
+
+G_END_DECLS
+
+#endif  // CHROME_BROWSER_UI_LIBGTKUI_CHROME_GTK_FRAME_H_
diff --git a/ui/gtk/chrome_gtk_menu_subclasses.cc b/ui/gtk/chrome_gtk_menu_subclasses.cc
new file mode 100644
index 0000000000000..adb5d8a9ec408
--- /dev/null
+++ b/ui/gtk/chrome_gtk_menu_subclasses.cc
@@ -0,0 +1,29 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/gtk/chrome_gtk_menu_subclasses.h"
+
+G_DEFINE_TYPE(GtkCustomMenu, gtk_custom_menu, GTK_TYPE_MENU)
+
+static void gtk_custom_menu_init(GtkCustomMenu* menu) {
+}
+
+static void gtk_custom_menu_class_init(GtkCustomMenuClass* klass) {
+}
+
+GtkWidget* gtk_custom_menu_new() {
+  return GTK_WIDGET(g_object_new(gtk_custom_menu_get_type(), nullptr));
+}
+
+G_DEFINE_TYPE(GtkCustomMenuItem, gtk_custom_menu_item, GTK_TYPE_MENU_ITEM)
+
+static void gtk_custom_menu_item_init(GtkCustomMenuItem* item) {
+}
+
+static void gtk_custom_menu_item_class_init(GtkCustomMenuItemClass* klass) {
+}
+
+GtkWidget* gtk_custom_menu_item_new() {
+  return GTK_WIDGET(g_object_new(gtk_custom_menu_item_get_type(), nullptr));
+}
diff --git a/ui/gtk/chrome_gtk_menu_subclasses.h b/ui/gtk/chrome_gtk_menu_subclasses.h
new file mode 100644
index 0000000000000..fd999576543aa
--- /dev/null
+++ b/ui/gtk/chrome_gtk_menu_subclasses.h
@@ -0,0 +1,47 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_UI_LIBGTKUI_CHROME_GTK_MENU_SUBCLASSES_H_
+#define CHROME_BROWSER_UI_LIBGTKUI_CHROME_GTK_MENU_SUBCLASSES_H_
+
+#include <gtk/gtk.h>
+
+// This file declares two subclasses of Gtk's menu classes. We do this because
+// when we were a GTK app proper, we had classes with the same names, and gtk
+// theme authors started writing themes and styling chrome's menus by targeting
+// these classes. We have to fetch our colors from these theme classes in
+// specific because several newer GTK+2 themes are pixmap based and they
+// specifically give real colors only to these classes.
+
+G_BEGIN_DECLS
+
+typedef struct _GtkCustomMenu GtkCustomMenu;
+typedef struct _GtkCustomMenuClass GtkCustomMenuClass;
+
+struct _GtkCustomMenu {
+  GtkMenu menu;
+};
+
+struct _GtkCustomMenuClass {
+  GtkMenuClass parent_class;
+};
+
+GtkWidget* gtk_custom_menu_new();
+
+typedef struct _GtkCustomMenuItem GtkCustomMenuItem;
+typedef struct _GtkCustomMenuItemClass GtkCustomMenuItemClass;
+
+struct _GtkCustomMenuItem {
+  GtkMenuItem menu_item;
+};
+
+struct _GtkCustomMenuItemClass {
+  GtkMenuItemClass parent_class;
+};
+
+GtkWidget* gtk_custom_menu_item_new();
+
+G_END_DECLS
+
+#endif  // CHROME_BROWSER_UI_LIBGTKUI_CHROME_GTK_MENU_SUBCLASSES_H_
diff --git a/ui/gtk/gdk.sigs b/ui/gtk/gdk.sigs
index 7a393ed7080d3..c0298e2ca5c89 100644
--- a/ui/gtk/gdk.sigs
+++ b/ui/gtk/gdk.sigs
@@ -1,36 +1,3 @@
-GdkDisplay* gdk_display_get_default(void);
-gboolean gdk_keymap_translate_keyboard_state(GdkKeymap* keymap, guint hardware_keycode, GdkModifierType state, gint group, guint* keyval, gint* effective_group, gint* level, GdkModifierType* consumed_modifiers);
-void gdk_keymap_add_virtual_modifiers(GdkKeymap* keymap, GdkModifierType* state);
-GdkEvent* gdk_event_new(GdkEventType type);
-void gdk_event_free(GdkEvent* event);
-gboolean gdk_keymap_get_entries_for_keycode(GdkKeymap* keymap, guint hardware_keycode, GdkKeymapKey** keys, guint** keyvals, gint* n_entries);
-GdkKeymap* gdk_keymap_get_for_display(GdkDisplay* display);
-int gdk_texture_get_width(GdkTexture* texture);
-int gdk_texture_get_height(GdkTexture* texture);
-void gdk_texture_download(GdkTexture* texture, guchar* data, gsize stride);
-gboolean gdk_display_map_keycode(GdkDisplay* display, guint keycode, GdkKeymapKey** keys, guint** keyvals, int* n_entries);
-void gdk_paintable_snapshot(GdkPaintable* paintable, GdkSnapshot* snapshot, double width, double height);
-GType gdk_paintable_get_type(void);
-GdkSeat* gdk_display_get_default_seat(GdkDisplay* display);
-GdkDevice* gdk_seat_get_keyboard(GdkSeat* seat);
-GdkTexture* gdk_memory_texture_new(int width, int height, GdkMemoryFormat format, GBytes* bytes, gsize stride);
-int gdk_paintable_get_intrinsic_width(GdkPaintable* paintable);
-int gdk_paintable_get_intrinsic_height(GdkPaintable* paintable);
-GdkScreen* gdk_screen_get_default(void);
-void gdk_color_free(GdkColor* color);
-gboolean gdk_wayland_window_set_transient_for_exported(GdkWindow* window, char* parent_handle_str);
-gboolean gdk_wayland_toplevel_set_transient_for_exported(GdkToplevel* toplevel, const char* parent_handle_str);
-unsigned long gdk_x11_surface_get_xid(GdkSurface* surface);
-unsigned long gdk_x11_window_get_xid(GdkWindow* window);
-void gdk_event_handler_set(GdkEventFunc func, gpointer data, GDestroyNotify notify);
+unsigned long gdk_x11_drawable_get_xid(GdkDrawable* drawable);
 GdkWindow* gdk_x11_window_foreign_new_for_display(GdkDisplay* display, unsigned long window);
 GdkWindow* gdk_x11_window_lookup_for_display(GdkDisplay* display, unsigned long window);
-guint gdk_key_event_get_keycode(GdkEvent* event);
-guint gdk_key_event_get_keyval(GdkEvent* event);
-GdkSurface* gdk_event_get_surface(GdkEvent* event);
-GdkModifierType gdk_event_get_modifier_state(GdkEvent *event);
-GType gdk_toplevel_get_type(void);
-void gdk_set_allowed_backends(const gchar* backends);
-void gdk_display_notify_startup_complete(GdkDisplay* display, const char* startup_id);
-guint32 gdk_keyval_to_unicode(guint keyval);
-gdouble gdk_screen_get_resolution(GdkScreen *screen);
diff --git a/ui/gtk/gdk_pixbuf.sigs b/ui/gtk/gdk_pixbuf.sigs
deleted file mode 100644
index 35caa0fa257c0..0000000000000
--- a/ui/gtk/gdk_pixbuf.sigs
+++ /dev/null
@@ -1,3 +0,0 @@
-GdkPixbuf* gdk_pixbuf_new_from_file_at_size(const char* filename, int width, int height, GError** error);
-int gdk_pixbuf_get_width(const GdkPixbuf* pixbuf);
-int gdk_pixbuf_get_height(const GdkPixbuf* pixbuf);
diff --git a/ui/gtk/gio.sigs b/ui/gtk/gio.sigs
deleted file mode 100644
index 01f6bde43c9a9..0000000000000
--- a/ui/gtk/gio.sigs
+++ /dev/null
@@ -1,4 +0,0 @@
-const char* g_file_peek_path(GFile* file);
-gpointer g_list_model_get_item(GListModel* list, guint position);
-guint g_list_model_get_n_items(GListModel* list);
-GObject* g_list_model_get_object(GListModel* list, guint position);
diff --git a/ui/gtk/gsk.sigs b/ui/gtk/gsk.sigs
deleted file mode 100644
index 4f3a8650fb715..0000000000000
--- a/ui/gtk/gsk.sigs
+++ /dev/null
@@ -1,16 +0,0 @@
-GskRenderNodeType gsk_render_node_get_node_type(GskRenderNode* node);
-void gsk_render_node_unref(GskRenderNode* node);
-GskRenderNode* gsk_transform_node_get_child(GskRenderNode* node);
-GskRenderNode* gsk_opacity_node_get_child(GskRenderNode* node);
-GskRenderNode* gsk_color_matrix_node_get_child(GskRenderNode* node);
-GskRenderNode* gsk_repeat_node_get_child(GskRenderNode* node);
-GskRenderNode* gsk_clip_node_get_child(GskRenderNode* node);
-GskRenderNode* gsk_rounded_clip_node_get_child(GskRenderNode* node);
-GskRenderNode* gsk_shadow_node_get_child(GskRenderNode* node);
-GskRenderNode* gsk_blur_node_get_child(GskRenderNode* node);
-GskRenderNode* gsk_debug_node_get_child(GskRenderNode* node);
-GskRenderNode* gsk_container_node_get_child(GskRenderNode* node, guint idx);
-GskRenderNode* gsk_gl_shader_node_get_child(GskRenderNode* node, guint idx);
-guint gsk_container_node_get_n_children(GskRenderNode* node);
-guint gsk_gl_shader_node_get_n_children(GskRenderNode* node);
-GdkTexture* gsk_texture_node_get_texture(GskRenderNode* node);
diff --git a/ui/gtk/gtk.fragment b/ui/gtk/gtk.fragment
deleted file mode 100644
index 4a0b78caf2eb9..0000000000000
--- a/ui/gtk/gtk.fragment
+++ /dev/null
@@ -1 +0,0 @@
-#include "ui/gtk/gtk_compat.h"
diff --git a/ui/gtk/gtk.sigs b/ui/gtk/gtk.sigs
deleted file mode 100644
index 5bf454bbc6752..0000000000000
--- a/ui/gtk/gtk.sigs
+++ /dev/null
@@ -1,186 +0,0 @@
-GtkSettings* gtk_settings_get_default(void);
-void gtk_widget_path_iter_set_object_name(GtkWidgetPath* path, gint pos, const gchar* name);
-void gtk_widget_path_iter_add_class(GtkWidgetPath* path, gint pos, const gchar* name);
-GtkWidgetPath* gtk_widget_path_copy(const GtkWidgetPath* path);
-GtkWidgetPath* gtk_widget_path_new(void);
-const GtkWidgetPath* gtk_style_context_get_path(GtkStyleContext* context);
-gint gtk_widget_path_append_type(GtkWidgetPath* path, GType type);
-void gtk_widget_path_iter_set_name(GtkWidgetPath* path, gint pos, const gchar* name);
-void gtk_widget_path_iter_set_state(GtkWidgetPath* path, gint pos, GtkStateFlags state);
-GtkStyleContext* gtk_style_context_new(void);
-void gtk_style_context_set_path(GtkStyleContext* context, GtkWidgetPath* path);
-void gtk_style_context_set_parent(GtkStyleContext* context, GtkStyleContext* parent);
-void gtk_widget_path_unref(GtkWidgetPath* path);
-GtkStyleContext* gtk_style_context_get_parent(GtkStyleContext* context);
-void gtk_widget_set_css_classes(GtkWidget* widget, const char** classes);
-void gtk_widget_measure(GtkWidget* widget, GtkOrientation orientation, int for_size, int* minimum, int* natural, int* minimum_baseline, int* natural_baseline);
-GtkWidget* gtk_offscreen_window_new(void);
-void gtk_container_add(GtkContainer* container, GtkWidget* widget);
-void gtk_widget_destroy(GtkWidget* widget);
-gboolean gtk_bindings_activate_event(GObject* object, GdkEventKey* event);
-void gtk_widget_set_events(GtkWidget* widget, gint events);
-GType gtk_container_get_type(void);
-cairo_surface_t* gtk_icon_info_load_surface(GtkIconInfo* icon_info, GdkWindow* for_window, GError** error);
-void gtk_style_context_get_valist(GtkStyleContext* context, GtkStateFlags state, va_list args);
-void gtk_style_context_get_style_valist(GtkStyleContext* context, va_list args);
-GtkSnapshot* gtk_snapshot_new(void);
-GskRenderNode* gtk_snapshot_free_to_node(GtkSnapshot* snapshot);
-void gtk_im_context_set_client_widget(GtkIMContext* context, GtkWidget* widget);
-GtkNative* gtk_widget_get_native(GtkWidget* widget);
-GdkSurface* gtk_native_get_surface(GtkNative* native);
-gboolean gtk_im_context_filter_key(GtkIMContext* context, gboolean press, GdkSurface* surface, GdkDevice* device, guint32 time, guint keycode, GdkModifierType state, int group);
-void gtk_im_context_set_client_window(GtkIMContext* context, GdkWindow* window);
-gboolean gtk_file_chooser_set_filename(GtkFileChooser* chooser, const char* filename);
-GSList* gtk_file_chooser_list_filters(GtkFileChooser* chooser);
-gchar* gtk_file_chooser_get_filename(GtkFileChooser* chooser);
-GSList* gtk_file_chooser_get_filenames(GtkFileChooser* chooser);
-char* gtk_file_chooser_get_preview_filename(GtkFileChooser* chooser);
-void gtk_file_chooser_set_preview_widget_active(GtkFileChooser* chooser, gboolean active);
-void gtk_file_chooser_set_preview_widget(GtkFileChooser* chooser, GtkWidget* preview_widget);
-gboolean gtk_widget_hide_on_delete(GtkWidget* widget);
-void gtk_widget_show_all(GtkWidget* widget);
-void gtk_file_chooser_set_do_overwrite_confirmation(GtkFileChooser* chooser, gboolean do_overwrite_confirmation);
-GListModel* gtk_file_chooser_get_filters(GtkFileChooser* chooser);
-void gtk_window_set_hide_on_close(GtkWindow* window, gboolean setting);
-GtkIconInfo* gtk_icon_theme_lookup_icon_for_scale(GtkIconTheme* icon_theme, const gchar* icon_name, gint size, gint scale, GtkIconLookupFlags flags);
-GdkPixbuf* gtk_icon_info_load_symbolic_for_context(GtkIconInfo* icon_info, GtkStyleContext* context, gboolean* was_symbolic, GError** error);
-void gtk_snapshot_render_background(GtkSnapshot* snapshot, GtkStyleContext* context, double x, double y, double width, double height);
-GType gtk_menu_get_type(void);
-GType gtk_menu_bar_get_type(void);
-GType gtk_menu_item_get_type(void);
-void gtk_style_context_add_provider_for_screen(GdkScreen* screen, GtkStyleProvider* provider, guint priority);
-void gtk_style_context_add_provider_for_display(GdkDisplay* display, GtkStyleProvider* provider, guint priority);
-void gtk_style_context_remove_provider_for_screen(GdkScreen* screen, GtkStyleProvider* provider);
-void gtk_style_context_remove_provider_for_display(GdkDisplay* display, GtkStyleProvider* provider);
-void gtk_window_destroy(GtkWindow* window);
-GtkIconTheme* gtk_icon_theme_get_for_display(GdkDisplay* display);
-GtkIconTheme* gtk_icon_theme_get_default(void);
-gboolean gtk_widget_path_iter_has_class(const GtkWidgetPath* path, gint pos, const gchar* name);
-GdkWindow* gtk_widget_get_window(GtkWidget* widget);
-void gtk_main_do_event(GdkEvent *event);
-guint gtk_get_major_version(void);
-guint gtk_get_minor_version(void);
-guint gtk_get_micro_version(void);
-void gtk_window_present(GtkWindow* window);
-void gtk_window_present_with_time(GtkWindow* window, guint32 timestamp);
-GType gtk_box_get_type(void);
-GType gtk_button_get_type(void);
-GType gtk_cell_view_get_type(void);
-GType gtk_combo_box_text_get_type(void);
-GType gtk_entry_get_type(void);
-GType gtk_file_chooser_get_type(void);
-GType gtk_frame_get_type(void);
-GType gtk_header_bar_get_type(void);
-GType gtk_image_get_type(void);
-GType gtk_info_bar_get_type(void);
-GType gtk_label_get_type(void);
-GType gtk_print_unix_dialog_get_type(void);
-GType gtk_range_get_type(void);
-GType gtk_scale_get_type(void);
-GType gtk_scrollbar_get_type(void);
-GType gtk_scrolled_window_get_type(void);
-GType gtk_separator_get_type(void);
-GType gtk_spinner_get_type(void);
-GType gtk_style_provider_get_type(void);
-GType gtk_text_view_get_type(void);
-GType gtk_toggle_button_get_type(void);
-GType gtk_tree_model_get_type(void);
-GType gtk_tree_view_get_type(void);
-GType gtk_widget_get_type(void);
-GType gtk_window_get_type(void);
-GtkWidget* gtk_combo_box_new_with_model(GtkTreeModel* model);
-GtkCssProvider* gtk_css_provider_new(void);
-void gtk_disable_setlocale(void);
-void gtk_enumerate_printers(GtkPrinterFunc func, gpointer data, GDestroyNotify destroy, gboolean wait);
-void gtk_file_chooser_add_filter(GtkFileChooser* chooser, GtkFileFilter* filter);
-GFile* gtk_file_chooser_get_file(GtkFileChooser* chooser);
-GtkFileFilter* gtk_file_chooser_get_filter(GtkFileChooser* chooser);
-void gtk_file_chooser_set_create_folders(GtkFileChooser* chooser, gboolean create_folders);
-void gtk_file_chooser_set_current_name(GtkFileChooser* chooser, const gchar* name);
-gboolean gtk_file_chooser_set_file(GtkFileChooser* chooser, GFile* file, GError** error);
-void gtk_file_chooser_set_filter(GtkFileChooser* chooser, GtkFileFilter* filter);
-void gtk_file_chooser_set_select_multiple(GtkFileChooser* chooser, gboolean select_multiple);
-void gtk_file_filter_add_mime_type(GtkFileFilter* filter, const gchar* mime_type);
-void gtk_file_filter_add_pattern(GtkFileFilter* filter, const gchar* pattern);
-GtkFileFilter* gtk_file_filter_new(void);
-void gtk_file_filter_set_name(GtkFileFilter* filter, const gchar* name);
-GtkWidget* gtk_image_new(void);
-void gtk_image_set_from_pixbuf(GtkImage* image, GdkPixbuf* pixbuf);
-void gtk_im_context_focus_in(GtkIMContext* context);
-void gtk_im_context_focus_out(GtkIMContext* context);
-void gtk_im_context_get_preedit_string(GtkIMContext* context, gchar** str, PangoAttrList** attrs, gint* cursor_pos);
-void gtk_im_context_reset(GtkIMContext* context);
-void gtk_im_context_set_cursor_location(GtkIMContext* context, const GdkRectangle* area);
-GtkIMContext* gtk_im_context_simple_new(void);
-GtkIMContext* gtk_im_multicontext_new(void);
-GtkWidget* gtk_label_new(const gchar* str);
-gdouble gtk_page_setup_get_left_margin(GtkPageSetup* setup, GtkUnit unit);
-gdouble gtk_page_setup_get_page_height(GtkPageSetup* setup, GtkUnit unit);
-gdouble gtk_page_setup_get_page_width(GtkPageSetup* setup, GtkUnit unit);
-gdouble gtk_page_setup_get_paper_height(GtkPageSetup* setup, GtkUnit unit);
-GtkPaperSize* gtk_page_setup_get_paper_size(GtkPageSetup* setup);
-gdouble gtk_page_setup_get_paper_width(GtkPageSetup* setup, GtkUnit unit);
-gdouble gtk_page_setup_get_top_margin(GtkPageSetup* setup, GtkUnit unit);
-GtkPageSetup* gtk_page_setup_new(void);
-void gtk_page_setup_set_paper_size(GtkPageSetup* setup, GtkPaperSize* size);
-void gtk_paper_size_free(GtkPaperSize* size);
-gdouble gtk_paper_size_get_height(GtkPaperSize* size, GtkUnit unit);
-GList* gtk_paper_size_get_paper_sizes(gboolean include_custom);
-const gchar* gtk_paper_size_get_ppd_name(GtkPaperSize* size);
-gdouble gtk_paper_size_get_width(GtkPaperSize* size, GtkUnit unit);
-GtkPaperSize* gtk_paper_size_new_custom(const gchar* name, const gchar* display_name, gdouble width, gdouble height, GtkUnit unit);
-GtkPageSetup* gtk_printer_get_default_page_size(GtkPrinter* printer);
-const gchar* gtk_printer_get_name(GtkPrinter* printer);
-gboolean gtk_printer_is_default(GtkPrinter* printer);
-GtkPrintJob* gtk_print_job_new(const gchar* title, GtkPrinter* printer, GtkPrintSettings* settings, GtkPageSetup* page_setup);
-void gtk_print_job_send(GtkPrintJob* job, GtkPrintJobCompleteFunc callback, gpointer user_data, GDestroyNotify dnotify);
-gboolean gtk_print_job_set_source_file(GtkPrintJob* job, const gchar* filename, GError** error);
-GtkPrintSettings* gtk_print_settings_copy(GtkPrintSettings* other);
-GtkPageOrientation gtk_print_settings_get_orientation(GtkPrintSettings* settings);
-GtkPageRange* gtk_print_settings_get_page_ranges(GtkPrintSettings* settings, gint *num_ranges);
-const gchar* gtk_print_settings_get_printer(GtkPrintSettings* settings);
-GtkPrintPages gtk_print_settings_get_print_pages(GtkPrintSettings* settings);
-gint gtk_print_settings_get_resolution(GtkPrintSettings* settings);
-GtkPrintSettings* gtk_print_settings_new(void);
-void gtk_print_settings_set(GtkPrintSettings* settings, const gchar* key, const gchar* value);
-void gtk_print_settings_set_collate(GtkPrintSettings* settings, gboolean collate);
-void gtk_print_settings_set_n_copies(GtkPrintSettings* settings, gint num_copies);
-void gtk_print_settings_set_orientation(GtkPrintSettings* settings, GtkPageOrientation orientation);
-void gtk_print_settings_set_printer_lpi(GtkPrintSettings* settings, gdouble lpi);
-void gtk_print_settings_set_print_pages(GtkPrintSettings* settings, GtkPrintPages pages);
-void gtk_print_settings_set_resolution_xy(GtkPrintSettings* settings, gint resolution_x, gint resolution_y);
-GtkPageSetup* gtk_print_unix_dialog_get_page_setup(GtkPrintUnixDialog* dialog);
-GtkPrinter* gtk_print_unix_dialog_get_selected_printer(GtkPrintUnixDialog* dialog);
-GtkPrintSettings* gtk_print_unix_dialog_get_settings(GtkPrintUnixDialog* dialog);
-GtkWidget* gtk_print_unix_dialog_new(const char* title, GtkWindow* parent);
-void gtk_print_unix_dialog_set_embed_page_setup(GtkPrintUnixDialog* dialog, gboolean embed);
-void gtk_print_unix_dialog_set_has_selection(GtkPrintUnixDialog* dialog, gboolean has_selection);
-void gtk_print_unix_dialog_set_manual_capabilities(GtkPrintUnixDialog* dialog, GtkPrintCapabilities capabilities);
-void gtk_print_unix_dialog_set_settings(GtkPrintUnixDialog* dialog, GtkPrintSettings* settings);
-void gtk_print_unix_dialog_set_support_selection(GtkPrintUnixDialog* dialog, gboolean support_selection);
-void gtk_render_background(GtkStyleContext* context, cairo_t* cr, gdouble x, gdouble y, gdouble width, gdouble height);
-void gtk_render_focus(GtkStyleContext* context, cairo_t* cr, gdouble x, gdouble y, gdouble width, gdouble height);
-void gtk_render_frame(GtkStyleContext* context, cairo_t* cr, gdouble x, gdouble y, gdouble width, gdouble height);
-GtkWidget* gtk_separator_new(GtkOrientation orientation);
-void gtk_style_context_add_class(GtkStyleContext* context, const gchar* class_name);
-void gtk_style_context_add_provider(GtkStyleContext* context, GtkStyleProvider* provider, guint priority);
-GtkStateFlags gtk_style_context_get_state(GtkStyleContext* context);
-gboolean gtk_style_context_has_class(GtkStyleContext* context, const gchar* class_name);
-void gtk_style_context_set_scale(GtkStyleContext* context, gint scale);
-void gtk_style_context_set_state(GtkStyleContext* context, GtkStateFlags flags);
-PangoContext* gtk_widget_get_pango_context(GtkWidget* widget);
-GtkWidget* gtk_widget_get_parent(GtkWidget* widget);
-void gtk_widget_get_preferred_size(GtkWidget* widget, GtkRequisition* minimum_size, GtkRequisition* natural_size);
-gint gtk_widget_get_scale_factor(GtkWidget* widget);
-GtkStyleContext* gtk_widget_get_style_context(GtkWidget* widget);
-void gtk_widget_hide(GtkWidget* widget);
-void gtk_widget_realize(GtkWidget* widget);
-void gtk_widget_set_can_focus(GtkWidget* widget, gboolean can_focus);
-void gtk_widget_set_name(GtkWidget* widget, const gchar* name);
-void gtk_widget_set_parent(GtkWidget* widget, GtkWidget* parent);
-void gtk_widget_set_sensitive(GtkWidget* widget, gboolean sensitive);
-void gtk_widget_set_size_request(GtkWidget* widget, gint width, gint height);
-void gtk_widget_set_state_flags(GtkWidget* widget, GtkStateFlags flags, gboolean clear);
-void gtk_widget_show(GtkWidget* widget);
-void gtk_window_set_modal(GtkWindow* window, gboolean modal);
-void gtk_print_settings_set_printer(GtkPrintSettings* settings, const gchar* printer);
diff --git a/ui/gtk/gtk_color_mixers.cc b/ui/gtk/gtk_color_mixers.cc
index e04e2cb8e2a4d..f20ab200a4eaf 100644
--- a/ui/gtk/gtk_color_mixers.cc
+++ b/ui/gtk/gtk_color_mixers.cc
@@ -11,6 +11,7 @@
 #include "ui/color/color_set.h"
 #include "ui/color/color_transform.h"
 #include "ui/gtk/gtk_util.h"
+#include "ui/gtk/native_theme_gtk.h"
 
 namespace gtk {
 
@@ -27,7 +28,9 @@ void AddGtkNativeCoreColorMixer(
   ui::ColorSet::ColorMap color_map;
   for (ui::ColorId id = ui::kUiColorsStart; id < ui::kUiColorsEnd; ++id) {
     // Add GTK color definitions to the map if they exist.
-    absl::optional<SkColor> color = gtk::SkColorFromColorId(id);
+    absl::optional<SkColor> color = gtk::NativeThemeGtk::instance()->SkColorFromColorId(
+      id, color_mode == ui::ColorProviderManager::ColorMode::kLight ?
+      NativeThemeGtk::ColorScheme::kLight : NativeThemeGtk::ColorScheme::kDark);
     if (color)
       color_map[id] = *color;
   }
diff --git a/ui/gtk/gtk_compat.cc b/ui/gtk/gtk_compat.cc
index f78893e41b7b5..4a20ed006aa3a 100644
--- a/ui/gtk/gtk_compat.cc
+++ b/ui/gtk/gtk_compat.cc
@@ -13,135 +13,20 @@
 #include "base/no_destructor.h"
 #include "base/strings/string_number_conversions.h"
 #include "ui/gfx/color_palette.h"
-#include "ui/gtk/gtk_stubs.h"
 
 namespace gtk {
 
 // IMPORTANT: All functions in this file that call dlsym()'ed
 // functions should be annotated with DISABLE_CFI_ICALL.
 
-namespace {
-
-const char kGtkVersionFlag[] = "gtk-version";
-
-struct Gdk3Rgba {
-  gdouble r;
-  gdouble g;
-  gdouble b;
-  gdouble a;
-};
-
-struct Gdk4Rgba {
-  float r;
-  float g;
-  float b;
-  float a;
-};
-
-template <typename T>
-SkColor GdkRgbaToSkColor(const T& color) {
-  return SkColorSetARGB(color.a * 255, color.r * 255, color.g * 255,
-                        color.b * 255);
-}
-
-void* DlOpen(const char* library_name, bool check = true) {
-  void* library = dlopen(library_name, RTLD_LAZY | RTLD_GLOBAL);
-  CHECK(!check || library);
-  return library;
-}
-
-void* DlSym(void* library, const char* name) {
-  void* symbol = dlsym(library, name);
-  CHECK(symbol);
-  return symbol;
-}
-
-template <typename T>
-auto DlCast(void* symbol) {
-  return reinterpret_cast<T*>(symbol);
-}
-
-void* GetLibGio() {
-  static void* libgio = DlOpen("libgio-2.0.so.0");
-  return libgio;
-}
-
-void* GetLibGdkPixbuf() {
-  static void* libgdk_pixbuf = DlOpen("libgdk_pixbuf-2.0.so.0");
-  return libgdk_pixbuf;
-}
-
-void* GetLibGdk3() {
-  static void* libgdk3 = DlOpen("libgdk-3.so.0");
-  return libgdk3;
-}
-
-void* GetLibGtk3(bool check = true) {
-  static void* libgtk3 = DlOpen("libgtk-3.so.0", check);
-  return libgtk3;
-}
-
-void* GetLibGtk4(bool check = true) {
-  static void* libgtk4 = DlOpen("libgtk-4.so.1", check);
-  return libgtk4;
-}
-
-void* GetLibGtk() {
-  if (GtkCheckVersion(4))
-    return GetLibGtk4();
-  return GetLibGtk3();
-}
-
-bool LoadGtk3() {
-  if (!GetLibGtk3(false))
-    return false;
-  ui_gtk::InitializeGdk_pixbuf(GetLibGdkPixbuf());
-  ui_gtk::InitializeGdk(GetLibGdk3());
-  ui_gtk::InitializeGtk(GetLibGtk3());
-  return true;
-}
-
-bool LoadGtk4() {
-  if (!GetLibGtk4(false))
-    return false;
-  // In GTK4 mode, we require some newer gio symbols that aren't available
-  // in Ubuntu Xenial or Debian Stretch.  Fortunately, GTK4 itself depends
-  // on a newer version of glib (which provides gio), so if we're using
-  // GTK4, we can safely assume the system has the required gio symbols.
-  ui_gtk::InitializeGio(GetLibGio());
-  // In GTK4, libgtk provides all gdk_*, gsk_*, and gtk_* symbols.
-  ui_gtk::InitializeGdk(GetLibGtk4());
-  ui_gtk::InitializeGsk(GetLibGtk4());
-  ui_gtk::InitializeGtk(GetLibGtk4());
-  return true;
-}
-
-bool LoadGtkImpl() {
-  auto* cmd = base::CommandLine::ForCurrentProcess();
-  unsigned int gtk_version;
-  if (!base::StringToUint(cmd->GetSwitchValueASCII(kGtkVersionFlag),
-                          &gtk_version)) {
-    gtk_version = 0;
-  }
-  // Prefer GTK3 for now as the GTK4 ecosystem is still immature.
-  return gtk_version == 4 ? LoadGtk4() || LoadGtk3() : LoadGtk3() || LoadGtk4();
-}
-
-gfx::Insets InsetsFromGtkBorder(const GtkBorder& border) {
-  return gfx::Insets(border.top, border.left, border.bottom, border.right);
-}
-
-}  // namespace
-
 bool LoadGtk() {
-  static bool loaded = LoadGtkImpl();
-  return loaded;
+  return true;
 }
 
 const base::Version& GtkVersion() {
   static base::NoDestructor<base::Version> gtk_version(
-      std::vector<uint32_t>{gtk_get_major_version(), gtk_get_minor_version(),
-                            gtk_get_micro_version()});
+      std::vector<uint32_t>{gtk_major_version, gtk_minor_version,
+                            gtk_micro_version});
   return *gtk_version;
 }
 
@@ -151,239 +36,41 @@ bool GtkCheckVersion(uint32_t major, uint32_t minor, uint32_t micro) {
 
 DISABLE_CFI_ICALL
 void GtkInit(const std::vector<std::string>& args) {
-  static void* gtk_init = DlSym(GetLibGtk(), "gtk_init");
-  if (GtkCheckVersion(4)) {
-    DlCast<void()>(gtk_init)();
-  } else {
-    // gtk_init() modifies argv, so make a copy first.
-    size_t args_chars = 0;
-    for (const auto& arg : args)
-      args_chars += arg.size() + 1;
-    std::vector<char> args_copy(args_chars);
-    std::vector<char*> argv;
-    char* dst = args_copy.data();
-    for (const auto& arg : args) {
-      argv.push_back(strcpy(dst, arg.c_str()));
-      dst += arg.size() + 1;
-    }
-
-    int gtk_argc = argv.size();
-    char** gtk_argv = argv.data();
-    {
-      // http://crbug.com/423873
-      ANNOTATE_SCOPED_MEMORY_LEAK;
-      DlCast<void(int*, char***)>(gtk_init)(&gtk_argc, &gtk_argv);
-    }
-  }
-}
-
-DISABLE_CFI_ICALL
-gfx::Insets GtkStyleContextGetPadding(GtkStyleContext* context) {
-  static void* get_padding =
-      DlSym(GetLibGtk(), "gtk_style_context_get_padding");
-  GtkBorder padding;
-  if (GtkCheckVersion(4)) {
-    DlCast<void(GtkStyleContext*, GtkBorder*)>(get_padding)(context, &padding);
-  } else {
-    DlCast<void(GtkStyleContext*, GtkStateFlags, GtkBorder*)>(get_padding)(
-        context, gtk_style_context_get_state(context), &padding);
-  }
-  return InsetsFromGtkBorder(padding);
-}
-
-DISABLE_CFI_ICALL
-gfx::Insets GtkStyleContextGetBorder(GtkStyleContext* context) {
-  static void* get_border = DlSym(GetLibGtk(), "gtk_style_context_get_border");
-  GtkBorder border;
-  if (GtkCheckVersion(4)) {
-    DlCast<void(GtkStyleContext*, GtkBorder*)>(get_border)(context, &border);
-  } else {
-    DlCast<void(GtkStyleContext*, GtkStateFlags, GtkBorder*)>(get_border)(
-        context, gtk_style_context_get_state(context), &border);
+  // gtk_init() modifies argv, so make a copy first.
+  size_t args_chars = 0;
+  for (const auto& arg : args)
+    args_chars += arg.size() + 1;
+  std::vector<char> args_copy(args_chars);
+  std::vector<char*> argv;
+  char* dst = args_copy.data();
+  for (const auto& arg : args) {
+    argv.push_back(strcpy(dst, arg.c_str()));
+    dst += arg.size() + 1;
   }
-  return InsetsFromGtkBorder(border);
-}
-
-DISABLE_CFI_ICALL
-gfx::Insets GtkStyleContextGetMargin(GtkStyleContext* context) {
-  static void* get_margin = DlSym(GetLibGtk(), "gtk_style_context_get_margin");
-  GtkBorder margin;
-  if (GtkCheckVersion(4)) {
-    DlCast<void(GtkStyleContext*, GtkBorder*)>(get_margin)(context, &margin);
-  } else {
-    DlCast<void(GtkStyleContext*, GtkStateFlags, GtkBorder*)>(get_margin)(
-        context, gtk_style_context_get_state(context), &margin);
-  }
-  return InsetsFromGtkBorder(margin);
-}
-
-DISABLE_CFI_ICALL
-SkColor GtkStyleContextGetColor(GtkStyleContext* context) {
-  static void* get_color = DlSym(GetLibGtk(), "gtk_style_context_get_color");
-  if (GtkCheckVersion(4)) {
-    Gdk4Rgba color;
-    DlCast<void(GtkStyleContext*, Gdk4Rgba*)>(get_color)(context, &color);
-    return GdkRgbaToSkColor(color);
-  }
-  Gdk3Rgba color;
-  DlCast<void(GtkStyleContext*, GtkStateFlags, Gdk3Rgba*)>(get_color)(
-      context, gtk_style_context_get_state(context), &color);
-  return GdkRgbaToSkColor(color);
-}
-
-DISABLE_CFI_ICALL
-SkColor GtkStyleContextGetBackgroundColor(GtkStyleContext* context) {
-  DCHECK(!GtkCheckVersion(4));
-  static void* get_bg_color =
-      DlSym(GetLibGtk(), "gtk_style_context_get_background_color");
-  Gdk3Rgba color;
-  DlCast<void(GtkStyleContext*, GtkStateFlags, Gdk3Rgba*)>(get_bg_color)(
-      context, gtk_style_context_get_state(context), &color);
-  return GdkRgbaToSkColor(color);
-}
 
-DISABLE_CFI_ICALL
-absl::optional<SkColor> GtkStyleContextLookupColor(GtkStyleContext* context,
-                                                   const gchar* color_name) {
-  DCHECK(!GtkCheckVersion(4));
-  static void* lookup_color =
-      DlSym(GetLibGtk(), "gtk_style_context_lookup_color");
-  Gdk3Rgba color;
-  if (DlCast<gboolean(GtkStyleContext*, const gchar*, Gdk3Rgba*)>(lookup_color)(
-          context, color_name, &color)) {
-    return GdkRgbaToSkColor(color);
+  int gtk_argc = argv.size();
+  char** gtk_argv = argv.data();
+  {
+    // http://crbug.com/423873
+    ANNOTATE_SCOPED_MEMORY_LEAK;
+    gtk_init(&gtk_argc, &gtk_argv);
   }
-  return absl::nullopt;
 }
 
 DISABLE_CFI_ICALL
 bool GtkImContextFilterKeypress(GtkIMContext* context, GdkEventKey* event) {
-  static void* filter = DlSym(GetLibGtk(), "gtk_im_context_filter_keypress");
-  if (GtkCheckVersion(4)) {
-    return DlCast<bool(GtkIMContext*, GdkEvent*)>(filter)(
-        context, reinterpret_cast<GdkEvent*>(event));
-  }
-  return DlCast<bool(GtkIMContext*, GdkEventKey*)>(filter)(context, event);
+  return gtk_im_context_filter_keypress(context, event);
 }
 
 DISABLE_CFI_ICALL
 bool GtkFileChooserSetCurrentFolder(GtkFileChooser* dialog,
                                     const base::FilePath& path) {
-  static void* set = DlSym(GetLibGtk(), "gtk_file_chooser_set_current_folder");
-  if (GtkCheckVersion(4)) {
-    auto file = TakeGObject(g_file_new_for_path(path.value().c_str()));
-    return DlCast<bool(GtkFileChooser*, GFile*, GError**)>(set)(dialog, file,
-                                                                nullptr);
-  }
-  return DlCast<bool(GtkFileChooser*, const gchar*)>(set)(dialog,
-                                                          path.value().c_str());
-}
-
-DISABLE_CFI_ICALL
-void GtkRenderIcon(GtkStyleContext* context,
-                   cairo_t* cr,
-                   GdkPixbuf* pixbuf,
-                   GdkTexture* texture,
-                   double x,
-                   double y) {
-  static void* render = DlSym(GetLibGtk(), "gtk_render_icon");
-  if (GtkCheckVersion(4)) {
-    DCHECK(texture);
-    DlCast<void(GtkStyleContext*, cairo_t*, GdkTexture*, double, double)>(
-        render)(context, cr, texture, x, y);
-  } else {
-    DCHECK(pixbuf);
-    DlCast<void(GtkStyleContext*, cairo_t*, GdkPixbuf*, double, double)>(
-        render)(context, cr, pixbuf, x, y);
-  }
+  return gtk_file_chooser_set_current_folder(dialog, path.value().c_str());
 }
 
 DISABLE_CFI_ICALL
 GtkWidget* GtkToplevelWindowNew() {
-  static void* window_new = DlSym(GetLibGtk(), "gtk_window_new");
-  if (GtkCheckVersion(4))
-    return DlCast<GtkWidget*()>(window_new)();
-  return DlCast<GtkWidget*(GtkWindowType)>(window_new)(GTK_WINDOW_TOPLEVEL);
-}
-
-DISABLE_CFI_ICALL
-void GtkCssProviderLoadFromData(GtkCssProvider* css_provider,
-                                const char* data,
-                                gssize length) {
-  static void* load = DlSym(GetLibGtk(), "gtk_css_provider_load_from_data");
-  if (GtkCheckVersion(4)) {
-    DlCast<void(GtkCssProvider*, const char*, gssize)>(load)(css_provider, data,
-                                                             length);
-  } else {
-    DlCast<gboolean(GtkCssProvider*, const char*, gssize, GError**)>(load)(
-        css_provider, data, length, nullptr);
-  }
-}
-
-ScopedGObject<GListModel> Gtk4FileChooserGetFiles(GtkFileChooser* dialog) {
-  DCHECK(GtkCheckVersion(4));
-  static void* get = DlSym(GetLibGtk(), "gtk_file_chooser_get_files");
-  return TakeGObject(DlCast<GListModel*(GtkFileChooser*)>(get)(dialog));
-}
-
-void GtkStyleContextGet(GtkStyleContext* context, ...) {
-  va_list args;
-  va_start(args, context);
-  gtk_style_context_get_valist(context, gtk_style_context_get_state(context),
-                               args);
-  va_end(args);
-}
-
-void GtkStyleContextGetStyle(GtkStyleContext* context, ...) {
-  va_list args;
-  va_start(args, context);
-  gtk_style_context_get_style_valist(context, args);
-  va_end(args);
-}
-
-DISABLE_CFI_ICALL
-ScopedGObject<GtkIconInfo> Gtk3IconThemeLookupByGicon(
-    GtkIconTheme* theme,
-    GIcon* icon,
-    int size,
-    GtkIconLookupFlags flags) {
-  DCHECK(!GtkCheckVersion(4));
-  static void* lookup = DlSym(GetLibGtk(), "gtk_icon_theme_lookup_by_gicon");
-  return TakeGObject(
-      DlCast<GtkIconInfo*(GtkIconTheme*, GIcon*, int, GtkIconLookupFlags)>(
-          lookup)(theme, icon, size, flags));
-}
-
-DISABLE_CFI_ICALL
-ScopedGObject<GtkIconPaintable> Gtk4IconThemeLookupIcon(
-    GtkIconTheme* theme,
-    const char* icon_name,
-    const char* fallbacks[],
-    int size,
-    int scale,
-    GtkTextDirection direction,
-    GtkIconLookupFlags flags) {
-  static void* lookup = DlSym(GetLibGtk(), "gtk_icon_theme_lookup_icon");
-  return TakeGObject(
-      DlCast<GtkIconPaintable*(GtkIconTheme*, const char*, const char*[], int,
-                               int, GtkTextDirection, GtkIconLookupFlags)>(
-          lookup)(theme, icon_name, fallbacks, size, scale, direction, flags));
-}
-
-DISABLE_CFI_ICALL
-ScopedGObject<GtkIconPaintable> Gtk4IconThemeLookupByGicon(
-    GtkIconTheme* theme,
-    GIcon* icon,
-    int size,
-    int scale,
-    GtkTextDirection direction,
-    GtkIconLookupFlags flags) {
-  static void* lookup = DlSym(GetLibGtk(), "gtk_icon_theme_lookup_by_gicon");
-  DCHECK(GtkCheckVersion(4));
-  return TakeGObject(
-      DlCast<GtkIconPaintable*(GtkIconTheme*, GIcon*, int, int,
-                               GtkTextDirection, GtkIconLookupFlags)>(lookup)(
-          theme, icon, size, scale, direction, flags));
+  return gtk_window_new(GTK_WINDOW_TOPLEVEL);
 }
 
 DISABLE_CFI_ICALL
@@ -394,37 +81,17 @@ GtkWidget* GtkFileChooserDialogNew(const gchar* title,
                                    GtkResponseType first_response,
                                    const gchar* second_button_text,
                                    GtkResponseType second_response) {
-  static void* create = DlSym(GetLibGtk(), "gtk_file_chooser_dialog_new");
-  return DlCast<GtkWidget*(const gchar*, GtkWindow*, GtkFileChooserAction,
-                           const gchar*, ...)>(create)(
+  return gtk_file_chooser_dialog_new(
       title, parent, action, first_button_text, first_response,
       second_button_text, second_response, nullptr);
 }
 
-DISABLE_CFI_ICALL
-GtkTreeStore* GtkTreeStoreNew(GType type) {
-  static void* create = DlSym(GetLibGtk(), "gtk_tree_store_new");
-  return DlCast<GtkTreeStore*(gint, ...)>(create)(1, type);
-}
-
-DISABLE_CFI_ICALL
-GdkEventType GdkEventGetEventType(GdkEvent* event) {
-  static void* get = DlSym(GetLibGtk(), "gdk_event_get_event_type");
-  return DlCast<GdkEventType(GdkEvent*)>(get)(event);
-}
-
-DISABLE_CFI_ICALL
-guint32 GdkEventGetTime(GdkEvent* event) {
-  static void* get = DlSym(GetLibGtk(), "gdk_event_get_time");
-  return DlCast<guint32(GdkEvent*)>(get)(event);
-}
-
 GdkEventType GdkKeyPress() {
-  return static_cast<GdkEventType>(GtkCheckVersion(4) ? 4 : 8);
+  return GDK_KEY_PRESS;
 }
 
 GdkEventType GdkKeyRelease() {
-  return static_cast<GdkEventType>(GtkCheckVersion(4) ? 5 : 9);
+  return GDK_KEY_RELEASE;
 }
 
 }  // namespace gtk
diff --git a/ui/gtk/gtk_compat.h b/ui/gtk/gtk_compat.h
index 1dc8fdba63546..51bd57cd129b4 100644
--- a/ui/gtk/gtk_compat.h
+++ b/ui/gtk/gtk_compat.h
@@ -23,16 +23,8 @@
 
 extern "C" {
 #include "ui/gtk/gdk.sigs"
-#include "ui/gtk/gdk_pixbuf.sigs"
-#include "ui/gtk/gio.sigs"
-#include "ui/gtk/gsk.sigs"
-#include "ui/gtk/gtk.sigs"
 }
 
-#define GDK_KEY_PRESS Do_not_use_GDK_KEY_PRESS_because_it_is_not_ABI_compatible
-#define GDK_KEY_RELEASE \
-  Do_not_use_GDK_KEY_RELEASE_because_it_is_not_ABI_compatible
-
 using SkColor = uint32_t;
 
 namespace gtk {
@@ -52,70 +44,13 @@ bool GtkCheckVersion(uint32_t major, uint32_t minor = 0, uint32_t micro = 0);
 
 void GtkInit(const std::vector<std::string>& args);
 
-gfx::Insets GtkStyleContextGetPadding(GtkStyleContext* context);
-
-gfx::Insets GtkStyleContextGetBorder(GtkStyleContext* context);
-
-gfx::Insets GtkStyleContextGetMargin(GtkStyleContext* context);
-
-SkColor GtkStyleContextGetColor(GtkStyleContext* context);
-
-// Only available in Gtk3.
-SkColor GtkStyleContextGetBackgroundColor(GtkStyleContext* context);
-
-// Only available in Gtk3.
-absl::optional<SkColor> GtkStyleContextLookupColor(GtkStyleContext* context,
-                                                   const gchar* color_name);
-
 bool GtkImContextFilterKeypress(GtkIMContext* context, GdkEventKey* event);
 
 bool GtkFileChooserSetCurrentFolder(GtkFileChooser* dialog,
                                     const base::FilePath& path);
 
-void GtkRenderIcon(GtkStyleContext* context,
-                   cairo_t* cr,
-                   GdkPixbuf* pixbuf,
-                   GdkTexture* texture,
-                   double x,
-                   double y);
-
 GtkWidget* GtkToplevelWindowNew();
 
-void GtkCssProviderLoadFromData(GtkCssProvider* css_provider,
-                                const char* data,
-                                gssize length);
-
-ScopedGObject<GListModel> Gtk4FileChooserGetFiles(GtkFileChooser* dialog);
-
-ScopedGObject<GtkIconInfo> Gtk3IconThemeLookupByGicon(GtkIconTheme* theme,
-                                                      GIcon* icon,
-                                                      int size,
-                                                      GtkIconLookupFlags flags);
-
-ScopedGObject<GtkIconPaintable> Gtk4IconThemeLookupByGicon(
-    GtkIconTheme* theme,
-    GIcon* icon,
-    int size,
-    int scale,
-    GtkTextDirection direction,
-    GtkIconLookupFlags flags);
-
-ScopedGObject<GtkIconPaintable> Gtk4IconThemeLookupIcon(
-    GtkIconTheme* theme,
-    const char* icon_name,
-    const char* fallbacks[],
-    int size,
-    int scale,
-    GtkTextDirection direction,
-    GtkIconLookupFlags flags);
-
-// generate_stubs cannot forward to C-style variadic functions, so the
-// functions below wrap the corresponding GTK va_list functions.
-
-void GtkStyleContextGet(GtkStyleContext* context, ...);
-
-void GtkStyleContextGetStyle(GtkStyleContext* context, ...);
-
 // These variadic functions do not have corresponding va_list equivalents,
 // so instances with only a fixed set of arguments are provided.
 
@@ -127,15 +62,6 @@ GtkWidget* GtkFileChooserDialogNew(const gchar* title,
                                    const gchar* second_button_text,
                                    GtkResponseType second_response);
 
-GtkTreeStore* GtkTreeStoreNew(GType type);
-
-// These functions have dropped "const" in their signatures, so cannot be
-// declared in *.sigs.
-
-GdkEventType GdkEventGetEventType(GdkEvent* event);
-
-guint32 GdkEventGetTime(GdkEvent* event);
-
 // Some enum values have changed between versions.
 
 GdkEventType GdkKeyPress();
diff --git a/ui/gtk/gtk_key_bindings_handler.cc b/ui/gtk/gtk_key_bindings_handler.cc
index f8eb76d57c9f2..db0afa9419716 100644
--- a/ui/gtk/gtk_key_bindings_handler.cc
+++ b/ui/gtk/gtk_key_bindings_handler.cc
@@ -50,7 +50,7 @@ bool GtkKeyBindingsHandler::MatchEvent(
 
   auto* key = reinterpret_cast<GdkEventKey*>(gdk_event);
   DCHECK(key->type == GdkKeyPress() || key->type == GdkKeyRelease());
-  gtk_bindings_activate_event(G_OBJECT(handler_), key);
+  gtk_bindings_activate_event(GTK_OBJECT(handler_), key);
   gdk_event_free(gdk_event);
 
   bool matched = !edit_commands_.empty();
@@ -88,15 +88,15 @@ void GtkKeyBindingsHandler::HandlerInit(Handler* self) {
 
 void GtkKeyBindingsHandler::HandlerClassInit(HandlerClass* klass) {
   // Overrides all virtual methods related to editor key bindings.
-  klass->backspace = BackSpace;
-  klass->copy_clipboard = CopyClipboard;
-  klass->cut_clipboard = CutClipboard;
-  klass->delete_from_cursor = DeleteFromCursor;
-  klass->insert_at_cursor = InsertAtCursor;
-  klass->move_cursor = MoveCursor;
-  klass->paste_clipboard = PasteClipboard;
-  klass->set_anchor = SetAnchor;
-  klass->toggle_overwrite = ToggleOverwrite;
+  klass->parent_class.backspace = BackSpace;
+  klass->parent_class.copy_clipboard = CopyClipboard;
+  klass->parent_class.cut_clipboard = CutClipboard;
+  klass->parent_class.delete_from_cursor = DeleteFromCursor;
+  klass->parent_class.insert_at_cursor = InsertAtCursor;
+  klass->parent_class.move_cursor = MoveCursor;
+  klass->parent_class.paste_clipboard = PasteClipboard;
+  klass->parent_class.set_anchor = SetAnchor;
+  klass->parent_class.toggle_overwrite = ToggleOverwrite;
 
   // "move-focus", "move-viewport", "select-all" and "toggle-cursor-visible"
   // have no corresponding virtual methods. Since glib 2.18 (gtk 2.14),
diff --git a/ui/gtk/gtk_key_bindings_handler.h b/ui/gtk/gtk_key_bindings_handler.h
index f3c3831cf1899..1916458ab68a6 100644
--- a/ui/gtk/gtk_key_bindings_handler.h
+++ b/ui/gtk/gtk_key_bindings_handler.h
@@ -50,57 +50,13 @@ class GtkKeyBindingsHandler {
  private:
   // Object structure of Handler class, which is derived from GtkTextView.
   struct Handler {
-    // Starting in Gtk4, GtkTextView subclasses from GtkWidget instead of
-    // GtkContainer.  This class is only used on Gtk3, so to ensure ABI
-    // compatibility, we always want the Gtk3 struct layout even when building
-    // with Gtk4 headers.  To facilitate this, we manually copy the class
-    // hierarchy up to GtkWidget.
-    GtkWidget widget;
-    void* container_private;
-    void* text_view_private;
+    GtkTextView parent_object;
     GtkKeyBindingsHandler* owner;
   };
 
   // Class structure of Handler class.
   struct HandlerClass {
-    // Class layout for types changes between GTK versions, but is stable within
-    // the same major version.  This class is only used on Gtk3, so manually
-    // expand the class layout as it appears in Gtk3.
-    GInitiallyUnownedClass parent_class;
-
-    // GtkWidgetClass and GtkContainerClass
-    guint pad0;
-    void* pad1[95];
-    unsigned int pad2 : 1;
-    void* pad3[8];
-
-    // GtkTextViewClass
-    void (*populate_popup)(GtkTextView* text_view, GtkWidget* popup);
-    void (*move_cursor)(GtkTextView* text_view,
-                        GtkMovementStep step,
-                        gint count,
-                        gboolean extend_selection);
-    void (*set_anchor)(GtkTextView* text_view);
-    void (*insert_at_cursor)(GtkTextView* text_view, const gchar* str);
-    void (*delete_from_cursor)(GtkTextView* text_view,
-                               GtkDeleteType type,
-                               gint count);
-    void (*backspace)(GtkTextView* text_view);
-    void (*cut_clipboard)(GtkTextView* text_view);
-    void (*copy_clipboard)(GtkTextView* text_view);
-    void (*paste_clipboard)(GtkTextView* text_view);
-    void (*toggle_overwrite)(GtkTextView* text_view);
-    GtkTextBuffer* (*create_buffer)(GtkTextView* text_view);
-    void (*draw_layer)(GtkTextView* text_view,
-                       GtkTextViewLayer layer,
-                       cairo_t* cr);
-    gboolean (*extend_selection)(GtkTextView* text_view,
-                                 GtkTextExtendSelection granularity,
-                                 const GtkTextIter* location,
-                                 GtkTextIter* start,
-                                 GtkTextIter* end);
-    void (*insert_emoji)(GtkTextView* text_view);
-    void* pad4[4];
+    GtkTextViewClass parent_class;
   };
 
   // Creates a new instance of Handler class.
diff --git a/ui/gtk/gtk_types.h b/ui/gtk/gtk_types.h
index 32ac5cddde1d9..174df61d74196 100644
--- a/ui/gtk/gtk_types.h
+++ b/ui/gtk/gtk_types.h
@@ -14,7 +14,8 @@
 #define GdkRGBA Do_not_use_GdkRGBA_because_it_is_not_ABI_compatible
 
 extern "C" {
-#if GTK_MAJOR_VERSION == 3
+#if GTK_MAJOR_VERSION == 2
+#elif GTK_MAJOR_VERSION == 3
 using GskRenderNodeType = enum {
   GSK_NOT_A_RENDER_NODE = 0,
   GSK_CONTAINER_NODE,
diff --git a/ui/gtk/gtk_ui.cc b/ui/gtk/gtk_ui.cc
index 6266d03b50fd7..e986226d010b0 100644
--- a/ui/gtk/gtk_ui.cc
+++ b/ui/gtk/gtk_ui.cc
@@ -4,6 +4,7 @@
 
 #include "ui/gtk/gtk_ui.h"
 
+#include <gdk/gdkkeysyms.h>
 #include <cairo.h>
 #include <pango/pango.h>
 
@@ -49,13 +50,13 @@
 #include "ui/gtk/gtk_key_bindings_handler.h"
 #include "ui/gtk/gtk_ui_platform.h"
 #include "ui/gtk/gtk_util.h"
+#include "ui/gtk/chrome_gtk_frame.h"
+#include "ui/gtk/skia_utils_gtk.h"
 #include "ui/gtk/input_method_context_impl_gtk.h"
 #include "ui/gtk/native_theme_gtk.h"
-#include "ui/gtk/nav_button_provider_gtk.h"
 #include "ui/gtk/printing/print_dialog_gtk.h"
 #include "ui/gtk/printing/printing_gtk_util.h"
 #include "ui/gtk/select_file_dialog_impl.h"
-#include "ui/gtk/settings_provider_gtk.h"
 #include "ui/native_theme/native_theme.h"
 #include "ui/shell_dialogs/select_file_policy.h"
 #include "ui/views/controls/button/button.h"
@@ -144,42 +145,45 @@ class GtkButtonImageSource : public gfx::ImageSkiaSource {
         width, height, width * 4);
     cairo_t* cr = cairo_create(surface);
 
-    GtkCssContext context = GetStyleContextFromCss("GtkButton#button");
-    GtkStateFlags state_flags = StateToStateFlags(state_);
-    if (focus_) {
-      state_flags =
-          static_cast<GtkStateFlags>(state_flags | GTK_STATE_FLAG_FOCUSED);
-    }
-    gtk_style_context_set_state(context, state_flags);
-    gtk_render_background(context, cr, 0, 0, width, height);
-    gtk_render_frame(context, cr, 0, 0, width, height);
-    if (focus_) {
-      gfx::Rect focus_rect(width, height);
-
-      if (!GtkCheckVersion(3, 14)) {
-        gint focus_pad;
-        GtkStyleContextGetStyle(context, "focus-padding", &focus_pad, nullptr);
-        focus_rect.Inset(focus_pad, focus_pad);
-
-        if (state_ == ui::NativeTheme::kPressed) {
-          gint child_displacement_x, child_displacement_y;
-          gboolean displace_focus;
-          GtkStyleContextGetStyle(context, "child-displacement-x",
-                                  &child_displacement_x, "child-displacement-y",
-                                  &child_displacement_y, "displace-focus",
-                                  &displace_focus, nullptr);
-          if (displace_focus)
-            focus_rect.Offset(child_displacement_x, child_displacement_y);
-        }
-      }
-
-      if (!GtkCheckVersion(3, 20))
-        focus_rect.Inset(GtkStyleContextGetBorder(context));
-
-      gtk_render_focus(context, cr, focus_rect.x(), focus_rect.y(),
-                       focus_rect.width(), focus_rect.height());
+    // Create a temporary GTK button to snapshot
+    GtkWidget* window = gtk_offscreen_window_new();
+    GtkWidget* button = gtk_toggle_button_new();
+
+    if (state_ == ui::NativeTheme::kPressed)
+      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), true);
+    else if (state_ == ui::NativeTheme::kDisabled)
+      gtk_widget_set_sensitive(button, false);
+
+    gtk_widget_set_size_request(button, width, height);
+    gtk_container_add(GTK_CONTAINER(window), button);
+
+    gtk_widget_show_all(window);
+
+    if (focus_)
+      GTK_WIDGET_SET_FLAGS(button, GTK_HAS_FOCUS);
+
+    int w, h;
+    GdkPixmap* pixmap;
+
+    {
+      // http://crbug.com/346740
+      ANNOTATE_SCOPED_MEMORY_LEAK;
+      pixmap = gtk_widget_get_snapshot(button, nullptr);
     }
 
+    gdk_drawable_get_size(GDK_DRAWABLE(pixmap), &w, &h);
+    GdkColormap* colormap = gdk_drawable_get_colormap(pixmap);
+    GdkPixbuf* pixbuf = gdk_pixbuf_get_from_drawable(
+        nullptr, GDK_DRAWABLE(pixmap), colormap, 0, 0, 0, 0, w, h);
+
+    gdk_cairo_set_source_pixbuf(cr, pixbuf, 0, 0);
+    cairo_paint(cr);
+
+    g_object_unref(pixbuf);
+    g_object_unref(pixmap);
+
+    gtk_widget_destroy(window);
+
     cairo_destroy(cr);
     cairo_surface_destroy(surface);
 
@@ -222,8 +226,6 @@ int indicators_count;
 const char kUnknownContentType[] = "application/octet-stream";
 
 std::unique_ptr<SettingsProvider> CreateSettingsProvider(GtkUi* gtk_ui) {
-  if (GtkCheckVersion(3, 14))
-    return std::make_unique<SettingsProviderGtk>(gtk_ui);
 #if defined(USE_GIO)
   return std::make_unique<SettingsProviderGSettings>(gtk_ui);
 #else
@@ -281,8 +283,6 @@ gfx::FontRenderParams GetGtkFontRenderParams() {
 }
 
 views::LinuxUI::WindowFrameAction GetDefaultMiddleClickAction() {
-  if (GtkCheckVersion(3, 14))
-    return views::LinuxUI::WindowFrameAction::kNone;
   std::unique_ptr<base::Environment> env(base::Environment::Create());
   switch (base::nix::GetDesktopEnvironment(env.get())) {
     case base::nix::DESKTOP_ENVIRONMENT_KDE4:
@@ -343,6 +343,9 @@ GtkUi::GtkUi() {
       {ActionSource::kDoubleClick, Action::kToggleMaximize},
       {ActionSource::kMiddleClick, GetDefaultMiddleClickAction()},
       {ActionSource::kRightClick, Action::kMenu}};
+
+  fake_window_ = chrome_gtk_frame_new();
+  gtk_widget_realize(fake_window_);
 }
 
 GtkUi::~GtkUi() {
@@ -536,55 +539,23 @@ gfx::Image GtkUi::GetIconForContentType(const std::string& content_type,
 
   for (size_t i = 0; i < base::size(content_types); ++i) {
     auto icon = TakeGObject(g_content_type_get_icon(content_type.c_str()));
-    SkBitmap bitmap;
-    if (GtkCheckVersion(4)) {
-      auto icon_paintable = Gtk4IconThemeLookupByGicon(
-          theme, icon.get(), size, 1, GTK_TEXT_DIR_NONE,
-          static_cast<GtkIconLookupFlags>(0));
-      if (!icon_paintable)
-        continue;
+    auto* icon_info = gtk_icon_theme_lookup_by_gicon(
+        theme, icon.get(), size,
+        static_cast<GtkIconLookupFlags>(GTK_ICON_LOOKUP_FORCE_SIZE));
+    if (!icon_info)
+      continue;
+    struct Dtor
+    {
+      ~Dtor() { gtk_icon_info_free(info); }
+      GtkIconInfo* info;
+    } id{icon_info};
+    auto pixbuf = TakeGObject(gtk_icon_info_load_icon(icon_info, nullptr));
+    if (!pixbuf)
+      continue;
 
-      auto* paintable = GlibCast<GdkPaintable>(icon_paintable.get(),
-                                               gdk_paintable_get_type());
-      auto* snapshot = gtk_snapshot_new();
-      gdk_paintable_snapshot(paintable, snapshot, size, size);
-      auto* node = gtk_snapshot_free_to_node(snapshot);
-      GdkTexture* texture = GetTextureFromRenderNode(node);
-
-      bitmap.allocN32Pixels(gdk_texture_get_width(texture),
-                            gdk_texture_get_height(texture));
-      gdk_texture_download(texture, static_cast<guchar*>(bitmap.getAddr(0, 0)),
-                           bitmap.rowBytes());
-
-      gsk_render_node_unref(node);
-    } else {
-      auto icon_info = Gtk3IconThemeLookupByGicon(
-          theme, icon.get(), size,
-          static_cast<GtkIconLookupFlags>(GTK_ICON_LOOKUP_FORCE_SIZE));
-      if (!icon_info)
-        continue;
-      auto* surface =
-          gtk_icon_info_load_surface(icon_info.get(), nullptr, nullptr);
-      if (!surface)
-        continue;
-      DCHECK_EQ(cairo_surface_get_type(surface), CAIRO_SURFACE_TYPE_IMAGE);
-      DCHECK_EQ(cairo_image_surface_get_format(surface), CAIRO_FORMAT_ARGB32);
-
-      SkImageInfo image_info =
-          SkImageInfo::Make(cairo_image_surface_get_width(surface),
-                            cairo_image_surface_get_height(surface),
-                            kBGRA_8888_SkColorType, kUnpremul_SkAlphaType);
-      if (!bitmap.installPixels(
-              image_info, cairo_image_surface_get_data(surface),
-              image_info.minRowBytes(),
-              [](void*, void* surface) {
-                cairo_surface_destroy(
-                    reinterpret_cast<cairo_surface_t*>(surface));
-              },
-              surface)) {
-        continue;
-      }
-    }
+    SkBitmap bitmap = GdkPixbufToImageSkia(pixbuf.get());
+    DCHECK_EQ(size, bitmap.width());
+    DCHECK_EQ(size, bitmap.height());
     gfx::ImageSkia image_skia = gfx::ImageSkia::CreateFrom1xBitmap(bitmap);
     image_skia.MakeThreadSafe();
     return gfx::Image(image_skia);
@@ -698,7 +669,7 @@ views::LinuxUI::WindowFrameAction GtkUi::GetWindowFrameAction(
 void GtkUi::NotifyWindowManagerStartupComplete() {
   // TODO(port) Implement this using _NET_STARTUP_INFO_BEGIN/_NET_STARTUP_INFO
   // from http://standards.freedesktop.org/startup-notification-spec/ instead.
-  gdk_display_notify_startup_complete(gdk_display_get_default(), nullptr);
+  gdk_notify_startup_complete();
 }
 
 void GtkUi::AddDeviceScaleFactorObserver(
@@ -726,8 +697,6 @@ bool GtkUi::AnimationsEnabled() const {
 }
 
 std::unique_ptr<views::NavButtonProvider> GtkUi::CreateNavButtonProvider() {
-  if (GtkCheckVersion(3, 14))
-    return std::make_unique<gtk::NavButtonProviderGtk>();
   return nullptr;
 }
 
@@ -764,10 +733,7 @@ base::flat_map<std::string, std::string> GtkUi::GetKeyboardLayoutMap() {
     // The order of the layouts is based on the system default ordering in
     // Keyboard Settings. The currently active layout does not affect this
     // order.
-    const bool success =
-        GtkCheckVersion(4) ? gdk_display_map_keycode(display, keycode, &keys,
-                                                     &keyvals, &n_entries)
-                           : gdk_keymap_get_entries_for_keycode(
+    const bool success = gdk_keymap_get_entries_for_keycode(
                                  keymap, keycode, &keys, &keyvals, &n_entries);
     if (success) {
       for (gint i = 0; i < n_entries; ++i) {
@@ -813,10 +779,6 @@ int GtkUi::GetCursorThemeSize() {
 
 bool GtkUi::MatchEvent(const ui::Event& event,
                        std::vector<ui::TextEditCommandAuraLinux>* commands) {
-  // GTK4 dropped custom key bindings.
-  if (GtkCheckVersion(4))
-    return false;
-
   // TODO(crbug.com/963419): Use delegate's |GetGdkKeymap| here to
   // determine if GtkUi's key binding handling implementation is used or not.
   // Ozone/Wayland was unintentionally using GtkUi for keybinding handling, so
@@ -835,7 +797,6 @@ void GtkUi::OnThemeChanged(GtkSettings* settings, GtkParamSpec* param) {
   colors_.clear();
   custom_frame_colors_.clear();
   native_frame_colors_.clear();
-  native_theme_->OnThemeChanged(settings, param);
   LoadGtkValues();
   native_theme_->NotifyOnNativeThemeUpdated();
 }
@@ -862,6 +823,19 @@ void GtkUi::OnDeviceScaleFactorMaybeChanged(void*, GParamSpec*) {
   UpdateDeviceScaleFactor();
 }
 
+bool GtkUi::GetChromeStyleColor(const char* style_property,
+                                SkColor* ret_color) const {
+  GdkColor* style_color = nullptr;
+  gtk_widget_style_get(fake_window_, style_property, &style_color, nullptr);
+  if (style_color) {
+    *ret_color = GdkColorToSkColor(*style_color);
+    gdk_color_free(style_color);
+    return true;
+  }
+
+  return false;
+}
+
 void GtkUi::LoadGtkValues() {
   // TODO(thomasanderson): GtkThemeService had a comment here about having to
   // muck with the raw Prefs object to remove prefs::kCurrentThemeImages or else
@@ -872,20 +846,24 @@ void GtkUi::LoadGtkValues() {
 }
 
 void GtkUi::UpdateColors() {
-  SkColor location_bar_border = GetBorderColor("GtkEntry#entry");
+  const color_utils::HSL kDefaultTintFrameIncognito = {-1, 0.2f, 0.35f};
+
+  // GetTextAAColor(GetEntry(), NORMAL) ~= GetBorderColor("GtkEntry#entry")
+  SkColor location_bar_border = native_theme_->GetSystemColor(
+    ui::NativeTheme::kColorId_UnfocusedBorderColor);
   if (SkColorGetA(location_bar_border))
     colors_[ThemeProperties::COLOR_LOCATION_BAR_BORDER] = location_bar_border;
 
-  inactive_selection_bg_color_ = GetSelectionBgColor(
-      GtkCheckVersion(3, 20) ? "GtkTextView#textview.view:backdrop "
-                               "#text:backdrop #selection:backdrop"
-                             : "GtkTextView.view:selected:backdrop");
-  inactive_selection_fg_color_ =
-      GetFgColor(GtkCheckVersion(3, 20) ? "GtkTextView#textview.view:backdrop "
-                                          "#text:backdrop #selection:backdrop"
-                                        : "GtkTextView.view:selected:backdrop");
+  // GetBgColor(GetEntry(), SELECTED) =~ GetSelectionBgColor("GtkTextView.view:selected:backdrop");
+  inactive_selection_bg_color_ = native_theme_->GetSystemColor(
+    ui::NativeTheme::kColorId_TextfieldSelectionBackgroundFocused);
+  // GetTextColor(GetEntry(), SELECTED) ~= GetFgColor("GtkTextView.view:selected:backdrop");
+  inactive_selection_fg_color_ = native_theme_->GetSystemColor(
+    ui::NativeTheme::kColorId_TextfieldSelectionColor);
 
-  SkColor tab_border = GetBorderColor("GtkButton#button");
+  // GetBgColor(GetLabel(), INSENSITIVE) =~ GetBorderColor("GtkButton#button");
+  SkColor tab_border = native_theme_->GetSystemColor(
+    ui::NativeTheme::kColorId_ButtonBorderColor);
   // Separates the toolbar from the bookmark bar or butter bars.
   colors_[ThemeProperties::COLOR_TOOLBAR_CONTENT_AREA_SEPARATOR] = tab_border;
   // Separates entries in the downloads bar.
@@ -896,10 +874,12 @@ void GtkUi::UpdateColors() {
           ui::NativeTheme::kColorId_TextfieldDefaultBackground);
   colors_[ThemeProperties::COLOR_NTP_TEXT] = native_theme_->GetSystemColor(
       ui::NativeTheme::kColorId_TextfieldDefaultColor);
-  colors_[ThemeProperties::COLOR_NTP_HEADER] =
-      GetBorderColor("GtkButton#button");
+  // GetBgColor(GetLabel(), INSENSITIVE) =~ GetBorderColor("GtkButton#button")
+  colors_[ThemeProperties::COLOR_NTP_HEADER] = native_theme_->GetSystemColor(
+    ui::NativeTheme::kColorId_ButtonBorderColor);
 
-  SkColor tab_text_color = GetFgColor("GtkLabel#label");
+  SkColor tab_text_color = native_theme_->GetSystemColor(
+    ui::NativeTheme::kColorId_DefaultIconColor); // GetTextColor(GetLabel, NORMAL)
   colors_[ThemeProperties::COLOR_TOOLBAR_BUTTON_ICON] = tab_text_color;
   colors_[ThemeProperties::COLOR_TOOLBAR_BUTTON_ICON_HOVERED] = tab_text_color;
   colors_[ThemeProperties::COLOR_TOOLBAR_BUTTON_ICON_PRESSED] = tab_text_color;
@@ -935,24 +915,27 @@ void GtkUi::UpdateColors() {
   for (bool custom_frame : {false, true}) {
     ColorMap& color_map =
         custom_frame ? custom_frame_colors_ : native_frame_colors_;
-    const std::string header_selector =
-        custom_frame ? "#headerbar.header-bar.titlebar" : "GtkMenuBar#menubar";
-    const std::string header_selector_inactive = header_selector + ":backdrop";
     const SkColor frame_color =
-        SkColorSetA(GetBgColor(header_selector), SK_AlphaOPAQUE);
-    const SkColor frame_color_inactive =
-        SkColorSetA(GetBgColor(header_selector_inactive), SK_AlphaOPAQUE);
+      native_theme_->GetSystemColor(ui::NativeTheme::kColorId_WindowBackground);
+    const SkColor frame_color_incognito =
+        color_utils::HSLShift(frame_color, kDefaultTintFrameIncognito);
+    const SkColor frame_color_inactive = native_theme_->GetSystemColor(
+      ui::NativeTheme::kColorId_NotificationBackground);
+    const SkColor frame_color_incognito_inactive =
+        color_utils::HSLShift(frame_color_inactive, kDefaultTintFrameIncognito);
 
     color_map[ThemeProperties::COLOR_FRAME_ACTIVE] = frame_color;
     color_map[ThemeProperties::COLOR_FRAME_INACTIVE] = frame_color_inactive;
-    color_map[ThemeProperties::COLOR_FRAME_ACTIVE_INCOGNITO] = frame_color;
+    color_map[ThemeProperties::COLOR_FRAME_ACTIVE_INCOGNITO] =
+        frame_color_incognito;
     color_map[ThemeProperties::COLOR_FRAME_INACTIVE_INCOGNITO] =
-        frame_color_inactive;
+        frame_color_incognito_inactive;
 
     // Compose the window color on the frame color to ensure the resulting tab
     // color is opaque.
+    auto tmp = native_theme_->GetSystemColor(ui::NativeTheme::kColorId_DialogBackground);
     SkColor tab_color =
-        color_utils::GetResultingPaintColor(GetBgColor(""), frame_color);
+        color_utils::GetResultingPaintColor(tmp, frame_color);
 
     color_map[ThemeProperties::COLOR_TOOLBAR] = tab_color;
     color_map[ThemeProperties::COLOR_DOWNLOAD_SHELF] = tab_color;
@@ -963,21 +946,29 @@ void GtkUi::UpdateColors() {
     color_map[ThemeProperties::COLOR_TAB_BACKGROUND_ACTIVE_FRAME_INACTIVE] =
         tab_color;
 
-    const SkColor background_tab_text_color =
-        GetFgColor(header_selector + " GtkLabel#label.title");
-    const SkColor background_tab_text_color_inactive =
-        GetFgColor(header_selector_inactive + " GtkLabel#label.title");
+    const SkColor background_tab_text_color = native_theme_->GetSystemColor(
+      ui::NativeTheme::kColorId_LabelEnabledColor);
+    const SkColor background_tab_text_color_inactive = native_theme_->GetSystemColor(
+      ui::NativeTheme::kColorId_LabelDisabledColor);
 
     color_map[ThemeProperties::COLOR_TAB_FOREGROUND_INACTIVE_FRAME_ACTIVE] =
         background_tab_text_color;
     color_map[ThemeProperties::
                   COLOR_TAB_FOREGROUND_INACTIVE_FRAME_ACTIVE_INCOGNITO] =
-        background_tab_text_color;
+        color_utils::BlendForMinContrast(
+            color_utils::HSLShift(background_tab_text_color,
+                                  kDefaultTintFrameIncognito),
+            frame_color_incognito)
+            .color;
     color_map[ThemeProperties::COLOR_TAB_FOREGROUND_INACTIVE_FRAME_INACTIVE] =
         background_tab_text_color_inactive;
     color_map[ThemeProperties::
                   COLOR_TAB_FOREGROUND_INACTIVE_FRAME_INACTIVE_INCOGNITO] =
-        background_tab_text_color_inactive;
+        color_utils::BlendForMinContrast(
+            color_utils::HSLShift(background_tab_text_color_inactive,
+                                  kDefaultTintFrameIncognito),
+            frame_color_incognito_inactive)
+            .color;
 
     color_map[ThemeProperties::COLOR_OMNIBOX_TEXT] =
         native_theme_->GetSystemColor(
@@ -988,11 +979,9 @@ void GtkUi::UpdateColors() {
 
     // These colors represent the border drawn around tabs and between
     // the tabstrip and toolbar.
-    SkColor toolbar_top_separator = GetBorderColor(
-        header_selector + " GtkSeparator#separator.vertical.titlebutton");
-    SkColor toolbar_top_separator_inactive =
-        GetBorderColor(header_selector +
-                       ":backdrop GtkSeparator#separator.vertical.titlebutton");
+    SkColor toolbar_top_separator = native_theme_->GetSystemColor(
+      ui::NativeTheme::kColorId_MenuSeparatorColor);
+    SkColor toolbar_top_separator_inactive = toolbar_top_separator;
 
     auto toolbar_top_separator_has_good_contrast = [&]() {
       // This constant is copied from chrome/browser/themes/theme_service.cc.
@@ -1008,13 +997,6 @@ void GtkUi::UpdateColors() {
                  kMinContrastRatio;
     };
 
-    if (!toolbar_top_separator_has_good_contrast()) {
-      toolbar_top_separator =
-          GetBorderColor(header_selector + " GtkButton#button");
-      toolbar_top_separator_inactive =
-          GetBorderColor(header_selector + ":backdrop GtkButton#button");
-    }
-
     // If we can't get a contrasting stroke from the theme, have ThemeService
     // provide a stroke color for us.
     if (toolbar_top_separator_has_good_contrast()) {
@@ -1072,27 +1054,10 @@ float GtkUi::GetRawDeviceScaleFactor() {
   if (display::Display::HasForceDeviceScaleFactor())
     return display::Display::GetForcedDeviceScaleFactor();
 
-  float scale = gtk_widget_get_scale_factor(GetDummyWindow());
-  DCHECK_GT(scale, 0.0);
-
-  double resolution = 0;
-  if (GtkCheckVersion(4)) {
-    auto* settings = gtk_settings_get_default();
-    int dpi = 0;
-    g_object_get(settings, "gtk-xft-dpi", &dpi, nullptr);
-    resolution = dpi / 1024.0;
-  } else {
-    GdkScreen* screen = gdk_screen_get_default();
-    resolution = gdk_screen_get_resolution(screen);
-  }
-  if (resolution > 0)
-    scale *= resolution / kDefaultDPI;
-
-  // Round to the nearest 64th so that UI can losslessly multiply and divide
-  // the scale factor.
-  scale = roundf(scale * 64) / 64;
-
-  return scale;
+  GtkSettings* gtk_settings = gtk_settings_get_default();
+  gint gtk_dpi = -1;
+  g_object_get(gtk_settings, "gtk-xft-dpi", &gtk_dpi, nullptr);
+  return gtk_dpi / (1024 * kDefaultDPI);
 }
 
 void GtkUi::UpdateDeviceScaleFactor() {
diff --git a/ui/gtk/gtk_ui.h b/ui/gtk/gtk_ui.h
index e4ecb6e36402e..59f6571ff6223 100644
--- a/ui/gtk/gtk_ui.h
+++ b/ui/gtk/gtk_ui.h
@@ -143,12 +143,19 @@ class GtkUi : public views::LinuxUI {
   // Updates |default_font_*|.
   void UpdateDefaultFont();
 
+  // Gets a ChromeGtkFrame theme color; returns true on success.  No-op on gtk3.
+  bool GetChromeStyleColor(const char* sytle_property,
+                           SkColor* ret_color) const;
+
   float GetRawDeviceScaleFactor();
 
   std::unique_ptr<GtkUiPlatform> platform_;
 
   NativeThemeGtk* native_theme_;
 
+  // A regular GtkWindow.
+  GtkWidget* fake_window_;
+
   // Colors calculated by LoadGtkValues() that are given to the
   // caller while |use_gtk_| is true.
   ColorMap colors_;
diff --git a/ui/gtk/gtk_ui_platform.h b/ui/gtk/gtk_ui_platform.h
index bfd4a98f1f6a1..ff2bfb7d349e6 100644
--- a/ui/gtk/gtk_ui_platform.h
+++ b/ui/gtk/gtk_ui_platform.h
@@ -13,7 +13,7 @@
 using GdkKeymap = struct _GdkKeymap;
 using GtkWindow = struct _GtkWindow;
 using GtkWidget = struct _GtkWidget;
-using GdkWindow = struct _GdkWindow;
+using GdkWindow = struct _GdkDrawable;
 
 namespace gtk {
 
diff --git a/ui/gtk/gtk_util.cc b/ui/gtk/gtk_util.cc
index 92b600e721150..f2ae008637eb4 100644
--- a/ui/gtk/gtk_util.cc
+++ b/ui/gtk/gtk_util.cc
@@ -4,6 +4,8 @@
 
 #include "ui/gtk/gtk_util.h"
 
+#include <gdk/gdkkeysyms.h>
+
 #include <locale.h>
 #include <stddef.h>
 
@@ -40,12 +42,6 @@ namespace {
 
 const char kAuraTransientParent[] = "aura-transient-parent";
 
-GtkCssContext GetTooltipContext() {
-  return AppendCssNodeToStyleContext(
-      {}, GtkCheckVersion(3, 20) ? "#tooltip.background"
-                                 : "GtkWindow#window.background.tooltip");
-}
-
 void CommonInitFromCommandLine(const base::CommandLine& command_line) {
   // Callers should have already called setlocale(LC_ALL, "") and
   // setlocale(LC_NUMERIC, "C") by now. Chrome does this in
@@ -57,87 +53,6 @@ void CommonInitFromCommandLine(const base::CommandLine& command_line) {
   GtkInit(command_line.argv());
 }
 
-GtkCssContext AppendCssNodeToStyleContextImpl(
-    GtkCssContext context,
-    GType gtype,
-    const std::string& name,
-    const std::string& object_name,
-    const std::vector<std::string>& classes,
-    GtkStateFlags state,
-    float scale) {
-  if (GtkCheckVersion(4)) {
-    // GTK_TYPE_BOX is used instead of GTK_TYPE_WIDGET because:
-    // 1. Widgets are abstract and cannot be created directly.
-    // 2. The widget must be a container type so that it unrefs child widgets
-    //    on destruction.
-    auto* widget_object = object_name.empty()
-                              ? g_object_new(GTK_TYPE_BOX, nullptr)
-                              : g_object_new(GTK_TYPE_BOX, "css-name",
-                                             object_name.c_str(), nullptr);
-    auto widget = TakeGObject(GTK_WIDGET(widget_object));
-
-    if (!name.empty())
-      gtk_widget_set_name(widget, name.c_str());
-
-    std::vector<const char*> css_classes;
-    css_classes.reserve(classes.size() + 1);
-    for (const auto& css_class : classes)
-      css_classes.push_back(css_class.c_str());
-    css_classes.push_back(nullptr);
-    gtk_widget_set_css_classes(widget, css_classes.data());
-
-    gtk_widget_set_state_flags(widget, state, false);
-
-    if (context)
-      gtk_widget_set_parent(widget, context.widget());
-
-    gtk_style_context_set_scale(gtk_widget_get_style_context(widget), scale);
-
-    return GtkCssContext(widget, context ? context.root() : widget);
-  } else {
-    GtkWidgetPath* path =
-        context ? gtk_widget_path_copy(gtk_style_context_get_path(context))
-                : gtk_widget_path_new();
-    gtk_widget_path_append_type(path, gtype);
-
-    if (!object_name.empty()) {
-      if (GtkCheckVersion(3, 20))
-        gtk_widget_path_iter_set_object_name(path, -1, object_name.c_str());
-      else
-        gtk_widget_path_iter_add_class(path, -1, object_name.c_str());
-    }
-
-    if (!name.empty())
-      gtk_widget_path_iter_set_name(path, -1, name.c_str());
-
-    for (const auto& css_class : classes)
-      gtk_widget_path_iter_add_class(path, -1, css_class.c_str());
-
-    if (GtkCheckVersion(3, 14))
-      gtk_widget_path_iter_set_state(path, -1, state);
-
-    GtkCssContext child_context(TakeGObject(gtk_style_context_new()));
-    gtk_style_context_set_path(child_context, path);
-    if (GtkCheckVersion(3, 14)) {
-      gtk_style_context_set_state(child_context, state);
-    } else {
-      GtkStateFlags child_state = state;
-      if (context) {
-        child_state = static_cast<GtkStateFlags>(
-            child_state | gtk_style_context_get_state(context));
-      }
-      gtk_style_context_set_state(child_context, child_state);
-    }
-
-    gtk_style_context_set_scale(child_context, scale);
-
-    gtk_style_context_set_parent(child_context, context);
-
-    gtk_widget_path_unref(path);
-    return GtkCssContext(child_context);
-  }
-}
-
 GtkWidget* CreateDummyWindow() {
   GtkWidget* window = GtkToplevelWindowNew();
   gtk_widget_realize(window);
@@ -146,20 +61,6 @@ GtkWidget* CreateDummyWindow() {
 
 }  // namespace
 
-const char* GtkCssMenu() {
-  return GtkCheckVersion(4) ? "#popover.background.menu #contents"
-                            : "GtkMenu#menu";
-}
-
-const char* GtkCssMenuItem() {
-  return GtkCheckVersion(4) ? "#modelbutton.flat" : "GtkMenuItem#menuitem";
-}
-
-const char* GtkCssMenuScrollbar() {
-  return GtkCheckVersion(4) ? "#scrollbar #range"
-                            : "GtkScrollbar#scrollbar #trough";
-}
-
 void GtkInitFromCommandLine(const base::CommandLine& command_line) {
   CommonInitFromCommandLine(command_line);
 }
@@ -216,350 +117,6 @@ void ParseButtonLayout(const std::string& button_string,
   }
 }
 
-CairoSurface::CairoSurface(SkBitmap& bitmap)
-    : surface_(cairo_image_surface_create_for_data(
-          static_cast<unsigned char*>(bitmap.getAddr(0, 0)),
-          CAIRO_FORMAT_ARGB32,
-          bitmap.width(),
-          bitmap.height(),
-          cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32, bitmap.width()))),
-      cairo_(cairo_create(surface_)) {}
-
-CairoSurface::CairoSurface(const gfx::Size& size)
-    : surface_(cairo_image_surface_create(CAIRO_FORMAT_ARGB32,
-                                          size.width(),
-                                          size.height())),
-      cairo_(cairo_create(surface_)) {
-  DCHECK(cairo_surface_status(surface_) == CAIRO_STATUS_SUCCESS);
-  // Clear the surface.
-  cairo_save(cairo_);
-  cairo_set_source_rgba(cairo_, 0, 0, 0, 0);
-  cairo_set_operator(cairo_, CAIRO_OPERATOR_SOURCE);
-  cairo_paint(cairo_);
-  cairo_restore(cairo_);
-}
-
-CairoSurface::~CairoSurface() {
-  cairo_destroy(cairo_);
-  cairo_surface_destroy(surface_);
-}
-
-SkColor CairoSurface::GetAveragePixelValue(bool frame) {
-  cairo_surface_flush(surface_);
-  SkColor* data =
-      reinterpret_cast<SkColor*>(cairo_image_surface_get_data(surface_));
-  int width = cairo_image_surface_get_width(surface_);
-  int height = cairo_image_surface_get_height(surface_);
-  DCHECK(4 * width == cairo_image_surface_get_stride(surface_));
-  long a = 0, r = 0, g = 0, b = 0;
-  unsigned int max_alpha = 0;
-  for (int i = 0; i < width * height; i++) {
-    SkColor color = data[i];
-    max_alpha = std::max(SkColorGetA(color), max_alpha);
-    a += SkColorGetA(color);
-    r += SkColorGetR(color);
-    g += SkColorGetG(color);
-    b += SkColorGetB(color);
-  }
-  if (a == 0)
-    return SK_ColorTRANSPARENT;
-  return SkColorSetARGB(frame ? max_alpha : a / (width * height), r * 255 / a,
-                        g * 255 / a, b * 255 / a);
-}
-
-GtkCssContext::GtkCssContext(GtkWidget* widget, GtkWidget* root)
-    : widget_(widget), root_(WrapGObject(root)) {
-  DCHECK(GtkCheckVersion(4));
-}
-
-GtkCssContext::GtkCssContext(GtkStyleContext* context)
-    : context_(WrapGObject(context)) {
-  DCHECK(!GtkCheckVersion(4));
-}
-
-GtkCssContext::GtkCssContext() = default;
-GtkCssContext::GtkCssContext(const GtkCssContext&) = default;
-GtkCssContext::GtkCssContext(GtkCssContext&&) = default;
-GtkCssContext& GtkCssContext::operator=(const GtkCssContext&) = default;
-GtkCssContext& GtkCssContext::operator=(GtkCssContext&&) = default;
-GtkCssContext::~GtkCssContext() = default;
-
-GtkCssContext::operator GtkStyleContext*() {
-  if (GtkCheckVersion(4))
-    return widget_ ? gtk_widget_get_style_context(widget_) : nullptr;
-  return context_;
-}
-
-GtkCssContext GtkCssContext::GetParent() {
-  if (GtkCheckVersion(4)) {
-    return GtkCssContext(WrapGObject(gtk_widget_get_parent(widget_)),
-                         root_ == widget_ ? ScopedGObject<GtkWidget>() : root_);
-  }
-  return GtkCssContext(WrapGObject(gtk_style_context_get_parent(context_)));
-}
-
-GtkWidget* GtkCssContext::widget() {
-  DCHECK(GtkCheckVersion(4));
-  return widget_;
-}
-
-GtkWidget* GtkCssContext::root() {
-  DCHECK(GtkCheckVersion(4));
-  return root_;
-}
-
-GtkStateFlags StateToStateFlags(ui::NativeTheme::State state) {
-  switch (state) {
-    case ui::NativeTheme::kDisabled:
-      return GTK_STATE_FLAG_INSENSITIVE;
-    case ui::NativeTheme::kHovered:
-      return GTK_STATE_FLAG_PRELIGHT;
-    case ui::NativeTheme::kNormal:
-      return GTK_STATE_FLAG_NORMAL;
-    case ui::NativeTheme::kPressed:
-      return static_cast<GtkStateFlags>(GTK_STATE_FLAG_PRELIGHT |
-                                        GTK_STATE_FLAG_ACTIVE);
-    default:
-      NOTREACHED();
-      return GTK_STATE_FLAG_NORMAL;
-  }
-}
-
-NO_SANITIZE("cfi-icall")
-GtkCssContext AppendCssNodeToStyleContext(GtkCssContext context,
-                                          const std::string& css_node) {
-  enum {
-    CSS_TYPE,
-    CSS_NAME,
-    CSS_OBJECT_NAME,
-    CSS_CLASS,
-    CSS_PSEUDOCLASS,
-    CSS_NONE,
-  } part_type = CSS_TYPE;
-
-  static const struct {
-    const char* name;
-    GtkStateFlags state_flag;
-  } pseudo_classes[] = {
-      {"active", GTK_STATE_FLAG_ACTIVE},
-      {"hover", GTK_STATE_FLAG_PRELIGHT},
-      {"selected", GTK_STATE_FLAG_SELECTED},
-      {"disabled", GTK_STATE_FLAG_INSENSITIVE},
-      {"indeterminate", GTK_STATE_FLAG_INCONSISTENT},
-      {"focus", GTK_STATE_FLAG_FOCUSED},
-      {"backdrop", GTK_STATE_FLAG_BACKDROP},
-      {"link", GTK_STATE_FLAG_LINK},
-      {"visited", GTK_STATE_FLAG_VISITED},
-      {"checked", GTK_STATE_FLAG_CHECKED},
-  };
-
-  GType gtype = G_TYPE_NONE;
-  std::string name;
-  std::string object_name;
-  std::vector<std::string> classes;
-  GtkStateFlags state = GTK_STATE_FLAG_NORMAL;
-
-  base::StringTokenizer t(css_node, ".:#()");
-  t.set_options(base::StringTokenizer::RETURN_DELIMS);
-  while (t.GetNext()) {
-    if (t.token_is_delim()) {
-      switch (*t.token_begin()) {
-        case '(':
-          part_type = CSS_NAME;
-          break;
-        case ')':
-          part_type = CSS_NONE;
-          break;
-        case '#':
-          part_type = CSS_OBJECT_NAME;
-          break;
-        case '.':
-          part_type = CSS_CLASS;
-          break;
-        case ':':
-          part_type = CSS_PSEUDOCLASS;
-          break;
-        default:
-          NOTREACHED();
-      }
-    } else {
-      switch (part_type) {
-        case CSS_NAME:
-          name = t.token();
-          break;
-        case CSS_OBJECT_NAME:
-          object_name = t.token();
-          break;
-        case CSS_TYPE: {
-          if (!GtkCheckVersion(4)) {
-            gtype = g_type_from_name(t.token().c_str());
-            DCHECK(gtype);
-          }
-          break;
-        }
-        case CSS_CLASS:
-          classes.push_back(t.token());
-          break;
-        case CSS_PSEUDOCLASS: {
-          GtkStateFlags state_flag = GTK_STATE_FLAG_NORMAL;
-          for (const auto& pseudo_class_entry : pseudo_classes) {
-            if (strcmp(pseudo_class_entry.name, t.token().c_str()) == 0) {
-              state_flag = pseudo_class_entry.state_flag;
-              break;
-            }
-          }
-          state = static_cast<GtkStateFlags>(state | state_flag);
-          break;
-        }
-        case CSS_NONE:
-          NOTREACHED();
-      }
-    }
-  }
-
-  // Always add a "chromium" class so that themes can style chromium
-  // widgets specially if they want to.
-  classes.push_back("chromium");
-
-  float scale = std::round(GetDeviceScaleFactor());
-
-  return AppendCssNodeToStyleContextImpl(context, gtype, name, object_name,
-                                         classes, state, scale);
-}
-
-GtkCssContext GetStyleContextFromCss(const std::string& css_selector) {
-  // Prepend a window node to the selector since all widgets must live
-  // in a window, but we don't want to specify that every time.
-  auto context = AppendCssNodeToStyleContext({}, "GtkWindow#window.background");
-
-  for (const auto& widget_type :
-       base::SplitString(css_selector, base::kWhitespaceASCII,
-                         base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY)) {
-    context = AppendCssNodeToStyleContext(context, widget_type);
-  }
-  return context;
-}
-
-SkColor GetBgColorFromStyleContext(GtkCssContext context) {
-  // Backgrounds are more general than solid colors (eg. gradients),
-  // but chromium requires us to boil this down to one color.  We
-  // cannot use the background-color here because some themes leave it
-  // set to a garbage color because a background-image will cover it
-  // anyway.  So we instead render the background into a 24x24 bitmap,
-  // removing any borders, and hope that we get a good color.
-  ApplyCssToContext(context,
-                    "* {"
-                    "border-radius: 0px;"
-                    "border-style: none;"
-                    "box-shadow: none;"
-                    "}");
-  gfx::Size size(24, 24);
-  CairoSurface surface(size);
-  RenderBackground(size, surface.cairo(), context);
-  return surface.GetAveragePixelValue(false);
-}
-
-SkColor GetFgColor(const std::string& css_selector) {
-  return GtkStyleContextGetColor(GetStyleContextFromCss(css_selector));
-}
-
-ScopedCssProvider GetCssProvider(const std::string& css) {
-  auto provider = TakeGObject(gtk_css_provider_new());
-  GtkCssProviderLoadFromData(provider, css.c_str(), -1);
-  return provider;
-}
-
-void ApplyCssProviderToContext(GtkCssContext context,
-                               GtkCssProvider* provider) {
-  while (context) {
-    gtk_style_context_add_provider(context, GTK_STYLE_PROVIDER(provider),
-                                   G_MAXUINT);
-    context = context.GetParent();
-  }
-}
-
-void ApplyCssToContext(GtkCssContext context, const std::string& css) {
-  auto provider = GetCssProvider(css);
-  ApplyCssProviderToContext(context, provider);
-}
-
-void RenderBackground(const gfx::Size& size,
-                      cairo_t* cr,
-                      GtkCssContext context) {
-  if (!context)
-    return;
-  RenderBackground(size, cr, context.GetParent());
-  gtk_render_background(context, cr, 0, 0, size.width(), size.height());
-}
-
-SkColor GetBgColor(const std::string& css_selector) {
-  return GetBgColorFromStyleContext(GetStyleContextFromCss(css_selector));
-}
-
-SkColor GetBorderColor(const std::string& css_selector) {
-  // Borders have the same issue as backgrounds, due to the
-  // border-image property.
-  auto context = GetStyleContextFromCss(css_selector);
-  gfx::Size size(24, 24);
-  CairoSurface surface(size);
-  gtk_render_frame(context, surface.cairo(), 0, 0, size.width(), size.height());
-  return surface.GetAveragePixelValue(true);
-}
-
-SkColor GetSelectionBgColor(const std::string& css_selector) {
-  auto context = GetStyleContextFromCss(css_selector);
-  if (GtkCheckVersion(3, 20))
-    return GetBgColorFromStyleContext(context);
-  DCHECK(!GtkCheckVersion(4));
-  // This is verbatim how Gtk gets the selection color on versions
-  // before 3.20.
-  return GtkStyleContextGetBackgroundColor(context);
-}
-
-bool ContextHasClass(GtkCssContext context, const std::string& style_class) {
-  bool has_class = gtk_style_context_has_class(context, style_class.c_str());
-  if (!GtkCheckVersion(4)) {
-    has_class |= gtk_widget_path_iter_has_class(
-        gtk_style_context_get_path(context), -1, style_class.c_str());
-  }
-  return has_class;
-}
-
-SkColor GetSeparatorColor(const std::string& css_selector) {
-  if (!GtkCheckVersion(3, 20))
-    return GetFgColor(css_selector);
-
-  auto context = GetStyleContextFromCss(css_selector);
-  bool horizontal = ContextHasClass(context, "horizontal");
-
-  int w = 1, h = 1;
-  if (GtkCheckVersion(4)) {
-    auto size = GetSeparatorSize(horizontal);
-    w = size.width();
-    h = size.height();
-  } else {
-    GtkStyleContextGet(context, "min-width", &w, "min-height", &h, nullptr);
-  }
-  auto border = GtkStyleContextGetBorder(context);
-  auto padding = GtkStyleContextGetPadding(context);
-  w += border.left() + padding.left() + padding.right() + border.right();
-  h += border.top() + padding.top() + padding.bottom() + border.bottom();
-
-  if (horizontal) {
-    w = 24;
-    h = std::max(h, 1);
-  } else {
-    DCHECK(ContextHasClass(context, "vertical"));
-    h = 24;
-    w = std::max(w, 1);
-  }
-
-  CairoSurface surface(gfx::Size(w, h));
-  gtk_render_background(context, surface.cairo(), 0, 0, w, h);
-  gtk_render_frame(context, surface.cairo(), 0, 0, w, h);
-  return surface.GetAveragePixelValue(false);
-}
-
 std::string GetGtkSettingsStringProperty(GtkSettings* settings,
                                          const gchar* prop_name) {
   GValue layout = G_VALUE_INIT;
@@ -645,16 +202,11 @@ GdkEvent* GdkEventFromKeyEvent(const ui::KeyEvent& key_event) {
 }
 
 GtkIconTheme* GetDefaultIconTheme() {
-  return GtkCheckVersion(4)
-             ? gtk_icon_theme_get_for_display(gdk_display_get_default())
-             : gtk_icon_theme_get_default();
+  return gtk_icon_theme_get_default();
 }
 
 void GtkWindowDestroy(GtkWidget* widget) {
-  if (GtkCheckVersion(4))
-    gtk_window_destroy(GTK_WINDOW(widget));
-  else
-    gtk_widget_destroy(widget);
+  gtk_widget_destroy(widget);
 }
 
 GtkWidget* GetDummyWindow() {
@@ -662,421 +214,9 @@ GtkWidget* GetDummyWindow() {
   return window;
 }
 
-gfx::Size GetSeparatorSize(bool horizontal) {
-  auto widget = TakeGObject(gtk_separator_new(
-      horizontal ? GTK_ORIENTATION_HORIZONTAL : GTK_ORIENTATION_VERTICAL));
-  GtkRequisition natural_size;
-  gtk_widget_get_preferred_size(widget, nullptr, &natural_size);
-  return {natural_size.width, natural_size.height};
-}
-
 float GetDeviceScaleFactor() {
   views::LinuxUI* linux_ui = views::LinuxUI::instance();
   return linux_ui ? linux_ui->GetDeviceScaleFactor() : 1;
 }
 
-GdkTexture* GetTextureFromRenderNode(GskRenderNode* node) {
-  DCHECK(GtkCheckVersion(4));
-  struct {
-    GskRenderNodeType node_type;
-    GskRenderNode* (*get_child)(GskRenderNode*);
-  } constexpr simple_getters[] = {
-      {GSK_TRANSFORM_NODE, gsk_transform_node_get_child},
-      {GSK_OPACITY_NODE, gsk_opacity_node_get_child},
-      {GSK_COLOR_MATRIX_NODE, gsk_color_matrix_node_get_child},
-      {GSK_REPEAT_NODE, gsk_repeat_node_get_child},
-      {GSK_CLIP_NODE, gsk_clip_node_get_child},
-      {GSK_ROUNDED_CLIP_NODE, gsk_rounded_clip_node_get_child},
-      {GSK_SHADOW_NODE, gsk_shadow_node_get_child},
-      {GSK_BLUR_NODE, gsk_blur_node_get_child},
-      {GSK_DEBUG_NODE, gsk_debug_node_get_child},
-  };
-  struct {
-    GskRenderNodeType node_type;
-    guint (*get_n_children)(GskRenderNode*);
-    GskRenderNode* (*get_child)(GskRenderNode*, guint);
-  } constexpr container_getters[] = {
-      {GSK_CONTAINER_NODE, gsk_container_node_get_n_children,
-       gsk_container_node_get_child},
-      {GSK_GL_SHADER_NODE, gsk_gl_shader_node_get_n_children,
-       gsk_gl_shader_node_get_child},
-  };
-
-  if (!node)
-    return nullptr;
-
-  auto node_type = gsk_render_node_get_node_type(node);
-  if (node_type == GSK_TEXTURE_NODE)
-    return gsk_texture_node_get_texture(node);
-  for (const auto& getter : simple_getters) {
-    if (node_type == getter.node_type) {
-      if (auto* texture = GetTextureFromRenderNode(getter.get_child(node)))
-        return texture;
-    }
-  }
-  for (const auto& getter : container_getters) {
-    if (node_type != getter.node_type)
-      continue;
-    for (guint i = 0; i < getter.get_n_children(node); ++i) {
-      if (auto* texture = GetTextureFromRenderNode(getter.get_child(node, i)))
-        return texture;
-    }
-    return nullptr;
-  }
-  return nullptr;
-}
-
-// TODO(tluk): Refactor this to make better use of the hierarchical nature of
-// ColorPipeline.
-absl::optional<SkColor> SkColorFromColorId(ui::ColorId color_id) {
-  switch (color_id) {
-    case ui::kColorWindowBackground:
-    case ui::kColorDialogBackground:
-    case ui::kColorBubbleBackground:
-    case ui::kColorNotificationBackgroundInactive:
-      return GetBgColor("");
-    case ui::kColorDialogForeground:
-      return GetFgColor("GtkLabel#label");
-    case ui::kColorBubbleFooterBackground:
-    case ui::kColorSyncInfoBackground:
-      return GetBgColor("#statusbar");
-    case ui::kColorNotificationActionsBackground:
-    case ui::kColorNotificationBackgroundActive:
-    case ui::kColorNotificationImageBackground:
-      return color_utils::BlendTowardMaxContrast(GetBgColor(""),
-                                                 gfx::kGoogleGreyAlpha100);
-
-    // FocusableBorder
-    case ui::kColorFocusableBorderFocused:
-      // GetBorderColor("GtkEntry#entry:focus") is correct here.  The focus ring
-      // around widgets is usually a lighter version of the "canonical theme
-      // color" - orange on Ambiance, blue on Adwaita, etc.  However, Chrome
-      // lightens the color we give it, so it would look wrong if we give it an
-      // already-lightened color.  This workaround returns the theme color
-      // directly, taken from a selected table row.  This has matched the theme
-      // color on every theme that I've tested.
-      return GetBgColor(
-          "GtkTreeView#treeview.view "
-          "GtkTreeView#treeview.view.cell:selected:focus");
-    case ui::kColorFocusableBorderUnfocused:
-      return GetBorderColor("GtkEntry#entry");
-
-    // Menu
-    case ui::kColorMenuBackground:
-    case ui::kColorMenuItemBackgroundHighlighted:
-    case ui::kColorMenuItemBackgroundAlertedInitial:
-    case ui::kColorMenuItemBackgroundAlertedTarget:
-    case ui::kColorSubtleEmphasisBackground:
-      return GetBgColor(GtkCssMenu());
-    case ui::kColorMenuBorder:
-      return GetBorderColor(GtkCssMenu());
-    case ui::kColorMenuItemBackgroundSelected:
-      return GetBgColor(
-          StrCat({GtkCssMenu(), " ", GtkCssMenuItem(), ":hover"}));
-    case ui::kColorMenuItemForeground:
-    case ui::kColorMenuDropmarker:
-    case ui::kColorMenuItemForegroundHighlighted:
-      return GetFgColor(
-          StrCat({GtkCssMenu(), " ", GtkCssMenuItem(), " GtkLabel#label"}));
-    case ui::kColorMenuItemForegroundSelected:
-      return GetFgColor(StrCat(
-          {GtkCssMenu(), " ", GtkCssMenuItem(), ":hover GtkLabel#label"}));
-    case ui::kColorMenuItemForegroundDisabled:
-      return GetFgColor(StrCat(
-          {GtkCssMenu(), " ", GtkCssMenuItem(), ":disabled GtkLabel#label"}));
-    case ui::kColorMenuItemForegroundSecondary:
-      if (GtkCheckVersion(3, 20)) {
-        return GetFgColor(
-            StrCat({GtkCssMenu(), " ", GtkCssMenuItem(), " #accelerator"}));
-      }
-      return GetFgColor(StrCat({GtkCssMenu(), " ", GtkCssMenuItem(),
-                                " GtkLabel#label.accelerator"}));
-    case ui::kColorMenuSeparator:
-      if (GtkCheckVersion(3, 20)) {
-        return GetSeparatorColor(
-            StrCat({GtkCssMenu(), " GtkSeparator#separator.horizontal"}));
-      }
-      return GetFgColor(
-          StrCat({GtkCssMenu(), " ", GtkCssMenuItem(), ".separator"}));
-
-    // Dropdown
-    case ui::kColorDropdownBackground:
-      return GetBgColor(
-          StrCat({"GtkComboBoxText#combobox GtkWindow#window.background.popup ",
-                  "GtkTreeMenu#menu(gtk-combobox-popup-menu) ",
-                  GtkCssMenuItem(), " ", "GtkCellView#cellview"}));
-    case ui::kColorDropdownForeground:
-      return GetFgColor(
-          StrCat({"GtkComboBoxText#combobox GtkWindow#window.background.popup ",
-                  "GtkTreeMenu#menu(gtk-combobox-popup-menu) ",
-                  GtkCssMenuItem(), " ", "GtkCellView#cellview"}));
-    case ui::kColorDropdownBackgroundSelected:
-      return GetBgColor(
-          StrCat({"GtkComboBoxText#combobox GtkWindow#window.background.popup ",
-                  "GtkTreeMenu#menu(gtk-combobox-popup-menu) ",
-                  GtkCssMenuItem(), ":hover GtkCellView#cellview"}));
-    case ui::kColorDropdownForegroundSelected:
-      return GetFgColor(
-          StrCat({"GtkComboBoxText#combobox GtkWindow#window.background.popup ",
-                  "GtkTreeMenu#menu(gtk-combobox-popup-menu) ",
-                  GtkCssMenuItem(), ":hover GtkCellView#cellview"}));
-
-    // Label
-    case ui::kColorLabelForeground:
-    case ui::kColorPrimaryForeground:
-      return GetFgColor("GtkLabel#label");
-    case ui::kColorLabelForegroundDisabled:
-    case ui::kColorLabelForegroundSecondary:
-    case ui::kColorDisabledForeground:
-    case ui::kColorSecondaryForeground:
-      return GetFgColor("GtkLabel#label:disabled");
-    case ui::kColorLabelSelectionForeground:
-      return GetFgColor(GtkCheckVersion(3, 20) ? "GtkLabel#label #selection"
-                                               : "GtkLabel#label:selected");
-    case ui::kColorLabelSelectionBackground:
-      return GetSelectionBgColor(GtkCheckVersion(3, 20)
-                                     ? "GtkLabel#label #selection"
-                                     : "GtkLabel#label:selected");
-
-    // Link
-    case ui::kColorLinkForegroundDisabled:
-      if (GtkCheckVersion(3, 12))
-        return GetFgColor("GtkLabel#label.link:link:disabled");
-      FALLTHROUGH;
-    case ui::kColorLinkForegroundPressed:
-      if (GtkCheckVersion(3, 12))
-        return GetFgColor("GtkLabel#label.link:link:hover:active");
-      FALLTHROUGH;
-    case ui::kColorLinkForeground: {
-      if (GtkCheckVersion(3, 12))
-        return GetFgColor("GtkLabel#label.link:link");
-      auto link_context = GetStyleContextFromCss("GtkLabel#label.view");
-      GdkColor* color = nullptr;
-      GtkStyleContextGetStyle(link_context, "link-color", &color, nullptr);
-      if (color) {
-        SkColor ret_color =
-            SkColorSetRGB(color->red >> 8, color->green >> 8, color->blue >> 8);
-        // gdk_color_free() was deprecated in Gtk3.14.  This code path is only
-        // taken on versions earlier than Gtk3.12, but the compiler doesn't
-        // know that, so silence the deprecation warnings.
-        G_GNUC_BEGIN_IGNORE_DEPRECATIONS;
-        gdk_color_free(color);
-        G_GNUC_END_IGNORE_DEPRECATIONS;
-        return ret_color;
-      }
-      // Default color comes from gtklinkbutton.c.
-      return SkColorSetRGB(0x00, 0x00, 0xEE);
-    }
-
-    // Scrollbar
-    case ui::kColorOverlayScrollbarStroke:
-      return GetBgColor("#GtkScrollbar#scrollbar #trough");
-    case ui::kColorOverlayScrollbarStrokeHovered:
-      return GetBgColor("#GtkScrollbar#scrollbar #trough:hover");
-    case ui::kColorOverlayScrollbarFill:
-      return GetBgColor("#GtkScrollbar#scrollbar #slider");
-    case ui::kColorOverlayScrollbarFillHovered:
-      return GetBgColor("#GtkScrollbar#scrollbar #slider:hover");
-
-    // Slider
-    case ui::kColorSliderThumb:
-      return GetBgColor("GtkScale#scale #highlight");
-    case ui::kColorSliderTrack:
-      return GetBgColor("GtkScale#scale #trough");
-    case ui::kColorSliderThumbMinimal:
-      return GetBgColor("GtkScale#scale:disabled #highlight");
-    case ui::kColorSliderTrackMinimal:
-      return GetBgColor("GtkScale#scale:disabled #trough");
-
-    // Separator
-    case ui::kColorMidground:
-    case ui::kColorSeparator:
-      return GetSeparatorColor("GtkSeparator#separator.horizontal");
-
-    // Button
-    case ui::kColorButtonBackground:
-      return GetBgColor("GtkButton#button");
-    case ui::kColorButtonForeground:
-    case ui::kColorButtonForegroundUnchecked:
-      return GetFgColor("GtkButton#button.text-button GtkLabel#label");
-    case ui::kColorButtonForegroundDisabled:
-      return GetFgColor("GtkButton#button.text-button:disabled GtkLabel#label");
-    // TODO(thomasanderson): Add this once this CL lands:
-    // https://chromium-review.googlesource.com/c/chromium/src/+/2053144
-    // case ui::kColorId_ButtonHoverColor:
-    //   return GetBgColor("GtkButton#button:hover");
-
-    // ProminentButton
-    case ui::kColorAccent:
-    case ui::kColorButtonForegroundChecked:
-    case ui::kColorButtonBackgroundProminent:
-    case ui::kColorButtonBackgroundProminentFocused:
-    case ui::kColorNotificationInputBackground:
-      return GetBgColor(
-          "GtkTreeView#treeview.view "
-          "GtkTreeView#treeview.view.cell:selected:focus");
-    case ui::kColorButtonForegroundProminent:
-    case ui::kColorNotificationInputForeground:
-      return GetFgColor(
-          "GtkTreeView#treeview.view "
-          "GtkTreeView#treeview.view.cell:selected:focus GtkLabel#label");
-    case ui::kColorButtonBackgroundProminentDisabled:
-    case ui::kColorButtonBorderDisabled:
-      return GetBgColor("GtkButton#button.text-button:disabled");
-    case ui::kColorButtonBorder:
-      return GetBorderColor("GtkButton#button.text-button");
-    // TODO(thomasanderson): Add this once this CL lands:
-    // https://chromium-review.googlesource.com/c/chromium/src/+/2053144
-    // case ui::kColorId_ProminentButtonHoverColor:
-    //   return GetBgColor(
-    //       "GtkTreeView#treeview.view "
-    //       "GtkTreeView#treeview.view.cell:selected:focus:hover");
-
-    // ToggleButton
-    case ui::kColorToggleButtonTrackOff:
-      return GetBgColor("GtkButton#button.text-button.toggle");
-    case ui::kColorToggleButtonTrackOn:
-      return GetBgColor("GtkButton#button.text-button.toggle:checked");
-
-    // TabbedPane
-    case ui::kColorTabForegroundSelected:
-      return GetFgColor("GtkLabel#label");
-    case ui::kColorTabForeground:
-      return GetFgColor("GtkLabel#label:disabled");
-    case ui::kColorTabContentSeparator:
-      return GetBorderColor(GtkCheckVersion(3, 20) ? "GtkFrame#frame #border"
-                                                   : "GtkFrame#frame");
-    case ui::kColorTabBackgroundHighlighted:
-      return GetBgColor("GtkNotebook#notebook #tab:checked");
-    case ui::kColorTabBackgroundHighlightedFocused:
-      return GetBgColor("GtkNotebook#notebook:focus #tab:checked");
-
-    // Textfield
-    case ui::kColorTextfieldForeground:
-      return GetFgColor(GtkCheckVersion(3, 20)
-                            ? "GtkTextView#textview.view #text"
-                            : "GtkTextView.view");
-    case ui::kColorTextfieldBackground:
-      return GetBgColor(GtkCheckVersion(3, 20) ? "GtkTextView#textview.view"
-                                               : "GtkTextView.view");
-    case ui::kColorTextfieldForegroundPlaceholder:
-      if (!GtkCheckVersion(4)) {
-        auto context = GetStyleContextFromCss("GtkEntry#entry");
-        // This is copied from gtkentry.c.  GTK uses a fallback of 50% gray
-        // when the theme doesn't provide a placeholder color, so we choose a
-        // fallback color where each component is 127.
-        return GtkStyleContextLookupColor(context, "placeholder_text_color")
-            .value_or(SkColorSetRGB(127, 127, 127));
-      }
-      return GetFgColor("GtkEntry#entry #text #placeholder");
-    case ui::kColorTextfieldForegroundDisabled:
-      return GetFgColor(GtkCheckVersion(3, 20)
-                            ? "GtkTextView#textview.view:disabled #text"
-                            : "GtkTextView.view:disabled");
-    case ui::kColorTextfieldBackgroundDisabled:
-      return GetBgColor(GtkCheckVersion(3, 20)
-                            ? "GtkTextView#textview.view:disabled"
-                            : "GtkTextView.view:disabled");
-    case ui::kColorTextfieldSelectionForeground:
-      return GetFgColor(GtkCheckVersion(3, 20)
-                            ? "GtkTextView#textview.view #text #selection"
-                            : "GtkTextView.view:selected");
-    case ui::kColorTextfieldSelectionBackground:
-      return GetSelectionBgColor(
-          GtkCheckVersion(3, 20) ? "GtkTextView#textview.view #text #selection"
-                                 : "GtkTextView.view:selected");
-
-    // Tooltips
-    case ui::kColorTooltipBackground:
-      return GetBgColorFromStyleContext(GetTooltipContext());
-    case ui::kColorHelpIconInactive:
-      return GetFgColor("GtkButton#button.image-button");
-    case ui::kColorHelpIconActive:
-      return GetFgColor("GtkButton#button.image-button:hover");
-    case ui::kColorTooltipForeground: {
-      auto context = GetTooltipContext();
-      context = AppendCssNodeToStyleContext(context, "GtkLabel#label");
-      return GtkStyleContextGetColor(context);
-    }
-
-    // Trees and Tables (implemented on GTK using the same class)
-    case ui::kColorTableBackground:
-    case ui::kColorTableBackgroundAlternate:
-    case ui::kColorTreeBackground:
-      return GetBgColor(
-          "GtkTreeView#treeview.view GtkTreeView#treeview.view.cell");
-    case ui::kColorTableForeground:
-    case ui::kColorTreeNodeForeground:
-    case ui::kColorTableGroupingIndicator:
-      return GetFgColor(
-          "GtkTreeView#treeview.view GtkTreeView#treeview.view.cell "
-          "GtkLabel#label");
-    case ui::kColorTableForegroundSelectedFocused:
-    case ui::kColorTableForegroundSelectedUnfocused:
-    case ui::kColorTreeNodeForegroundSelectedFocused:
-    case ui::kColorTreeNodeForegroundSelectedUnfocused:
-      return GetFgColor(
-          "GtkTreeView#treeview.view "
-          "GtkTreeView#treeview.view.cell:selected:focus GtkLabel#label");
-    case ui::kColorTableBackgroundSelectedFocused:
-    case ui::kColorTableBackgroundSelectedUnfocused:
-    case ui::kColorTreeNodeBackgroundSelectedFocused:
-    case ui::kColorTreeNodeBackgroundSelectedUnfocused:
-      return GetBgColor(
-          "GtkTreeView#treeview.view "
-          "GtkTreeView#treeview.view.cell:selected:focus");
-
-    // Table Header
-    case ui::kColorTableHeaderForeground:
-      return GetFgColor(
-          "GtkTreeView#treeview.view GtkButton#button GtkLabel#label");
-    case ui::kColorTableHeaderBackground:
-      return GetBgColor("GtkTreeView#treeview.view GtkButton#button");
-    case ui::kColorTableHeaderSeparator:
-      return GetBorderColor("GtkTreeView#treeview.view GtkButton#button");
-
-    // Throbber
-    // TODO(thomasanderson): Render GtkSpinner directly.
-    case ui::kColorThrobber:
-      return GetFgColor("GtkSpinner#spinner");
-    case ui::kColorThrobberPreconnect:
-      return GetFgColor("GtkSpinner#spinner:disabled");
-
-      // Guest and Incognito Avatar
-    case ui::kColorAvatarIconIncognito:
-      return GetFgColor("GtkLabel#label");
-    case ui::kColorAvatarIconGuest:
-      return color_utils::DeriveDefaultIconColor(GetFgColor("GtkLabel#label"));
-    case ui::kColorAvatarHeaderArt:
-      return color_utils::AlphaBlend(GetFgColor("GtkLabel#label"),
-                                     GetBgColor(""), gfx::kGoogleGreyAlpha300);
-
-    // Alert icons
-    // Fallback to the same colors as Aura.
-    case ui::kColorAlertLowSeverity:
-    case ui::kColorAlertMediumSeverity:
-    case ui::kColorAlertHighSeverity: {
-      // Alert icons appear on the toolbar, so use the toolbar BG
-      // color (the GTK window bg color) to determine if the dark
-      // or light native theme should be used for the icons.
-      return ui::GetAlertSeverityColor(color_id,
-                                       color_utils::IsDark(GetBgColor("")));
-    }
-
-    case ui::kColorMenuIcon:
-      if (GtkCheckVersion(3, 20))
-        return GetFgColor(
-            StrCat({GtkCssMenu(), " ", GtkCssMenuItem(), " #radio"}));
-      return GetFgColor(
-          StrCat({GtkCssMenu(), " ", GtkCssMenuItem(), ".radio"}));
-
-    case ui::kColorIcon:
-      return GetFgColor("GtkButton#button.flat.scale GtkImage#image");
-
-    default:
-      break;
-  }
-  return absl::nullopt;
-}
-
 }  // namespace gtk
diff --git a/ui/gtk/gtk_util.h b/ui/gtk/gtk_util.h
index 6be49077607de..870a0e713a632 100644
--- a/ui/gtk/gtk_util.h
+++ b/ui/gtk/gtk_util.h
@@ -29,10 +29,6 @@ class KeyEvent;
 
 namespace gtk {
 
-const char* GtkCssMenu();
-const char* GtkCssMenuItem();
-const char* GtkCssMenuScrollbar();
-
 void GtkInitFromCommandLine(const base::CommandLine& command_line);
 
 // Sets |dialog| as transient for |parent|, which will keep it on top and center
@@ -53,150 +49,6 @@ void ParseButtonLayout(const std::string& button_string,
                        std::vector<views::FrameButton>* leading_buttons,
                        std::vector<views::FrameButton>* trailing_buttons);
 
-class CairoSurface {
- public:
-  // Attaches a cairo surface to an SkBitmap so that GTK can render
-  // into it.  |bitmap| must outlive this CairoSurface.
-  explicit CairoSurface(SkBitmap& bitmap);
-
-  // Creates a new cairo surface with the given size.  The memory for
-  // this surface is deallocated when this CairoSurface is destroyed.
-  explicit CairoSurface(const gfx::Size& size);
-
-  ~CairoSurface();
-
-  // Get the drawing context for GTK to use.
-  cairo_t* cairo() { return cairo_; }
-
-  // Returns the average of all pixels in the surface.  If |frame| is
-  // true, the resulting alpha will be the average alpha, otherwise it
-  // will be the max alpha across all pixels.
-  SkColor GetAveragePixelValue(bool frame);
-
- private:
-  cairo_surface_t* surface_;
-  cairo_t* cairo_;
-};
-
-class GtkCssContext {
- public:
-  GtkCssContext();
-  GtkCssContext(const GtkCssContext&);
-  GtkCssContext(GtkCssContext&&);
-  GtkCssContext& operator=(const GtkCssContext&);
-  GtkCssContext& operator=(GtkCssContext&&);
-  ~GtkCssContext();
-
-  // GTK3 constructor.
-  explicit GtkCssContext(GtkStyleContext* context);
-
-  // GTK4 constructor.
-  GtkCssContext(GtkWidget* widget, GtkWidget* root);
-
-  // As a convenience, allow using a GtkCssContext as a gtk_style_context()
-  // to avoid repeated use of an explicit getter.
-  // NOLINTNEXTLINE(google-explicit-constructor)
-  operator GtkStyleContext*();
-
-  GtkCssContext GetParent();
-
-  // Only available on GTK4.
-  GtkWidget* widget();
-  GtkWidget* root();
-
- private:
-  // GTK3 state.
-  ScopedGObject<GtkStyleContext> context_;
-
-  // GTK4 state.
-  // GTK widgets own their children, so instead of keeping a reference to the
-  // widget directly, keep a reference to the root widget.
-  GtkWidget* widget_ = nullptr;
-  ScopedGObject<GtkWidget> root_;
-};
-
-using ScopedCssProvider = ScopedGObject<GtkCssProvider>;
-
-}  // namespace gtk
-
-// Template override cannot be in the gtk namespace.
-template <>
-inline void ScopedGObject<GtkStyleContext>::Unref() {
-  // Versions of GTK earlier than 3.15.4 had a bug where a g_assert
-  // would be triggered when trying to free a GtkStyleContext that had
-  // a parent whose only reference was the child context in question.
-  // This is a hack to work around that case.  See GTK commit
-  // "gtkstylecontext: Don't try to emit a signal when finalizing".
-  GtkStyleContext* context = obj_;
-  while (context) {
-    GtkStyleContext* parent = gtk_style_context_get_parent(context);
-    if (parent && G_OBJECT(context)->ref_count == 1 &&
-        !gtk::GtkCheckVersion(3, 15, 4)) {
-      g_object_ref(parent);
-      gtk_style_context_set_parent(context, nullptr);
-      g_object_unref(context);
-    } else {
-      g_object_unref(context);
-      return;
-    }
-    context = parent;
-  }
-}
-
-namespace gtk {
-
-// Converts ui::NativeTheme::State to GtkStateFlags.
-GtkStateFlags StateToStateFlags(ui::NativeTheme::State state);
-
-// If |context| is nullptr, creates a new top-level style context
-// specified by parsing |css_node|.  Otherwise, creates the child
-// context with |context| as the parent.
-GtkCssContext AppendCssNodeToStyleContext(GtkCssContext context,
-                                          const std::string& css_node);
-
-// Parses |css_selector| into a StyleContext.  The format is a
-// sequence of whitespace-separated objects.  Each object may have at
-// most one object name at the beginning of the string, and any number
-// of '.'-prefixed classes and ':'-prefixed pseudoclasses.  An example
-// is "GtkButton.button.suggested-action:hover:active".  The caller
-// must g_object_unref() the returned context.
-GtkCssContext GetStyleContextFromCss(const std::string& css_selector);
-
-SkColor GetBgColorFromStyleContext(GtkCssContext context);
-
-// Overrides properties on |context| and all its parents with those
-// provided by |css|.
-void ApplyCssToContext(GtkCssContext context, const std::string& css);
-
-// Get the 'color' property from the style context created by
-// GetStyleContextFromCss(|css_selector|).
-SkColor GetFgColor(const std::string& css_selector);
-
-ScopedCssProvider GetCssProvider(const std::string& css);
-
-// Renders the backgrounds of all ancestors of |context|, then renders
-// the background for |context| itself.
-void RenderBackground(const gfx::Size& size,
-                      cairo_t* cr,
-                      GtkCssContext context);
-
-// Renders a background from the style context created by
-// GetStyleContextFromCss(|css_selector|) into a 24x24 bitmap and
-// returns the average color.
-SkColor GetBgColor(const std::string& css_selector);
-
-// Renders the border from the style context created by
-// GetStyleContextFromCss(|css_selector|) into a 24x24 bitmap and
-// returns the average color.
-SkColor GetBorderColor(const std::string& css_selector);
-
-// On Gtk3.20 or later, behaves like GetBgColor.  Otherwise, returns
-// the background-color property.
-SkColor GetSelectionBgColor(const std::string& css_selector);
-
-// Get the color of the GtkSeparator specified by |css_selector|.
-SkColor GetSeparatorColor(const std::string& css_selector);
-
 // Get a GtkSettings property as a C++ string.
 std::string GetGtkSettingsStringProperty(GtkSettings* settings,
                                          const gchar* prop_name);
@@ -230,16 +82,8 @@ void GtkWindowDestroy(GtkWidget* widget);
 
 GtkWidget* GetDummyWindow();
 
-gfx::Size GetSeparatorSize(bool horizontal);
-
 float GetDeviceScaleFactor();
 
-// This should only be called on Gtk4.
-GdkTexture* GetTextureFromRenderNode(GskRenderNode* node);
-
-// Gets the GTK theme color for a given `color_id`.
-absl::optional<SkColor> SkColorFromColorId(ui::ColorId color_id);
-
 }  // namespace gtk
 
 #endif  // UI_GTK_GTK_UTIL_H_
diff --git a/ui/gtk/input_method_context_impl_gtk.cc b/ui/gtk/input_method_context_impl_gtk.cc
index 56c1060d0a511..33d19d2424bdc 100644
--- a/ui/gtk/input_method_context_impl_gtk.cc
+++ b/ui/gtk/input_method_context_impl_gtk.cc
@@ -83,9 +83,6 @@ InputMethodContextImplGtk::InputMethodContextImplGtk(
   // TODO(shuchen): Handle operations on surrounding text.
   // "delete-surrounding" and "retrieve-surrounding" signals should be
   // handled.
-
-  if (GtkCheckVersion(4))
-    gtk_im_context_set_client_widget(gtk_context_, GetDummyWindow());
 }
 
 InputMethodContextImplGtk::~InputMethodContextImplGtk() {
@@ -128,33 +125,15 @@ bool InputMethodContextImplGtk::DispatchKeyEvent(
   // --force-device-scale-factor is used.
   caret_bounds = ScaleToRoundedRect(
       caret_bounds,
-      GetDeviceScaleFactor() / gtk_widget_get_scale_factor(GetDummyWindow()));
+      GetDeviceScaleFactor() / 1/*gtk_widget_get_scale_factor(GetDummyWindow())*/); // fuck HiDPI
   GdkRectangle gdk_rect = {caret_bounds.x(), caret_bounds.y(),
                            caret_bounds.width(), caret_bounds.height()};
   gtk_im_context_set_cursor_location(gtk_context_, &gdk_rect);
 
-  if (!GtkCheckVersion(4)) {
-    const bool handled =
-        GtkImContextFilterKeypress(gtk_context_, GdkEventToKey(event));
-    gdk_event_free(event);
-    return handled;
-  }
-  // In GTK4, clients can no longer create or modify events.  This makes using
-  // the gtk_im_context_filter_keypress() API impossible.  Fortunately, an
-  // alternative API called gtk_im_context_filter_key() was added for clients
-  // that would have needed to construct their own event.  The parameters to
-  // the new API are just a deconstructed version of a KeyEvent.
-  bool press = key_event.type() == ui::ET_KEY_PRESSED;
-  auto* surface =
-      gtk_native_get_surface(gtk_widget_get_native(GetDummyWindow()));
-  auto* device = gdk_seat_get_keyboard(
-      gdk_display_get_default_seat(gdk_display_get_default()));
-  auto time = (key_event.time_stamp() - base::TimeTicks()).InMilliseconds();
-  auto keycode = GetKeyEventProperty(key_event, ui::kPropertyKeyboardHwKeyCode);
-  auto state = GetGdkKeyEventState(key_event);
-  auto group = GetKeyEventProperty(key_event, ui::kPropertyKeyboardGroup);
-  return gtk_im_context_filter_key(gtk_context_, press, surface, device, time,
-                                   keycode, state, group);
+  const bool handled =
+      GtkImContextFilterKeypress(gtk_context_, GdkEventToKey(event));
+  gdk_event_free(event);
+  return handled;
 }
 
 bool InputMethodContextImplGtk::IsPeekKeyEvent(const ui::KeyEvent& key_event) {
diff --git a/ui/gtk/input_method_context_impl_gtk.h b/ui/gtk/input_method_context_impl_gtk.h
index 519820a69fa99..4c207d590c2e3 100644
--- a/ui/gtk/input_method_context_impl_gtk.h
+++ b/ui/gtk/input_method_context_impl_gtk.h
@@ -14,7 +14,7 @@
 #include "ui/gfx/geometry/rect.h"
 
 using GtkIMContext = struct _GtkIMContext;
-using GdkWindow = struct _GdkWindow;
+using GdkWindow = struct _GdkDrawable;
 
 namespace gtk {
 
diff --git a/ui/gtk/native_theme_gtk.cc b/ui/gtk/native_theme_gtk.cc
index 3d896fd9656e3..434cb55a144a8 100644
--- a/ui/gtk/native_theme_gtk.cc
+++ b/ui/gtk/native_theme_gtk.cc
@@ -6,9 +6,16 @@
 
 #include "base/strings/strcat.h"
 #include "ui/color/color_provider_manager.h"
+#include "ui/gtk/chrome_gtk_frame.h"
+#include "ui/gtk/chrome_gtk_menu_subclasses.h"
+#include "ui/gtk/gtk_ui.h"
+#include "ui/gtk/gtk_util.h"
+#include "ui/gtk/skia_utils_gtk.h"
+#include "third_party/skia/include/core/SkColor.h"
 #include "ui/gfx/color_palette.h"
 #include "ui/gfx/color_utils.h"
 #include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/geometry/size.h"
 #include "ui/gfx/skia_util.h"
 #include "ui/gtk/gtk_color_mixers.h"
 #include "ui/gtk/gtk_compat.h"
@@ -23,48 +30,36 @@ namespace gtk {
 
 namespace {
 
-enum BackgroundRenderMode {
-  BG_RENDER_NORMAL,
-  BG_RENDER_NONE,
-  BG_RENDER_RECURSIVE,
+enum WidgetState {
+  NORMAL = 0,
+  ACTIVE = 1,
+  PRELIGHT = 2,
+  SELECTED = 3,
+  INSENSITIVE = 4,
 };
 
-SkBitmap GetWidgetBitmap(const gfx::Size& size,
-                         GtkCssContext context,
-                         BackgroundRenderMode bg_mode,
-                         bool render_frame) {
-  DCHECK(bg_mode != BG_RENDER_NONE || render_frame);
-  SkBitmap bitmap;
-  bitmap.allocN32Pixels(size.width(), size.height());
-  bitmap.eraseColor(0);
-
-  CairoSurface surface(bitmap);
-  cairo_t* cr = surface.cairo();
+// Same order as enum WidgetState above
+const GtkStateType stateMap[] = {
+    GTK_STATE_NORMAL,   GTK_STATE_ACTIVE,      GTK_STATE_PRELIGHT,
+    GTK_STATE_SELECTED, GTK_STATE_INSENSITIVE,
+};
 
-  switch (bg_mode) {
-    case BG_RENDER_NORMAL:
-      gtk_render_background(context, cr, 0, 0, size.width(), size.height());
-      break;
-    case BG_RENDER_RECURSIVE:
-      RenderBackground(size, cr, context);
-      break;
-    case BG_RENDER_NONE:
-      break;
-  }
-  if (render_frame)
-    gtk_render_frame(context, cr, 0, 0, size.width(), size.height());
-  bitmap.setImmutable();
-  return bitmap;
+SkColor GetFgColor(GtkWidget* widget, WidgetState state) {
+  return GdkColorToSkColor(gtk_rc_get_style(widget)->fg[stateMap[state]]);
+}
+SkColor GetBgColor(GtkWidget* widget, WidgetState state) {
+  return GdkColorToSkColor(gtk_rc_get_style(widget)->bg[stateMap[state]]);
 }
 
-void PaintWidget(cc::PaintCanvas* canvas,
-                 const gfx::Rect& rect,
-                 GtkCssContext context,
-                 BackgroundRenderMode bg_mode,
-                 bool render_frame) {
-  canvas->drawImage(cc::PaintImage::CreateFromBitmap(GetWidgetBitmap(
-                        rect.size(), context, bg_mode, render_frame)),
-                    rect.x(), rect.y());
+
+SkColor GetTextColor(GtkWidget* widget, WidgetState state) {
+  return GdkColorToSkColor(gtk_rc_get_style(widget)->text[stateMap[state]]);
+}
+SkColor GetTextAAColor(GtkWidget* widget, WidgetState state) {
+  return GdkColorToSkColor(gtk_rc_get_style(widget)->text_aa[stateMap[state]]);
+}
+SkColor GetBaseColor(GtkWidget* widget, WidgetState state) {
+  return GdkColorToSkColor(gtk_rc_get_style(widget)->base[stateMap[state]]);
 }
 
 }  // namespace
@@ -75,78 +70,10 @@ NativeThemeGtk* NativeThemeGtk::instance() {
   return s_native_theme.get();
 }
 
-NativeThemeGtk::NativeThemeGtk() {
-  // g_type_from_name() is only used in GTK3.
-  if (!GtkCheckVersion(4)) {
-    // These types are needed by g_type_from_name(), but may not be registered
-    // at this point.  We need the g_type_class magic to make sure the compiler
-    // doesn't optimize away this code.
-    g_type_class_unref(g_type_class_ref(gtk_button_get_type()));
-    g_type_class_unref(g_type_class_ref(gtk_entry_get_type()));
-    g_type_class_unref(g_type_class_ref(gtk_frame_get_type()));
-    g_type_class_unref(g_type_class_ref(gtk_header_bar_get_type()));
-    g_type_class_unref(g_type_class_ref(gtk_image_get_type()));
-    g_type_class_unref(g_type_class_ref(gtk_info_bar_get_type()));
-    g_type_class_unref(g_type_class_ref(gtk_label_get_type()));
-    g_type_class_unref(g_type_class_ref(gtk_menu_get_type()));
-    g_type_class_unref(g_type_class_ref(gtk_menu_bar_get_type()));
-    g_type_class_unref(g_type_class_ref(gtk_menu_item_get_type()));
-    g_type_class_unref(g_type_class_ref(gtk_range_get_type()));
-    g_type_class_unref(g_type_class_ref(gtk_scrollbar_get_type()));
-    g_type_class_unref(g_type_class_ref(gtk_scrolled_window_get_type()));
-    g_type_class_unref(g_type_class_ref(gtk_separator_get_type()));
-    g_type_class_unref(g_type_class_ref(gtk_spinner_get_type()));
-    g_type_class_unref(g_type_class_ref(gtk_text_view_get_type()));
-    g_type_class_unref(g_type_class_ref(gtk_toggle_button_get_type()));
-    g_type_class_unref(g_type_class_ref(gtk_tree_view_get_type()));
-    g_type_class_unref(g_type_class_ref(gtk_window_get_type()));
-    g_type_class_unref(g_type_class_ref(gtk_combo_box_text_get_type()));
-    g_type_class_unref(g_type_class_ref(gtk_cell_view_get_type()));
-    g_type_class_unref(g_type_class_ref(gtk_scale_get_type()));
-
-    // Initialize the GtkTreeMenu type.  _gtk_tree_menu_get_type() is private,
-    // so we need to initialize it indirectly.
-    auto model = TakeGObject(GTK_TREE_MODEL(GtkTreeStoreNew(G_TYPE_STRING)));
-    auto combo = TakeGObject(gtk_combo_box_new_with_model(model));
-  }
-
-  ui::ColorProviderManager::Get().AppendColorProviderInitializer(
-      base::BindRepeating(AddGtkNativeCoreColorMixer));
-
-  OnThemeChanged(gtk_settings_get_default(), nullptr);
-}
-
-NativeThemeGtk::~NativeThemeGtk() {
-  NOTREACHED();
-}
-
-void NativeThemeGtk::SetThemeCssOverride(ScopedCssProvider provider) {
-  if (theme_css_override_) {
-    if (GtkCheckVersion(4)) {
-      gtk_style_context_remove_provider_for_display(
-          gdk_display_get_default(),
-          GTK_STYLE_PROVIDER(theme_css_override_.get()));
-    } else {
-      gtk_style_context_remove_provider_for_screen(
-          gdk_screen_get_default(),
-          GTK_STYLE_PROVIDER(theme_css_override_.get()));
-    }
-  }
-  theme_css_override_ = std::move(provider);
-  if (theme_css_override_) {
-    if (GtkCheckVersion(4)) {
-      gtk_style_context_add_provider_for_display(
-          gdk_display_get_default(),
-          GTK_STYLE_PROVIDER(theme_css_override_.get()),
-          GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
-    } else {
-      gtk_style_context_add_provider_for_screen(
-          gdk_screen_get_default(),
-          GTK_STYLE_PROVIDER(theme_css_override_.get()),
-          GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
-    }
-  }
-}
+// Constructors automatically called
+NativeThemeGtk::NativeThemeGtk() {}
+// This doesn't actually get called
+NativeThemeGtk::~NativeThemeGtk() {}
 
 void NativeThemeGtk::NotifyOnNativeThemeUpdated() {
   NativeTheme::NotifyOnNativeThemeUpdated();
@@ -161,52 +88,6 @@ void NativeThemeGtk::NotifyOnNativeThemeUpdated() {
   native_theme->NotifyOnNativeThemeUpdated();
 }
 
-void NativeThemeGtk::OnThemeChanged(GtkSettings* settings,
-                                    GtkParamSpec* param) {
-  SetThemeCssOverride(ScopedCssProvider());
-  for (auto& color : color_cache_)
-    color = absl::nullopt;
-
-  // Hack to workaround a bug on GNOME standard themes which would
-  // cause black patches to be rendered on GtkFileChooser dialogs.
-  std::string theme_name =
-      GetGtkSettingsStringProperty(settings, "gtk-theme-name");
-  if (!GtkCheckVersion(3, 14)) {
-    if (theme_name == "Adwaita") {
-      SetThemeCssOverride(GetCssProvider(
-          "GtkFileChooser GtkPaned { background-color: @theme_bg_color; }"));
-    } else if (theme_name == "HighContrast") {
-      SetThemeCssOverride(GetCssProvider(
-          "GtkFileChooser GtkPaned { background-color: @theme_base_color; }"));
-    }
-  }
-
-  // GTK has a dark mode setting called "gtk-application-prefer-dark-theme", but
-  // this is really only used for themes that have a dark or light variant that
-  // gets toggled based on this setting (eg. Adwaita).  Most dark themes do not
-  // have a light variant and aren't affected by the setting.  Because of this,
-  // experimentally check if the theme is dark by checking if the window
-  // background color is dark.
-  set_use_dark_colors(IsForcedDarkMode() || color_utils::IsDark(GetSystemColor(
-                                                kColorId_WindowBackground)));
-  set_preferred_color_scheme(CalculatePreferredColorScheme());
-
-  // GTK doesn't have a native high contrast setting.  Rather, it's implied by
-  // the theme name.  The only high contrast GTK themes that I know of are
-  // HighContrast (GNOME) and ContrastHighInverse (MATE).  So infer the contrast
-  // based on if the theme name contains both "high" and "contrast",
-  // case-insensitive.
-  std::transform(theme_name.begin(), theme_name.end(), theme_name.begin(),
-                 ::tolower);
-  bool high_contrast = theme_name.find("high") != std::string::npos &&
-                       theme_name.find("contrast") != std::string::npos;
-  set_preferred_contrast(
-      high_contrast ? ui::NativeThemeBase::PreferredContrast::kMore
-                    : ui::NativeThemeBase::PreferredContrast::kNoPreference);
-
-  NotifyOnNativeThemeUpdated();
-}
-
 bool NativeThemeGtk::AllowColorPipelineRedirection(
     ColorScheme color_scheme) const {
   return true;
@@ -218,7 +99,7 @@ SkColor NativeThemeGtk::GetSystemColorDeprecated(ColorId color_id,
   absl::optional<SkColor> color = color_cache_[color_id];
   if (!color) {
     if (auto provider_color_id = ui::NativeThemeColorIdToColorId(color_id))
-      color = SkColorFromColorId(provider_color_id.value());
+      color = SkColorFromColorId(provider_color_id.value(), color_scheme);
     if (!color) {
       color = ui::NativeThemeBase::GetSystemColorDeprecated(
           color_id, color_scheme, apply_processing);
@@ -229,94 +110,30 @@ SkColor NativeThemeGtk::GetSystemColorDeprecated(ColorId color_id,
   return color.value();
 }
 
-void NativeThemeGtk::PaintArrowButton(
-    cc::PaintCanvas* canvas,
-    const gfx::Rect& rect,
-    Part direction,
-    State state,
-    ColorScheme color_scheme,
-    const ScrollbarArrowExtraParams& arrow) const {
-  // Add the "flat" styleclass to avoid drawing a border.
-  auto context = GetStyleContextFromCss(
-      GtkCheckVersion(3, 20)
-          ? StrCat({GtkCssMenuScrollbar(), " #range GtkButton#button.flat"})
-          : "GtkRange.scrollbar.button.flat");
-  // Remove any rounded corners since arrow scrollbar buttons are tiny.
-  ApplyCssToContext(context, "* { border-radius: 0px; }");
-  GtkStateFlags state_flags = StateToStateFlags(state);
-  gtk_style_context_set_state(context, state_flags);
-
-  switch (direction) {
-    case kScrollbarUpArrow:
-      gtk_style_context_add_class(context, "top");
-      break;
-    case kScrollbarRightArrow:
-      gtk_style_context_add_class(context, "right");
-      break;
-    case kScrollbarDownArrow:
-      gtk_style_context_add_class(context, "bottom");
-      break;
-    case kScrollbarLeftArrow:
-      gtk_style_context_add_class(context, "left");
-      break;
-    default:
-      NOTREACHED();
-  }
-
-  PaintWidget(canvas, rect, context, BG_RENDER_NORMAL, false);
-  PaintArrow(canvas, rect, direction, GtkStyleContextGetColor(context));
-}
-
-void NativeThemeGtk::PaintScrollbarTrack(
-    cc::PaintCanvas* canvas,
-    Part part,
-    State state,
-    const ScrollbarTrackExtraParams& extra_params,
-    const gfx::Rect& rect,
-    ColorScheme color_scheme) const {
-  PaintWidget(
-      canvas, rect,
-      GetStyleContextFromCss(GtkCheckVersion(3, 20)
-                                 ? StrCat({GtkCssMenuScrollbar(), " #trough"})
-                                 : "GtkScrollbar.scrollbar.trough"),
-      BG_RENDER_NORMAL, true);
-}
-
-void NativeThemeGtk::PaintScrollbarThumb(
-    cc::PaintCanvas* canvas,
-    Part part,
-    State state,
-    const gfx::Rect& rect,
-    NativeTheme::ScrollbarOverlayColorTheme theme,
-    ColorScheme color_scheme) const {
-  auto context = GetStyleContextFromCss(
-      GtkCheckVersion(3, 20)
-          ? StrCat({GtkCssMenuScrollbar(), " #trough #slider"})
-          : "GtkScrollbar.scrollbar.slider");
-  gtk_style_context_set_state(context, StateToStateFlags(state));
-  PaintWidget(canvas, rect, context, BG_RENDER_NORMAL, true);
-}
-
-void NativeThemeGtk::PaintScrollbarCorner(cc::PaintCanvas* canvas,
-                                          State state,
-                                          const gfx::Rect& rect,
-                                          ColorScheme color_scheme) const {
-  auto context = GetStyleContextFromCss(
-      GtkCheckVersion(3, 19, 2)
-          ? "GtkScrolledWindow#scrolledwindow #junction"
-          : "GtkScrolledWindow.scrolledwindow.scrollbars-junction");
-  PaintWidget(canvas, rect, context, BG_RENDER_NORMAL, true);
-}
-
 void NativeThemeGtk::PaintMenuPopupBackground(
     cc::PaintCanvas* canvas,
     const gfx::Size& size,
     const MenuBackgroundExtraParams& menu_background,
     ColorScheme color_scheme) const {
-  auto context = GetStyleContextFromCss(GtkCssMenu());
-  // Chrome menus aren't rendered with transparency, so avoid rounded corners.
-  ApplyCssToContext(context, "* { border-radius: 0px; }");
-  PaintWidget(canvas, gfx::Rect(size), context, BG_RENDER_RECURSIVE, false);
+  if (menu_background.corner_radius > 0) {
+    cc::PaintFlags flags;
+    flags.setStyle(cc::PaintFlags::kFill_Style);
+    flags.setAntiAlias(true);
+    flags.setColor(GetSystemColor(kColorId_MenuBackgroundColor));
+
+    SkPath path;
+    SkRect rect = SkRect::MakeWH(SkIntToScalar(size.width()),
+                                 SkIntToScalar(size.height()));
+    SkScalar radius = SkIntToScalar(menu_background.corner_radius);
+    SkScalar radii[8] = {radius, radius, radius, radius,
+                         radius, radius, radius, radius};
+    path.addRoundRect(rect, radii);
+
+    canvas->drawPath(path, flags);
+  } else {
+    canvas->drawColor(GetSystemColor(kColorId_MenuBackgroundColor),
+                      SkBlendMode::kSrc);
+  }
 }
 
 void NativeThemeGtk::PaintMenuItemBackground(
@@ -325,102 +142,381 @@ void NativeThemeGtk::PaintMenuItemBackground(
     const gfx::Rect& rect,
     const MenuItemExtraParams& menu_item,
     ColorScheme color_scheme) const {
-  auto context =
-      GetStyleContextFromCss(StrCat({GtkCssMenu(), " ", GtkCssMenuItem()}));
-  gtk_style_context_set_state(context, StateToStateFlags(state));
-  PaintWidget(canvas, rect, context, BG_RENDER_NORMAL, true);
-}
-
-void NativeThemeGtk::PaintMenuSeparator(
-    cc::PaintCanvas* canvas,
-    State state,
-    const gfx::Rect& rect,
-    const MenuSeparatorExtraParams& menu_separator,
-    ColorScheme color_scheme) const {
-  // TODO(estade): use GTK to draw vertical separators too. See
-  // crbug.com/710183
-  if (menu_separator.type == ui::VERTICAL_SEPARATOR) {
-    cc::PaintFlags paint;
-    paint.setStyle(cc::PaintFlags::kFill_Style);
-    paint.setColor(GetSystemColor(ui::NativeTheme::kColorId_MenuSeparatorColor,
-                                  color_scheme));
-    canvas->drawRect(gfx::RectToSkRect(rect), paint);
+  SkColor color;
+  cc::PaintFlags flags;
+  switch (state) {
+    case NativeTheme::kNormal:
+    case NativeTheme::kDisabled:
+      color = GetSystemColor(NativeTheme::kColorId_MenuBackgroundColor);
+      flags.setColor(color);
+      break;
+    case NativeTheme::kHovered:
+      color =
+          GetSystemColor(NativeTheme::kColorId_FocusedMenuItemBackgroundColor);
+      flags.setColor(color);
+      break;
+    default:
+      NOTREACHED() << "Invalid state " << state;
+      break;
+  }
+  if (menu_item.corner_radius > 0) {
+    const SkScalar radius = SkIntToScalar(menu_item.corner_radius);
+    canvas->drawRoundRect(gfx::RectToSkRect(rect), radius, radius, flags);
     return;
   }
+  canvas->drawRect(gfx::RectToSkRect(rect), flags);
+}
 
-  auto separator_offset = [&](int separator_thickness) {
-    switch (menu_separator.type) {
-      case ui::LOWER_SEPARATOR:
-        return rect.height() - separator_thickness;
-      case ui::UPPER_SEPARATOR:
-        return 0;
-      default:
-        return (rect.height() - separator_thickness) / 2;
-    }
-  };
-  if (GtkCheckVersion(3, 20)) {
-    auto context = GetStyleContextFromCss(
-        StrCat({GtkCssMenu(), " GtkSeparator#separator.horizontal"}));
-    int min_height = 1;
-    auto margin = GtkStyleContextGetMargin(context);
-    auto border = GtkStyleContextGetBorder(context);
-    auto padding = GtkStyleContextGetPadding(context);
-    if (GtkCheckVersion(4))
-      min_height = GetSeparatorSize(true).height();
-    else
-      GtkStyleContextGet(context, "min-height", &min_height, nullptr);
-    int w = rect.width() - margin.left() - margin.right();
-    int h = std::max(min_height + padding.top() + padding.bottom() +
-                         border.top() + border.bottom(),
-                     1);
-    int x = margin.left();
-    int y = separator_offset(h);
-    PaintWidget(canvas, gfx::Rect(x, y, w, h), context, BG_RENDER_NORMAL, true);
-  } else {
-    auto context = GetStyleContextFromCss(
-        StrCat({GtkCssMenu(), " ", GtkCssMenuItem(), ".separator.horizontal"}));
-    gboolean wide_separators = false;
-    gint separator_height = 0;
-    GtkStyleContextGetStyle(context, "wide-separators", &wide_separators,
-                            "separator-height", &separator_height, nullptr);
-    // This code was adapted from gtk/gtkmenuitem.c.  For some reason,
-    // padding is used as the margin.
-    auto padding = GtkStyleContextGetPadding(context);
-    int w = rect.width() - padding.left() - padding.right();
-    int x = rect.x() + padding.left();
-    int h = wide_separators ? separator_height : 1;
-    int y = rect.y() + separator_offset(h);
-    if (wide_separators) {
-      PaintWidget(canvas, gfx::Rect(x, y, w, h), context, BG_RENDER_NONE, true);
-    } else {
-      cc::PaintFlags flags;
-      flags.setColor(GtkStyleContextGetColor(context));
-      flags.setAntiAlias(true);
-      flags.setStrokeWidth(1);
-      canvas->drawLine(x + 0.5f, y + 0.5f, x + w + 0.5f, y + 0.5f, flags);
-    }
+GtkWidget* NativeThemeGtk::GetWindow() const {
+  static GtkWidget* fake_window = nullptr;
+
+  if (!fake_window) {
+    fake_window = chrome_gtk_frame_new();
+    gtk_widget_realize(fake_window);
+  }
+
+  return fake_window;
+}
+
+GtkWidget* NativeThemeGtk::GetEntry() const {
+  static GtkWidget* fake_entry = nullptr;
+
+  if (!fake_entry) {
+    fake_entry = gtk_entry_new();
+
+    // The fake entry needs to be in the window so it can be realized so we can
+    // use the computed parts of the style.
+    gtk_container_add(GTK_CONTAINER(GetWindow()), fake_entry);
+    gtk_widget_realize(fake_entry);
+  }
+
+  return fake_entry;
+}
+
+GtkWidget* NativeThemeGtk::GetLabel() const {
+  static GtkWidget* fake_label = nullptr;
+
+  if (!fake_label)
+    fake_label = gtk_label_new("");
+
+  return fake_label;
+}
+
+GtkWidget* NativeThemeGtk::GetButton() const {
+  static GtkWidget* fake_button = nullptr;
+
+  if (!fake_button)
+    fake_button = gtk_button_new();
+
+  return fake_button;
+}
+
+GtkWidget* NativeThemeGtk::GetTree() const {
+  static GtkWidget* fake_tree = nullptr;
+
+  if (!fake_tree)
+    fake_tree = gtk_tree_view_new();
+
+  return fake_tree;
+}
+
+GtkWidget* NativeThemeGtk::GetTooltip() const {
+  static GtkWidget* fake_tooltip = nullptr;
+
+  if (!fake_tooltip) {
+    fake_tooltip = gtk_window_new(GTK_WINDOW_TOPLEVEL);
+    gtk_widget_set_name(fake_tooltip, "gtk-tooltip");
+    gtk_widget_realize(fake_tooltip);
+  }
+
+  return fake_tooltip;
+}
+
+GtkWidget* NativeThemeGtk::GetMenu() const {
+  static GtkWidget* fake_menu = nullptr;
+
+  if (!fake_menu)
+    fake_menu = gtk_custom_menu_new();
+
+  return fake_menu;
+}
+
+GtkWidget* NativeThemeGtk::GetMenuItem() const {
+  static GtkWidget* fake_menu_item = nullptr;
+
+  if (!fake_menu_item) {
+    fake_menu_item = gtk_custom_menu_item_new();
+    gtk_menu_shell_append(GTK_MENU_SHELL(GetMenu()), fake_menu_item);
   }
+
+  return fake_menu_item;
 }
 
-void NativeThemeGtk::PaintFrameTopArea(
-    cc::PaintCanvas* canvas,
-    State state,
-    const gfx::Rect& rect,
-    const FrameTopAreaExtraParams& frame_top_area,
-    ColorScheme color_scheme) const {
-  auto context = GetStyleContextFromCss(frame_top_area.use_custom_frame
-                                            ? "#headerbar.header-bar.titlebar"
-                                            : "GtkMenuBar#menubar");
-  ApplyCssToContext(context, "* { border-radius: 0px; border-style: none; }");
-  gtk_style_context_set_state(context, frame_top_area.is_active
-                                           ? GTK_STATE_FLAG_NORMAL
-                                           : GTK_STATE_FLAG_BACKDROP);
-
-  SkBitmap bitmap =
-      GetWidgetBitmap(rect.size(), context, BG_RENDER_RECURSIVE, false);
-  bitmap.setImmutable();
-  canvas->drawImage(cc::PaintImage::CreateFromBitmap(std::move(bitmap)),
-                    rect.x(), rect.y());
+GtkWidget* NativeThemeGtk::GetSeparator() const {
+  static GtkWidget* fake_separator = nullptr;
+
+  if (!fake_separator)
+    fake_separator = gtk_hseparator_new();
+
+  return fake_separator;
+}
+
+// TODO(tluk): Refactor this to make better use of the hierarchical nature of
+// ColorPipeline.
+absl::optional<SkColor>
+NativeThemeGtk::SkColorFromColorId(ui::ColorId color_id, ColorScheme color_scheme) const {
+  switch (color_id) {
+    case ui::kColorWindowBackground:
+      return GetBgColor(GetWindow(), SELECTED);
+    case ui::kColorDialogBackground:
+    case ui::kColorBubbleBackground:
+    case ui::kColorNotificationBackgroundInactive:
+      return GetBgColor(GetWindow(), NORMAL);
+    case ui::kColorDialogForeground:
+      return GetFgColor(GetLabel(), NORMAL);
+    case ui::kColorBubbleFooterBackground:
+    case ui::kColorSyncInfoBackground:
+      return GetBgColor(GetLabel(), NORMAL);
+    case ui::kColorNotificationActionsBackground:
+    case ui::kColorNotificationBackgroundActive:
+    case ui::kColorNotificationImageBackground:
+      return color_utils::BlendTowardMaxContrast(GetBgColor(GetWindow(), NORMAL),
+                                                 gfx::kGoogleGreyAlpha100);
+
+    // FocusableBorder
+    case ui::kColorFocusableBorderFocused:
+      return GetTextColor(GetMenuItem(), SELECTED);
+    case ui::kColorFocusableBorderUnfocused:
+      return GetTextAAColor(GetEntry(), NORMAL);
+
+    // Menu
+    case ui::kColorMenuBackground:
+    case ui::kColorMenuItemBackgroundHighlighted:
+    case ui::kColorMenuItemBackgroundAlertedInitial:
+    case ui::kColorMenuItemBackgroundAlertedTarget:
+    case ui::kColorSubtleEmphasisBackground:
+      return GetBgColor(GetMenuItem(), NORMAL);
+    case ui::kColorMenuBorder:
+      return GetTextColor(GetMenuItem(), INSENSITIVE);
+    case ui::kColorMenuItemBackgroundSelected:
+      return GetBgColor(GetMenuItem(), SELECTED);
+    case ui::kColorMenuItemForeground:
+    case ui::kColorMenuDropmarker:
+    case ui::kColorMenuItemForegroundHighlighted:
+      return GetTextColor(GetMenuItem(), NORMAL);
+    case ui::kColorMenuItemForegroundSelected:
+      return GetTextColor(GetMenuItem(), SELECTED);
+    case ui::kColorMenuItemForegroundDisabled:
+      return GetTextColor(GetMenuItem(), INSENSITIVE);
+    case ui::kColorMenuItemForegroundSecondary:
+      return GetTextColor(GetMenuItem(), INSENSITIVE);
+    case ui::kColorMenuSeparator:
+      return GetTextColor(GetMenuItem(), INSENSITIVE);
+
+    // Dropdown
+    case ui::kColorDropdownBackground:
+      return GetBgColor(GetMenuItem(), NORMAL);
+    case ui::kColorDropdownForeground:
+      return GetFgColor(GetMenuItem(), NORMAL);
+    case ui::kColorDropdownBackgroundSelected:
+      return GetBgColor(GetMenuItem(), SELECTED);
+    case ui::kColorDropdownForegroundSelected:
+      return GetFgColor(GetMenuItem(), SELECTED);
+
+    // Label
+    case ui::kColorLabelForeground:
+    case ui::kColorPrimaryForeground:
+      return GetTextColor(GetLabel(), NORMAL);
+    case ui::kColorLabelForegroundDisabled:
+    case ui::kColorLabelForegroundSecondary:
+    case ui::kColorDisabledForeground:
+    case ui::kColorSecondaryForeground:
+      return GetTextColor(GetLabel(), INSENSITIVE);
+    case ui::kColorLabelSelectionForeground:
+      return GetTextColor(GetLabel(), SELECTED);
+    case ui::kColorLabelSelectionBackground:
+      return GetBaseColor(GetLabel(), SELECTED);
+
+    // Link
+    case ui::kColorLinkForegroundDisabled:
+      return SkColorSetA(
+          GetSystemColor(ui::NativeTheme::kColorId_LinkEnabled, color_scheme),
+           0xBB);
+    case ui::kColorLinkForegroundPressed:
+    case ui::kColorLinkForeground: {
+      SkColor link_color = SK_ColorTRANSPARENT;
+      GdkColor* style_color = nullptr;
+      gtk_widget_style_get(GetWindow(), "link-color", &style_color, nullptr);
+      if (style_color) {
+        link_color = GdkColorToSkColor(*style_color);
+        gdk_color_free(style_color);
+      }
+      if (link_color != SK_ColorTRANSPARENT)
+        return link_color;
+      // Default color comes from gtklinkbutton.c.
+      return SkColorSetRGB(0x00, 0x00, 0xEE);
+    }
+
+    // Scrollbar
+    case ui::kColorOverlayScrollbarStroke:
+      return GetBgColor(GetButton(), NORMAL);
+    case ui::kColorOverlayScrollbarStrokeHovered:
+      return GetBgColor(GetButton(), PRELIGHT);
+    case ui::kColorOverlayScrollbarFill:
+      return GetBgColor(GetButton(), NORMAL);
+    case ui::kColorOverlayScrollbarFillHovered:
+      return GetBgColor(GetButton(), PRELIGHT);
+
+    // Slider
+    case ui::kColorSliderThumb:
+    case ui::kColorSliderTrack:
+      return GetBgColor(GetButton(), PRELIGHT);
+    case ui::kColorSliderThumbMinimal:
+    case ui::kColorSliderTrackMinimal:
+      return GetBgColor(GetButton(), INSENSITIVE);
+
+    // Separator
+    case ui::kColorMidground:
+    case ui::kColorSeparator:
+      return GetFgColor(GetSeparator(), INSENSITIVE);
+
+    // Button
+    case ui::kColorButtonBackground:
+      return GetBgColor(GetButton(), NORMAL);
+    case ui::kColorButtonForeground:
+    case ui::kColorButtonForegroundUnchecked:
+      return GetTextColor(GetButton(), NORMAL);
+    case ui::kColorButtonForegroundDisabled:
+      return GetTextColor(GetButton(), INSENSITIVE);
+
+    // ProminentButton
+    case ui::kColorAccent:
+    case ui::kColorButtonForegroundChecked:
+    case ui::kColorButtonBackgroundProminent:
+    // case ui::kColorButtonBackgroundProminentFocused:
+    case ui::kColorNotificationInputBackground:
+      return GetBgColor(GetLabel(), SELECTED);
+    case ui::kColorButtonForegroundProminent:
+    case ui::kColorNotificationInputForeground:
+      return GetTextColor(GetLabel(), SELECTED);
+    case ui::kColorButtonBackgroundProminentDisabled:
+    case ui::kColorButtonBorderDisabled:
+      return GetBgColor(GetLabel(), INSENSITIVE);
+    case ui::kColorButtonBorder:
+      return GetBgColor(GetLabel(), INSENSITIVE);
+    case ui::kColorButtonBackgroundProminentFocused:
+      return SkColorSetA(GetBgColor(GetLabel(), PRELIGHT), 0x33);
+
+    // ToggleButton
+    case ui::kColorToggleButtonTrackOff:
+      return GetBgColor(GetButton(), NORMAL);
+    case ui::kColorToggleButtonTrackOn:
+      return GetBgColor(GetButton(), SELECTED);
+
+    // TabbedPane
+    case ui::kColorTabForegroundSelected:
+      return GetTextColor(GetEntry(), NORMAL);
+    case ui::kColorTabForeground:
+      return GetTextColor(GetLabel(), INSENSITIVE);
+    case ui::kColorTabContentSeparator:
+      return GetTextColor(GetEntry(), NORMAL);
+    case ui::kColorTabBackgroundHighlighted:
+      return GetBgColor(GetEntry(), NORMAL);
+    case ui::kColorTabBackgroundHighlightedFocused:
+      return GetBgColor(GetEntry(), PRELIGHT);
+
+    // Textfield
+    case ui::kColorTextfieldForeground:
+      return GetTextColor(GetEntry(), NORMAL);
+    case ui::kColorTextfieldBackground:
+      return GetBaseColor(GetEntry(), NORMAL);
+    case ui::kColorTextfieldForegroundPlaceholder:
+      return GetTextColor(GetEntry(), INSENSITIVE);
+    case ui::kColorTextfieldForegroundDisabled:
+      return GetTextColor(GetEntry(), INSENSITIVE);
+    case ui::kColorTextfieldBackgroundDisabled:
+      return GetBgColor(GetEntry(), INSENSITIVE);
+    case ui::kColorTextfieldSelectionForeground:
+      return GetTextColor(GetEntry(), SELECTED);
+    case ui::kColorTextfieldSelectionBackground:
+      return GetBaseColor(GetEntry(), SELECTED);
+
+    // Tooltips
+    case ui::kColorTooltipBackground:
+      return GetBgColor(GetTooltip(), NORMAL);
+    case ui::kColorHelpIconInactive:
+      return GetFgColor(GetTooltip(), NORMAL);
+    case ui::kColorHelpIconActive:
+      return GetFgColor(GetTooltip(), PRELIGHT);
+    case ui::kColorTooltipForeground:
+      return GetFgColor(GetTooltip(), NORMAL);
+
+    // Trees and Tables (implemented on GTK using the same class)
+    case ui::kColorTableBackground:
+    case ui::kColorTableBackgroundAlternate:
+    case ui::kColorTreeBackground:
+      return GetBgColor(GetTree(), NORMAL);
+    case ui::kColorTableForeground:
+    case ui::kColorTreeNodeForeground:
+    case ui::kColorTableGroupingIndicator:
+      return GetFgColor(GetTree(), NORMAL);
+    case ui::kColorTableForegroundSelectedFocused:
+    case ui::kColorTableForegroundSelectedUnfocused:
+    case ui::kColorTreeNodeForegroundSelectedFocused:
+    case ui::kColorTreeNodeForegroundSelectedUnfocused:
+      return GetTextColor(GetTree(), NORMAL);
+    case ui::kColorTableBackgroundSelectedFocused:
+    case ui::kColorTableBackgroundSelectedUnfocused:
+    case ui::kColorTreeNodeBackgroundSelectedFocused:
+    case ui::kColorTreeNodeBackgroundSelectedUnfocused:
+      return GetBgColor(GetTree(), SELECTED);
+
+    // Table Header
+    case ui::kColorTableHeaderForeground:
+      return GetTextColor(GetTree(), NORMAL);
+    case ui::kColorTableHeaderBackground:
+      return GetBgColor(GetTree(), NORMAL);
+    case ui::kColorTableHeaderSeparator:
+      return GetFgColor(GetSeparator(), INSENSITIVE);
+
+    // Throbber
+    // TODO(thomasanderson): Render GtkSpinner directly.
+    case ui::kColorThrobber:
+      return GetSystemColor(kColorId_TextfieldSelectionBackgroundFocused, color_scheme);
+    case ui::kColorThrobberPreconnect:
+      return GetSystemColor(kColorId_TextfieldSelectionBackgroundFocused);
+
+    // Guest and Incognito Avatar
+    case ui::kColorAvatarIconIncognito:
+      return GetTextColor(GetLabel(), NORMAL);
+    case ui::kColorAvatarIconGuest:
+      return color_utils::DeriveDefaultIconColor(GetTextColor(GetLabel(), NORMAL));
+    case ui::kColorAvatarHeaderArt:
+      return color_utils::AlphaBlend(GetTextColor(GetLabel(), NORMAL),
+                                     GetBgColor(GetWindow(), NORMAL), gfx::kGoogleGreyAlpha300);
+
+    // Alert icons
+    // Fallback to the same colors as Aura.
+    case ui::kColorAlertLowSeverity:
+    case ui::kColorAlertMediumSeverity:
+    case ui::kColorAlertHighSeverity: {
+      // Alert icons appear on the toolbar, so use the toolbar BG
+      // color (the GTK window bg color) to determine if the dark
+      // or light native theme should be used for the icons.
+      return ui::GetAlertSeverityColor(color_id,
+                                       color_utils::IsDark(GetBgColor(GetWindow(), NORMAL)));
+    }
+
+    case ui::kColorMenuIcon:
+      return GetFgColor(GetMenu(), NORMAL);
+
+    case ui::kColorIcon:
+      return GetTextColor(GetLabel(), NORMAL);
+
+    default:
+      break;
+  }
+  return absl::nullopt;
 }
 
-}  // namespace gtk
+}  // namespace libgtkui
diff --git a/ui/gtk/native_theme_gtk.h b/ui/gtk/native_theme_gtk.h
index acaabda813fac..cfbc13ae7da18 100644
--- a/ui/gtk/native_theme_gtk.h
+++ b/ui/gtk/native_theme_gtk.h
@@ -11,67 +11,33 @@
 #include "third_party/abseil-cpp/absl/types/optional.h"
 #include "ui/base/glib/glib_signal.h"
 #include "ui/base/glib/scoped_gobject.h"
+#include "ui/color/color_id.h"
 #include "ui/native_theme/native_theme_base.h"
 
-typedef struct _GtkCssProvider GtkCssProvider;
-typedef struct _GtkParamSpec GtkParamSpec;
-typedef struct _GtkSettings GtkSettings;
+typedef struct _GtkWidget GtkWidget;
 
 namespace gtk {
 
-using ScopedCssProvider = ScopedGObject<GtkCssProvider>;
-
 // A version of NativeTheme that uses GTK-rendered widgets.
 class NativeThemeGtk : public ui::NativeThemeBase {
  public:
   static NativeThemeGtk* instance();
 
-  // ui::NativeThemeBase:
-  void PaintArrowButton(cc::PaintCanvas* canvas,
-                        const gfx::Rect& rect,
-                        Part direction,
-                        State state,
-                        ColorScheme color_scheme,
-                        const ScrollbarArrowExtraParams& arrow) const override;
-  void PaintScrollbarTrack(cc::PaintCanvas* canvas,
-                           Part part,
-                           State state,
-                           const ScrollbarTrackExtraParams& extra_params,
-                           const gfx::Rect& rect,
-                           ColorScheme color_scheme) const override;
-  void PaintScrollbarThumb(cc::PaintCanvas* canvas,
-                           Part part,
-                           State state,
-                           const gfx::Rect& rect,
-                           NativeTheme::ScrollbarOverlayColorTheme theme,
-                           ColorScheme color_scheme) const override;
-  void PaintScrollbarCorner(cc::PaintCanvas* canvas,
-                            State state,
-                            const gfx::Rect& rect,
-                            ColorScheme color_scheme) const override;
   void PaintMenuPopupBackground(
       cc::PaintCanvas* canvas,
       const gfx::Size& size,
       const MenuBackgroundExtraParams& menu_background,
       ColorScheme color_scheme) const override;
-  void PaintMenuSeparator(cc::PaintCanvas* canvas,
-                          State state,
-                          const gfx::Rect& rect,
-                          const MenuSeparatorExtraParams& menu_separator,
-                          ColorScheme color_scheme) const override;
+
   void PaintMenuItemBackground(cc::PaintCanvas* canvas,
                                State state,
                                const gfx::Rect& rect,
                                const MenuItemExtraParams& menu_item,
                                ColorScheme color_scheme) const override;
-  void PaintFrameTopArea(cc::PaintCanvas* canvas,
-                         State state,
-                         const gfx::Rect& rect,
-                         const FrameTopAreaExtraParams& frame_top_area,
-                         ColorScheme color_scheme) const override;
   void NotifyOnNativeThemeUpdated() override;
 
-  void OnThemeChanged(GtkSettings* settings, GtkParamSpec* param);
+  absl::optional<SkColor> SkColorFromColorId(
+    ui::ColorId color_id, ColorScheme color_scheme) const;
 
  protected:
   // ui::NativeThemeBase:
@@ -86,11 +52,18 @@ class NativeThemeGtk : public ui::NativeThemeBase {
   NativeThemeGtk();
   ~NativeThemeGtk() override;
 
-  void SetThemeCssOverride(ScopedCssProvider provider);
-
   mutable absl::optional<SkColor> color_cache_[kColorId_NumColors];
 
-  ScopedCssProvider theme_css_override_;
+  // Returns various widgets for theming use.
+  GtkWidget* GetWindow() const;
+  GtkWidget* GetEntry() const;
+  GtkWidget* GetLabel() const;
+  GtkWidget* GetButton() const;
+  GtkWidget* GetTree() const;
+  GtkWidget* GetTooltip() const;
+  GtkWidget* GetMenu() const;
+  GtkWidget* GetMenuItem() const;
+  GtkWidget* GetSeparator() const;
 
   DISALLOW_COPY_AND_ASSIGN(NativeThemeGtk);
 };
diff --git a/ui/gtk/nav_button_provider_gtk.cc b/ui/gtk/nav_button_provider_gtk.cc
deleted file mode 100644
index 27239539af487..0000000000000
--- a/ui/gtk/nav_button_provider_gtk.cc
+++ /dev/null
@@ -1,447 +0,0 @@
-// Copyright 2017 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "ui/gtk/nav_button_provider_gtk.h"
-
-#include "base/notreached.h"
-#include "ui/base/glib/glib_cast.h"
-#include "ui/base/glib/scoped_gobject.h"
-#include "ui/gfx/image/image_skia.h"
-#include "ui/gfx/image/image_skia_source.h"
-#include "ui/gtk/gtk_compat.h"
-#include "ui/gtk/gtk_util.h"
-#include "ui/views/widget/widget.h"
-
-namespace gtk {
-
-namespace {
-
-struct NavButtonIcon {
-  // Used on Gtk3.
-  ScopedGObject<GdkPixbuf> pixbuf;
-
-  // Used on Gtk4.
-  ScopedGObject<GdkTexture> texture;
-};
-
-// gtkheaderbar.c uses GTK_ICON_SIZE_MENU, which is 16px.
-const int kNavButtonIconSize = 16;
-
-// Specified in GtkHeaderBar spec.
-const int kHeaderSpacing = 6;
-
-const char* ButtonStyleClassFromButtonType(
-    views::NavButtonProvider::FrameButtonDisplayType type) {
-  switch (type) {
-    case views::NavButtonProvider::FrameButtonDisplayType::kMinimize:
-      return "minimize";
-    case views::NavButtonProvider::FrameButtonDisplayType::kMaximize:
-    case views::NavButtonProvider::FrameButtonDisplayType::kRestore:
-      return "maximize";
-    case views::NavButtonProvider::FrameButtonDisplayType::kClose:
-      return "close";
-    default:
-      NOTREACHED();
-      return "";
-  }
-}
-
-GtkStateFlags GtkStateFlagsFromButtonState(views::Button::ButtonState state) {
-  switch (state) {
-    case views::Button::STATE_NORMAL:
-      return GTK_STATE_FLAG_NORMAL;
-    case views::Button::STATE_HOVERED:
-      return GTK_STATE_FLAG_PRELIGHT;
-    case views::Button::STATE_PRESSED:
-      return static_cast<GtkStateFlags>(GTK_STATE_FLAG_PRELIGHT |
-                                        GTK_STATE_FLAG_ACTIVE);
-    case views::Button::STATE_DISABLED:
-      return GTK_STATE_FLAG_INSENSITIVE;
-    default:
-      NOTREACHED();
-      return GTK_STATE_FLAG_NORMAL;
-  }
-}
-
-const char* IconNameFromButtonType(
-    views::NavButtonProvider::FrameButtonDisplayType type) {
-  switch (type) {
-    case views::NavButtonProvider::FrameButtonDisplayType::kMinimize:
-      return "window-minimize-symbolic";
-    case views::NavButtonProvider::FrameButtonDisplayType::kMaximize:
-      return "window-maximize-symbolic";
-    case views::NavButtonProvider::FrameButtonDisplayType::kRestore:
-      return "window-restore-symbolic";
-    case views::NavButtonProvider::FrameButtonDisplayType::kClose:
-      return "window-close-symbolic";
-    default:
-      NOTREACHED();
-      return "";
-  }
-}
-
-gfx::Size LoadNavButtonIcon(
-    views::NavButtonProvider::FrameButtonDisplayType type,
-    GtkStyleContext* button_context,
-    int scale,
-    NavButtonIcon* icon = nullptr) {
-  const char* icon_name = IconNameFromButtonType(type);
-  if (!GtkCheckVersion(4)) {
-    auto icon_info = TakeGObject(gtk_icon_theme_lookup_icon_for_scale(
-        GetDefaultIconTheme(), icon_name, kNavButtonIconSize, scale,
-        static_cast<GtkIconLookupFlags>(GTK_ICON_LOOKUP_USE_BUILTIN |
-                                        GTK_ICON_LOOKUP_GENERIC_FALLBACK)));
-    auto icon_pixbuf = TakeGObject(gtk_icon_info_load_symbolic_for_context(
-        icon_info, button_context, nullptr, nullptr));
-    gfx::Size size{gdk_pixbuf_get_width(icon_pixbuf),
-                   gdk_pixbuf_get_height(icon_pixbuf)};
-    if (icon)
-      icon->pixbuf = std::move(icon_pixbuf);
-    return size;
-  }
-  auto icon_paintable = Gtk4IconThemeLookupIcon(
-      GetDefaultIconTheme(), icon_name, nullptr, kNavButtonIconSize, scale,
-      GTK_TEXT_DIR_NONE, static_cast<GtkIconLookupFlags>(0));
-  auto* paintable =
-      GlibCast<GdkPaintable>(icon_paintable.get(), gdk_paintable_get_type());
-  int width = scale * gdk_paintable_get_intrinsic_width(paintable);
-  int height = scale * gdk_paintable_get_intrinsic_height(paintable);
-  if (icon) {
-    auto* snapshot = gtk_snapshot_new();
-    gdk_paintable_snapshot(paintable, snapshot, width, height);
-    auto* node = gtk_snapshot_free_to_node(snapshot);
-    GdkTexture* texture = GetTextureFromRenderNode(node);
-    size_t nbytes = width * height * sizeof(SkColor);
-    SkColor* pixels = reinterpret_cast<SkColor*>(g_malloc(nbytes));
-    size_t stride = sizeof(SkColor) * width;
-    gdk_texture_download(texture, reinterpret_cast<guchar*>(pixels), stride);
-    SkColor fg = GtkStyleContextGetColor(button_context);
-    for (int i = 0; i < width * height; ++i)
-      pixels[i] = SkColorSetA(fg, SkColorGetA(pixels[i]));
-    icon->texture = TakeGObject(
-        gdk_memory_texture_new(width, height, GDK_MEMORY_B8G8R8A8,
-                               g_bytes_new_take(pixels, nbytes), stride));
-    gsk_render_node_unref(node);
-  }
-  return {width, height};
-}
-
-gfx::Size GetMinimumWidgetSize(gfx::Size content_size,
-                               GtkStyleContext* content_context,
-                               GtkCssContext widget_context) {
-  gfx::Rect widget_rect = gfx::Rect(content_size);
-  if (content_context)
-    widget_rect.Inset(-GtkStyleContextGetMargin(content_context));
-
-  int min_width = 0;
-  int min_height = 0;
-  // On GTK3, get the min size from the CSS directly.
-  if (GtkCheckVersion(3, 20) && !GtkCheckVersion(4)) {
-    GtkStyleContextGet(widget_context, "min-width", &min_width, "min-height",
-                       &min_height, nullptr);
-    widget_rect.set_width(std::max(widget_rect.width(), min_width));
-    widget_rect.set_height(std::max(widget_rect.height(), min_height));
-  }
-
-  widget_rect.Inset(-GtkStyleContextGetPadding(widget_context));
-  widget_rect.Inset(-GtkStyleContextGetBorder(widget_context));
-
-  // On GTK4, the CSS properties are hidden, so compute the min size indirectly,
-  // which will include the border, margin, and padding.  We can't take this
-  // codepath on GTK3 since we only have a widget available in GTK4.
-  if (GtkCheckVersion(4)) {
-    gtk_widget_measure(widget_context.widget(), GTK_ORIENTATION_HORIZONTAL, -1,
-                       &min_width, nullptr, nullptr, nullptr);
-    gtk_widget_measure(widget_context.widget(), GTK_ORIENTATION_VERTICAL, -1,
-                       &min_height, nullptr, nullptr, nullptr);
-
-    // The returned "minimum size" is the drawn size of the widget, which
-    // doesn't include the margin.  However, GTK includes this size in its
-    // calculation. So remove the margin, recompute the min size, then add it
-    // back.
-    auto margin = GtkStyleContextGetMargin(widget_context);
-    widget_rect.Inset(-margin);
-    widget_rect.set_width(std::max(widget_rect.width(), min_width));
-    widget_rect.set_height(std::max(widget_rect.height(), min_height));
-    widget_rect.Inset(margin);
-  }
-
-  return widget_rect.size();
-}
-
-GtkCssContext CreateHeaderContext(bool maximized) {
-  std::string window_selector = "GtkWindow#window.background.csd";
-  if (maximized)
-    window_selector += ".maximized";
-  return AppendCssNodeToStyleContext(
-      AppendCssNodeToStyleContext({}, window_selector),
-      "GtkHeaderBar#headerbar.header-bar.titlebar");
-}
-
-GtkCssContext CreateWindowControlsContext(bool maximized) {
-  return AppendCssNodeToStyleContext(CreateHeaderContext(maximized),
-                                     "#windowcontrols");
-}
-
-void CalculateUnscaledButtonSize(
-    views::NavButtonProvider::FrameButtonDisplayType type,
-    bool maximized,
-    gfx::Size* button_size,
-    gfx::Insets* button_margin) {
-  // views::ImageButton expects the images for each state to be of the
-  // same size, but GTK can, in general, use a differnetly-sized
-  // button for each state.  For this reason, render buttons for all
-  // states at the size of a GTK_STATE_FLAG_NORMAL button.
-  auto button_context = AppendCssNodeToStyleContext(
-      CreateWindowControlsContext(maximized),
-      "GtkButton#button.titlebutton." +
-          std::string(ButtonStyleClassFromButtonType(type)));
-
-  auto icon_size = LoadNavButtonIcon(type, button_context, 1);
-
-  auto image_context =
-      AppendCssNodeToStyleContext(button_context, "GtkImage#image");
-  gfx::Size image_size =
-      GetMinimumWidgetSize(icon_size, nullptr, image_context);
-
-  *button_size =
-      GetMinimumWidgetSize(image_size, image_context, button_context);
-  *button_margin = GtkStyleContextGetMargin(button_context);
-}
-
-class NavButtonImageSource : public gfx::ImageSkiaSource {
- public:
-  NavButtonImageSource(views::NavButtonProvider::FrameButtonDisplayType type,
-                       views::Button::ButtonState state,
-                       bool maximized,
-                       bool active,
-                       gfx::Size button_size)
-      : type_(type),
-        state_(state),
-        maximized_(maximized),
-        active_(active),
-        button_size_(button_size) {}
-
-  ~NavButtonImageSource() override = default;
-
-  gfx::ImageSkiaRep GetImageForScale(float scale) override {
-    // gfx::ImageSkia kindly caches the result of this function, so
-    // RenderNavButton() is called at most once for each needed scale
-    // factor.  Additionally, buttons in the HOVERED or PRESSED states
-    // are not actually rendered until they are needed.
-    if (button_size_.IsEmpty())
-      return gfx::ImageSkiaRep();
-
-    auto button_context =
-        AppendCssNodeToStyleContext(CreateWindowControlsContext(maximized_),
-                                    "GtkButton#button.titlebutton");
-    gtk_style_context_add_class(button_context,
-                                ButtonStyleClassFromButtonType(type_));
-    GtkStateFlags button_state = GtkStateFlagsFromButtonState(state_);
-    if (!active_) {
-      button_state =
-          static_cast<GtkStateFlags>(button_state | GTK_STATE_FLAG_BACKDROP);
-    }
-    gtk_style_context_set_state(button_context, button_state);
-
-    // Gtk header bars usually have the same height in both maximized and
-    // restored windows.  But chrome's tabstrip background has a smaller height
-    // when maximized.  To prevent buttons from clipping outside of this region,
-    // they are scaled down.  However, this is problematic for themes that do
-    // not expect this case and use bitmaps for frame buttons (like the Breeze
-    // theme).  When the background-size is set to auto, the background bitmap
-    // is not scaled for the (unexpected) smaller button size, and the button's
-    // edges appear cut off.  To fix this, manually set the background to scale
-    // to the button size when it would have clipped.
-    //
-    // GTK's "contain" is unlike CSS's "contain".  In CSS, the image would only
-    // be downsized when it would have clipped.  In GTK, the image is always
-    // scaled to fit the drawing region (preserving aspect ratio).  Only add
-    // "contain" if clipping would occur.
-    int bg_width = 0;
-    int bg_height = 0;
-    if (GtkCheckVersion(4)) {
-      auto* snapshot = gtk_snapshot_new();
-      gtk_snapshot_render_background(snapshot, button_context, 0, 0,
-                                     button_size_.width(),
-                                     button_size_.height());
-      if (auto* node = gtk_snapshot_free_to_node(snapshot)) {
-        if (GdkTexture* texture = GetTextureFromRenderNode(node)) {
-          bg_width = gdk_texture_get_width(texture);
-          bg_height = gdk_texture_get_height(texture);
-        }
-        gsk_render_node_unref(node);
-      }
-    } else {
-      cairo_pattern_t* cr_pattern = nullptr;
-      cairo_surface_t* cr_surface = nullptr;
-      GtkStyleContextGet(
-          button_context,
-          "background-image" /* GTK_STYLE_PROPERTY_BACKGROUND_IMAGE */,
-          &cr_pattern, nullptr);
-      if (cr_pattern) {
-        cairo_pattern_get_surface(cr_pattern, &cr_surface);
-        if (cr_surface &&
-            cairo_surface_get_type(cr_surface) == CAIRO_SURFACE_TYPE_IMAGE) {
-          bg_width = cairo_image_surface_get_width(cr_surface);
-          bg_height = cairo_image_surface_get_height(cr_surface);
-        }
-        cairo_pattern_destroy(cr_pattern);
-      }
-    }
-    if (bg_width > button_size_.width() || bg_height > button_size_.height()) {
-      ApplyCssToContext(button_context,
-                        ".titlebutton { background-size: contain; }");
-    }
-
-    // Gtk doesn't support fractional scale factors, but chrome does.
-    // Rendering the button background and border at a fractional
-    // scale factor is easy, since we can adjust the cairo context
-    // transform.  But the icon is loaded from a pixbuf, so we pick
-    // the next-highest integer scale and manually downsize.
-    int pixbuf_scale = scale == static_cast<int>(scale) ? scale : scale + 1;
-    NavButtonIcon icon;
-    auto icon_size =
-        LoadNavButtonIcon(type_, button_context, pixbuf_scale, &icon);
-
-    SkBitmap bitmap;
-    bitmap.allocN32Pixels(scale * button_size_.width(),
-                          scale * button_size_.height());
-    bitmap.eraseColor(0);
-
-    CairoSurface surface(bitmap);
-    cairo_t* cr = surface.cairo();
-
-    cairo_save(cr);
-    cairo_scale(cr, scale, scale);
-    if (GtkCheckVersion(3, 11, 3) ||
-        (button_state & (GTK_STATE_FLAG_PRELIGHT | GTK_STATE_FLAG_ACTIVE))) {
-      gtk_render_background(button_context, cr, 0, 0, button_size_.width(),
-                            button_size_.height());
-      gtk_render_frame(button_context, cr, 0, 0, button_size_.width(),
-                       button_size_.height());
-    }
-    cairo_restore(cr);
-    cairo_save(cr);
-    float pixbuf_extra_scale = scale / pixbuf_scale;
-    cairo_scale(cr, pixbuf_extra_scale, pixbuf_extra_scale);
-    GtkRenderIcon(
-        button_context, cr, icon.pixbuf, icon.texture,
-        ((pixbuf_scale * button_size_.width() - icon_size.width()) / 2),
-        ((pixbuf_scale * button_size_.height() - icon_size.height()) / 2));
-    cairo_restore(cr);
-
-    return gfx::ImageSkiaRep(bitmap, scale);
-  }
-
-  bool HasRepresentationAtAllScales() const override { return true; }
-
- private:
-  views::NavButtonProvider::FrameButtonDisplayType type_;
-  views::Button::ButtonState state_;
-  bool maximized_;
-  bool active_;
-  gfx::Size button_size_;
-};
-
-}  // namespace
-
-NavButtonProviderGtk::NavButtonProviderGtk() = default;
-
-NavButtonProviderGtk::~NavButtonProviderGtk() = default;
-
-void NavButtonProviderGtk::RedrawImages(int top_area_height,
-                                        bool maximized,
-                                        bool active) {
-  auto header_context = CreateHeaderContext(maximized);
-  auto header_padding = GtkStyleContextGetPadding(header_context);
-
-  double scale = 1.0f;
-  std::map<views::NavButtonProvider::FrameButtonDisplayType, gfx::Size>
-      button_sizes;
-  std::map<views::NavButtonProvider::FrameButtonDisplayType, gfx::Insets>
-      button_margins;
-  std::vector<views::NavButtonProvider::FrameButtonDisplayType> display_types{
-      views::NavButtonProvider::FrameButtonDisplayType::kMinimize,
-      maximized ? views::NavButtonProvider::FrameButtonDisplayType::kRestore
-                : views::NavButtonProvider::FrameButtonDisplayType::kMaximize,
-      views::NavButtonProvider::FrameButtonDisplayType::kClose,
-  };
-  for (auto type : display_types) {
-    CalculateUnscaledButtonSize(type, maximized, &button_sizes[type],
-                                &button_margins[type]);
-    int button_unconstrained_height = button_sizes[type].height() +
-                                      button_margins[type].top() +
-                                      button_margins[type].bottom();
-
-    int needed_height = header_padding.top() + button_unconstrained_height +
-                        header_padding.bottom();
-
-    if (needed_height > top_area_height)
-      scale =
-          std::min(scale, static_cast<double>(top_area_height) / needed_height);
-  }
-
-  top_area_spacing_ = gfx::Insets(std::round(scale * header_padding.top()),
-                                  std::round(scale * header_padding.left()),
-                                  std::round(scale * header_padding.bottom()),
-                                  std::round(scale * header_padding.right()));
-
-  inter_button_spacing_ = std::round(scale * kHeaderSpacing);
-
-  for (auto type : display_types) {
-    double button_height =
-        scale * (button_sizes[type].height() + button_margins[type].top() +
-                 button_margins[type].bottom());
-    double available_height =
-        top_area_height -
-        scale * (header_padding.top() + header_padding.bottom());
-    double scaled_button_offset = (available_height - button_height) / 2;
-
-    gfx::Size size = button_sizes[type];
-    size = gfx::Size(std::round(scale * size.width()),
-                     std::round(scale * size.height()));
-    gfx::Insets margin = button_margins[type];
-    margin =
-        gfx::Insets(std::round(scale * (header_padding.top() + margin.top()) +
-                               scaled_button_offset),
-                    std::round(scale * margin.left()), 0,
-                    std::round(scale * margin.right()));
-
-    button_margins_[type] = margin;
-
-    for (size_t state = 0; state < views::Button::STATE_COUNT; state++) {
-      button_images_[type][state] = gfx::ImageSkia(
-          std::make_unique<NavButtonImageSource>(
-              type, static_cast<views::Button::ButtonState>(state), maximized,
-              active, size),
-          size);
-    }
-  }
-}
-
-gfx::ImageSkia NavButtonProviderGtk::GetImage(
-    views::NavButtonProvider::FrameButtonDisplayType type,
-    views::Button::ButtonState state) const {
-  auto it = button_images_.find(type);
-  DCHECK(it != button_images_.end());
-  return it->second[state];
-}
-
-gfx::Insets NavButtonProviderGtk::GetNavButtonMargin(
-    views::NavButtonProvider::FrameButtonDisplayType type) const {
-  auto it = button_margins_.find(type);
-  DCHECK(it != button_margins_.end());
-  return it->second;
-}
-
-gfx::Insets NavButtonProviderGtk::GetTopAreaSpacing() const {
-  return top_area_spacing_;
-}
-
-int NavButtonProviderGtk::GetInterNavButtonSpacing() const {
-  return inter_button_spacing_;
-}
-
-}  // namespace gtk
diff --git a/ui/gtk/nav_button_provider_gtk.h b/ui/gtk/nav_button_provider_gtk.h
deleted file mode 100644
index ffedf019c8eaa..0000000000000
--- a/ui/gtk/nav_button_provider_gtk.h
+++ /dev/null
@@ -1,42 +0,0 @@
-// Copyright 2017 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef UI_GTK_NAV_BUTTON_PROVIDER_GTK_H_
-#define UI_GTK_NAV_BUTTON_PROVIDER_GTK_H_
-
-#include <map>
-
-#include "ui/gfx/image/image_skia.h"
-#include "ui/views/controls/button/button.h"
-#include "ui/views/linux_ui/nav_button_provider.h"
-
-namespace gtk {
-
-class NavButtonProviderGtk : public views::NavButtonProvider {
- public:
-  NavButtonProviderGtk();
-  ~NavButtonProviderGtk() override;
-
-  // views::NavButtonProvider:
-  void RedrawImages(int top_area_height, bool maximized, bool active) override;
-  gfx::ImageSkia GetImage(views::NavButtonProvider::FrameButtonDisplayType type,
-                          views::Button::ButtonState state) const override;
-  gfx::Insets GetNavButtonMargin(
-      views::NavButtonProvider::FrameButtonDisplayType type) const override;
-  gfx::Insets GetTopAreaSpacing() const override;
-  int GetInterNavButtonSpacing() const override;
-
- private:
-  std::map<views::NavButtonProvider::FrameButtonDisplayType,
-           gfx::ImageSkia[views::Button::STATE_COUNT]>
-      button_images_;
-  std::map<views::NavButtonProvider::FrameButtonDisplayType, gfx::Insets>
-      button_margins_;
-  gfx::Insets top_area_spacing_;
-  int inter_button_spacing_;
-};
-
-}  // namespace gtk
-
-#endif  // UI_GTK_NAV_BUTTON_PROVIDER_GTK_H_
diff --git a/ui/gtk/printing/print_dialog_gtk.cc b/ui/gtk/printing/print_dialog_gtk.cc
index 62108f0eb91fd..f214ab984caba 100644
--- a/ui/gtk/printing/print_dialog_gtk.cc
+++ b/ui/gtk/printing/print_dialog_gtk.cc
@@ -370,12 +370,8 @@ void PrintDialogGtk::ShowDialog(
   gtk::SetGtkTransientForAura(dialog_, parent_view);
   if (parent_view)
     parent_view->AddObserver(this);
-  if (gtk::GtkCheckVersion(4)) {
-    gtk_window_set_hide_on_close(GTK_WINDOW(dialog_), true);
-  } else {
-    g_signal_connect(dialog_, "delete-event",
-                     G_CALLBACK(gtk_widget_hide_on_delete), nullptr);
-  }
+  g_signal_connect(dialog_, "delete-event",
+                   G_CALLBACK(gtk_widget_hide_on_delete), nullptr);
 
   // Handle the case when the existing |gtk_settings_| has "selection" selected
   // as the page range, but |has_selection| is false.
@@ -532,7 +528,7 @@ void PrintDialogGtk::OnResponse(GtkWidget* dialog, int response_id) {
 
 static void OnJobCompletedThunk(GtkPrintJob* print_job,
                                 gpointer user_data,
-                                const GError* error) {
+                                GError* error) {
   static_cast<PrintDialogGtk*>(user_data)->OnJobCompleted(print_job, error);
 }
 void PrintDialogGtk::SendDocumentToPrinter(
diff --git a/ui/gtk/select_file_dialog_impl_gtk.cc b/ui/gtk/select_file_dialog_impl_gtk.cc
index d53f05761afa4..0bcced5112079 100644
--- a/ui/gtk/select_file_dialog_impl_gtk.cc
+++ b/ui/gtk/select_file_dialog_impl_gtk.cc
@@ -94,19 +94,9 @@ int GtkDialogSelectedFilterIndex(GtkWidget* dialog) {
   GtkFileFilter* selected_filter =
       gtk_file_chooser_get_filter(GTK_FILE_CHOOSER(dialog));
   int idx = -1;
-  if (GtkCheckVersion(4)) {
-    auto filters =
-        TakeGObject(gtk_file_chooser_get_filters(GTK_FILE_CHOOSER(dialog)));
-    int size = g_list_model_get_n_items(filters);
-    for (; idx < size; ++idx) {
-      if (g_list_model_get_item(filters, idx) == selected_filter)
-        break;
-    }
-  } else {
-    GSList* filters = gtk_file_chooser_list_filters(GTK_FILE_CHOOSER(dialog));
-    idx = g_slist_index(filters, selected_filter);
-    g_slist_free(filters);
-  }
+  GSList* filters = gtk_file_chooser_list_filters(GTK_FILE_CHOOSER(dialog));
+  idx = g_slist_index(filters, selected_filter);
+  g_slist_free(filters);
   return idx;
 }
 
@@ -116,40 +106,24 @@ std::string GtkFileChooserGetFilename(GtkWidget* dialog) {
     void operator()(gchar* ptr) const { g_free(ptr); }
   };
   std::unique_ptr<gchar, GFreeDeleter> gchar_filename;
-  if (GtkCheckVersion(4)) {
-    if (auto file =
-            TakeGObject(gtk_file_chooser_get_file(GTK_FILE_CHOOSER(dialog)))) {
-      filename = g_file_peek_path(file);
-    }
-  } else {
-    gchar_filename = std::unique_ptr<gchar, GFreeDeleter>(
-        gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog)));
-    filename = gchar_filename.get();
-  }
+  gchar_filename = std::unique_ptr<gchar, GFreeDeleter>(
+      gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog)));
+  filename = gchar_filename.get();
   return filename ? std::string(filename) : std::string();
 }
 
 std::vector<base::FilePath> GtkFileChooserGetFilenames(GtkWidget* dialog) {
   std::vector<base::FilePath> filenames_fp;
-  if (GtkCheckVersion(4)) {
-    auto files = Gtk4FileChooserGetFiles(GTK_FILE_CHOOSER(dialog));
-    auto size = g_list_model_get_n_items(files);
-    for (unsigned int i = 0; i < size; ++i) {
-      auto file = TakeGObject(G_FILE(g_list_model_get_object(files, i)));
-      filenames_fp.emplace_back(g_file_peek_path(file));
-    }
-  } else {
-    GSList* filenames =
-        gtk_file_chooser_get_filenames(GTK_FILE_CHOOSER(dialog));
-    if (!filenames)
-      return {};
-    for (GSList* iter = filenames; iter != nullptr; iter = g_slist_next(iter)) {
-      base::FilePath path(static_cast<char*>(iter->data));
-      g_free(iter->data);
-      filenames_fp.push_back(path);
-    }
-    g_slist_free(filenames);
+  GSList* filenames =
+      gtk_file_chooser_get_filenames(GTK_FILE_CHOOSER(dialog));
+  if (!filenames)
+    return {};
+  for (GSList* iter = filenames; iter != nullptr; iter = g_slist_next(iter)) {
+    base::FilePath path(static_cast<char*>(iter->data));
+    g_free(iter->data);
+    filenames_fp.push_back(path);
   }
+  g_slist_free(filenames);
   return filenames_fp;
 }
 
@@ -255,12 +229,8 @@ void SelectFileDialogImplGTK::SelectFileImpl(
       NOTREACHED();
       return;
   }
-  if (GtkCheckVersion(4)) {
-    gtk_window_set_hide_on_close(GTK_WINDOW(dialog), true);
-  } else {
-    g_signal_connect(dialog, "delete-event",
-                     G_CALLBACK(gtk_widget_hide_on_delete), nullptr);
-  }
+  g_signal_connect(dialog, "delete-event",
+                   G_CALLBACK(gtk_widget_hide_on_delete), nullptr);
 
   dialogs_[dialog] = g_signal_connect(
       dialog, "destroy", G_CALLBACK(OnFileChooserDestroyThunk), this);
diff --git a/ui/gtk/settings_provider_gtk.cc b/ui/gtk/settings_provider_gtk.cc
deleted file mode 100644
index 0163f4ece569f..0000000000000
--- a/ui/gtk/settings_provider_gtk.cc
+++ /dev/null
@@ -1,142 +0,0 @@
-// Copyright 2017 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "ui/gtk/settings_provider_gtk.h"
-
-#include "base/strings/string_split.h"
-#include "gtk_compat.h"
-#include "ui/gtk/gtk_compat.h"
-#include "ui/gtk/gtk_ui.h"
-#include "ui/gtk/gtk_util.h"
-
-namespace gtk {
-
-namespace {
-
-std::string GetDecorationLayoutFromGtkWindow() {
-  DCHECK(!GtkCheckVersion(4));
-
-  GtkCssContext context = GetStyleContextFromCss("");
-  gtk_style_context_add_class(context, "csd");
-
-  gchar* layout_c = nullptr;
-  GtkStyleContextGetStyle(context, "decoration-button-layout", &layout_c,
-                          nullptr);
-  DCHECK(layout_c);
-  std::string layout(layout_c);
-  g_free(layout_c);
-  return layout;
-}
-
-void ParseActionString(const std::string& value,
-                       GtkUi::WindowFrameAction* action) {
-  if (value == "none")
-    *action = views::LinuxUI::WindowFrameAction::kNone;
-  else if (value == "lower")
-    *action = views::LinuxUI::WindowFrameAction::kLower;
-  else if (value == "minimize")
-    *action = views::LinuxUI::WindowFrameAction::kMinimize;
-  else if (value == "toggle-maximize")
-    *action = views::LinuxUI::WindowFrameAction::kToggleMaximize;
-  else if (value == "menu")
-    *action = views::LinuxUI::WindowFrameAction::kMenu;
-}
-
-}  // namespace
-
-SettingsProviderGtk::FrameActionSettingWatcher::FrameActionSettingWatcher(
-    SettingsProviderGtk* settings_provider,
-    const std::string& setting_name,
-    views::LinuxUI::WindowFrameActionSource action_type,
-    views::LinuxUI::WindowFrameAction default_action)
-    : settings_provider_(settings_provider),
-      setting_name_(setting_name),
-      action_type_(action_type),
-      default_action_(default_action) {
-  GtkSettings* settings = gtk_settings_get_default();
-  std::string notify_setting = "notify::" + setting_name;
-  signal_id_ = g_signal_connect(settings, notify_setting.c_str(),
-                                G_CALLBACK(OnSettingChangedThunk), this);
-  DCHECK(signal_id_);
-  OnSettingChanged(settings, nullptr);
-}
-
-SettingsProviderGtk::FrameActionSettingWatcher::~FrameActionSettingWatcher() {
-  if (signal_id_)
-    g_signal_handler_disconnect(gtk_settings_get_default(), signal_id_);
-}
-
-void SettingsProviderGtk::FrameActionSettingWatcher::OnSettingChanged(
-    GtkSettings* settings,
-    GParamSpec* param) {
-  std::string value =
-      GetGtkSettingsStringProperty(settings, setting_name_.c_str());
-  GtkUi::WindowFrameAction action = default_action_;
-  ParseActionString(value, &action);
-  settings_provider_->delegate_->SetWindowFrameAction(action_type_, action);
-}
-
-SettingsProviderGtk::SettingsProviderGtk(GtkUi* delegate)
-    : delegate_(delegate), signal_id_decoration_layout_(0) {
-  DCHECK(delegate_);
-  GtkSettings* settings = gtk_settings_get_default();
-  if (GtkCheckVersion(3, 14)) {
-    signal_id_decoration_layout_ = g_signal_connect(
-        settings, "notify::gtk-decoration-layout",
-        G_CALLBACK(OnDecorationButtonLayoutChangedThunk), this);
-    DCHECK(signal_id_decoration_layout_);
-    OnDecorationButtonLayoutChanged(settings, nullptr);
-
-    frame_action_setting_watchers_.push_back(
-        std::make_unique<FrameActionSettingWatcher>(
-            this, "gtk-titlebar-middle-click",
-            views::LinuxUI::WindowFrameActionSource::kMiddleClick,
-            views::LinuxUI::WindowFrameAction::kNone));
-    frame_action_setting_watchers_.push_back(
-        std::make_unique<FrameActionSettingWatcher>(
-            this, "gtk-titlebar-double-click",
-            views::LinuxUI::WindowFrameActionSource::kDoubleClick,
-            views::LinuxUI::WindowFrameAction::kToggleMaximize));
-    frame_action_setting_watchers_.push_back(
-        std::make_unique<FrameActionSettingWatcher>(
-            this, "gtk-titlebar-right-click",
-            views::LinuxUI::WindowFrameActionSource::kRightClick,
-            views::LinuxUI::WindowFrameAction::kMenu));
-  } else {
-    signal_id_decoration_layout_ =
-        g_signal_connect_after(settings, "notify::gtk-theme-name",
-                               G_CALLBACK(OnThemeChangedThunk), this);
-    DCHECK(signal_id_decoration_layout_);
-    OnThemeChanged(settings, nullptr);
-  }
-}
-
-SettingsProviderGtk::~SettingsProviderGtk() {
-  if (signal_id_decoration_layout_) {
-    g_signal_handler_disconnect(gtk_settings_get_default(),
-                                signal_id_decoration_layout_);
-  }
-}
-
-void SettingsProviderGtk::SetWindowButtonOrderingFromGtkLayout(
-    const std::string& gtk_layout) {
-  std::vector<views::FrameButton> leading_buttons;
-  std::vector<views::FrameButton> trailing_buttons;
-  ParseButtonLayout(gtk_layout, &leading_buttons, &trailing_buttons);
-  delegate_->SetWindowButtonOrdering(leading_buttons, trailing_buttons);
-}
-
-void SettingsProviderGtk::OnDecorationButtonLayoutChanged(GtkSettings* settings,
-                                                          GParamSpec* param) {
-  SetWindowButtonOrderingFromGtkLayout(
-      GetGtkSettingsStringProperty(settings, "gtk-decoration-layout"));
-}
-
-void SettingsProviderGtk::OnThemeChanged(GtkSettings* settings,
-                                         GParamSpec* param) {
-  std::string layout = GetDecorationLayoutFromGtkWindow();
-  SetWindowButtonOrderingFromGtkLayout(layout);
-}
-
-}  // namespace gtk
diff --git a/ui/gtk/settings_provider_gtk.h b/ui/gtk/settings_provider_gtk.h
deleted file mode 100644
index 582d1bebd29ca..0000000000000
--- a/ui/gtk/settings_provider_gtk.h
+++ /dev/null
@@ -1,81 +0,0 @@
-// Copyright 2017 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef UI_GTK_SETTINGS_PROVIDER_GTK_H_
-#define UI_GTK_SETTINGS_PROVIDER_GTK_H_
-
-#include <memory>
-#include <string>
-#include <vector>
-
-#include "base/macros.h"
-#include "ui/base/glib/glib_signal.h"
-#include "ui/gtk/settings_provider.h"
-#include "ui/views/linux_ui/linux_ui.h"
-
-typedef struct _GParamSpec GParamSpec;
-typedef struct _GtkSettings GtkSettings;
-
-namespace gtk {
-
-class GtkUi;
-
-class SettingsProviderGtk : public SettingsProvider {
- public:
-  explicit SettingsProviderGtk(GtkUi* delegate);
-  ~SettingsProviderGtk() override;
-
- private:
-  class FrameActionSettingWatcher {
-   public:
-    FrameActionSettingWatcher(
-        SettingsProviderGtk* settings_provider,
-        const std::string& setting_name,
-        views::LinuxUI::WindowFrameActionSource action_type,
-        views::LinuxUI::WindowFrameAction default_action);
-    ~FrameActionSettingWatcher();
-
-    CHROMEG_CALLBACK_1(FrameActionSettingWatcher,
-                       void,
-                       OnSettingChanged,
-                       GtkSettings*,
-                       GParamSpec*);
-
-   private:
-    SettingsProviderGtk* settings_provider_;
-    std::string setting_name_;
-    views::LinuxUI::WindowFrameActionSource action_type_;
-    views::LinuxUI::WindowFrameAction default_action_;
-    unsigned long signal_id_;
-
-    DISALLOW_COPY_AND_ASSIGN(FrameActionSettingWatcher);
-  };
-
-  void SetWindowButtonOrderingFromGtkLayout(const std::string& gtk_layout);
-
-  CHROMEG_CALLBACK_1(SettingsProviderGtk,
-                     void,
-                     OnDecorationButtonLayoutChanged,
-                     GtkSettings*,
-                     GParamSpec*);
-
-  CHROMEG_CALLBACK_1(SettingsProviderGtk,
-                     void,
-                     OnThemeChanged,
-                     GtkSettings*,
-                     GParamSpec*);
-
-  GtkUi* delegate_;
-
-  unsigned long signal_id_decoration_layout_;
-
-  std::vector<std::unique_ptr<FrameActionSettingWatcher>>
-      frame_action_setting_watchers_;
-
-  DISALLOW_COPY_AND_ASSIGN(SettingsProviderGtk);
-};
-
-}  // namespace gtk
-
-#endif  // UI_GTK_SETTINGS_PROVIDER_GTK_H_
diff --git a/ui/gtk/skia_utils_gtk.cc b/ui/gtk/skia_utils_gtk.cc
new file mode 100644
index 0000000000000..bea308b6e2ccf
--- /dev/null
+++ b/ui/gtk/skia_utils_gtk.cc
@@ -0,0 +1,129 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/check_op.h"
+#include "base/notreached.h"
+#include "ui/gtk/skia_utils_gtk.h"
+
+#include <gdk/gdk.h>
+
+#include "base/logging.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "third_party/skia/include/core/SkUnPreMultiply.h"
+
+namespace gtk {
+
+// GDK_COLOR_RGB multiplies by 257 (= 0x10001) to distribute the bits evenly
+// See: http://www.mindcontrol.org/~hplus/graphics/expand-bits.html
+// To get back, we can just right shift by eight
+// (or, formulated differently, i == (i*257)/256 for all i < 256).
+
+SkColor GdkColorToSkColor(GdkColor color) {
+  return SkColorSetRGB(color.red >> 8, color.green >> 8, color.blue >> 8);
+}
+
+GdkColor SkColorToGdkColor(SkColor color) {
+  GdkColor gdk_color = {
+      0, static_cast<guint16>(SkColorGetR(color) * kSkiaToGDKMultiplier),
+      static_cast<guint16>(SkColorGetG(color) * kSkiaToGDKMultiplier),
+      static_cast<guint16>(SkColorGetB(color) * kSkiaToGDKMultiplier)};
+  return gdk_color;
+}
+
+const SkBitmap GdkPixbufToImageSkia(GdkPixbuf* pixbuf) {
+  // TODO(erg): What do we do in the case where the pixbuf fails these dchecks?
+  // I would prefer to use our gtk based canvas, but that would require
+  // recompiling half of our skia extensions with gtk support, which we can't
+  // do in this build.
+  DCHECK_EQ(GDK_COLORSPACE_RGB, gdk_pixbuf_get_colorspace(pixbuf));
+
+  int n_channels = gdk_pixbuf_get_n_channels(pixbuf);
+  int w = gdk_pixbuf_get_width(pixbuf);
+  int h = gdk_pixbuf_get_height(pixbuf);
+
+  SkBitmap ret;
+  ret.allocN32Pixels(w, h);
+  ret.eraseColor(0);
+
+  uint32_t* skia_data = static_cast<uint32_t*>(ret.getAddr(0, 0));
+
+  if (n_channels == 4) {
+    int total_length = w * h;
+    guchar* gdk_pixels = gdk_pixbuf_get_pixels(pixbuf);
+
+    // Now here's the trick: we need to convert the gdk data (which is RGBA and
+    // isn't premultiplied) to skia (which can be anything and premultiplied).
+    for (int i = 0; i < total_length; ++i, gdk_pixels += 4) {
+      const unsigned char& red = gdk_pixels[0];
+      const unsigned char& green = gdk_pixels[1];
+      const unsigned char& blue = gdk_pixels[2];
+      const unsigned char& alpha = gdk_pixels[3];
+
+      skia_data[i] = SkPreMultiplyARGB(alpha, red, green, blue);
+    }
+  } else if (n_channels == 3) {
+    // Because GDK makes rowstrides word aligned, we need to do something a bit
+    // more complex when a pixel isn't perfectly a word of memory.
+    int rowstride = gdk_pixbuf_get_rowstride(pixbuf);
+    guchar* gdk_pixels = gdk_pixbuf_get_pixels(pixbuf);
+    for (int y = 0; y < h; ++y) {
+      int row = y * rowstride;
+
+      for (int x = 0; x < w; ++x) {
+        guchar* pixel = gdk_pixels + row + (x * 3);
+        const unsigned char& red = pixel[0];
+        const unsigned char& green = pixel[1];
+        const unsigned char& blue = pixel[2];
+
+        skia_data[y * w + x] = SkPreMultiplyARGB(255, red, green, blue);
+      }
+    }
+  } else {
+    NOTREACHED();
+  }
+
+  return ret;
+}
+
+GdkPixbuf* GdkPixbufFromSkBitmap(const SkBitmap& bitmap) {
+  if (bitmap.isNull())
+    return nullptr;
+
+  int width = bitmap.width();
+  int height = bitmap.height();
+
+  GdkPixbuf* pixbuf =
+      gdk_pixbuf_new(GDK_COLORSPACE_RGB,  // The only colorspace gtk supports.
+                     TRUE,                // There is an alpha channel.
+                     8, width, height);
+
+  // SkBitmaps are premultiplied, we need to unpremultiply them.
+  const int kBytesPerPixel = 4;
+  uint8_t* divided = gdk_pixbuf_get_pixels(pixbuf);
+
+  for (int y = 0, i = 0; y < height; y++) {
+    for (int x = 0; x < width; x++) {
+      uint32_t pixel = bitmap.getAddr32(0, y)[x];
+
+      int alpha = SkColorGetA(pixel);
+      if (alpha != 0 && alpha != 255) {
+        SkColor unmultiplied = SkUnPreMultiply::PMColorToColor(pixel);
+        divided[i + 0] = SkColorGetR(unmultiplied);
+        divided[i + 1] = SkColorGetG(unmultiplied);
+        divided[i + 2] = SkColorGetB(unmultiplied);
+        divided[i + 3] = alpha;
+      } else {
+        divided[i + 0] = SkColorGetR(pixel);
+        divided[i + 1] = SkColorGetG(pixel);
+        divided[i + 2] = SkColorGetB(pixel);
+        divided[i + 3] = alpha;
+      }
+      i += kBytesPerPixel;
+    }
+  }
+
+  return pixbuf;
+}
+
+}  // namespace libgtkui
diff --git a/ui/gtk/skia_utils_gtk.h b/ui/gtk/skia_utils_gtk.h
new file mode 100644
index 0000000000000..0672b982a8ec9
--- /dev/null
+++ b/ui/gtk/skia_utils_gtk.h
@@ -0,0 +1,48 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_UI_LIBGTKUI_SKIA_UTILS_GTK_H_
+#define CHROME_BROWSER_UI_LIBGTKUI_SKIA_UTILS_GTK_H_
+
+#include <gtk/gtk.h>
+#include <stdint.h>
+
+#include "third_party/skia/include/core/SkColor.h"
+
+typedef struct _GdkColor GdkColor;
+
+class SkBitmap;
+
+// Define a macro for creating GdkColors from RGB values.  This is a macro to
+// allow static construction of literals, etc.  Use this like:
+//   GdkColor white = GDK_COLOR_RGB(0xff, 0xff, 0xff);
+#define GDK_COLOR_RGB(r, g, b)               \
+  {                                          \
+    0,                                       \
+    r * ::libgtkui::kSkiaToGDKMultiplier,    \
+    g * ::libgtkui::kSkiaToGDKMultiplier,    \
+    b * ::libgtkui::kSkiaToGDKMultiplier,    \
+  }
+
+namespace gtk {
+
+// Multiply uint8_t color components by this.
+const int kSkiaToGDKMultiplier = 257;
+
+// Converts GdkColors to the ARGB layout Skia expects.
+SkColor GdkColorToSkColor(GdkColor color);
+
+// Converts ARGB to GdkColor.
+GdkColor SkColorToGdkColor(SkColor color);
+
+const SkBitmap GdkPixbufToImageSkia(GdkPixbuf* pixbuf);
+
+// Convert and copy a SkBitmap to a GdkPixbuf. NOTE: this uses BGRAToRGBA, so
+// it is an expensive operation.  The returned GdkPixbuf will have a refcount of
+// 1, and the caller is responsible for unrefing it when done.
+GdkPixbuf* GdkPixbufFromSkBitmap(const SkBitmap& bitmap);
+
+}  // namespace libgtkui
+
+#endif  // CHROME_BROWSER_UI_LIBGTKUI_SKIA_UTILS_GTK_H_
diff --git a/ui/gtk/x/gtk_event_loop_x11.cc b/ui/gtk/x/gtk_event_loop_x11.cc
index b259260e09f21..07a6f1dc960ab 100644
--- a/ui/gtk/x/gtk_event_loop_x11.cc
+++ b/ui/gtk/x/gtk_event_loop_x11.cc
@@ -21,52 +21,17 @@ x11::KeyButMask BuildXkbStateFromGdkEvent(unsigned int state,
 }
 
 x11::KeyEvent ConvertGdkEventToKeyEvent(GdkEvent* gdk_event) {
-  if (!gtk::GtkCheckVersion(4)) {
-    auto* key = reinterpret_cast<GdkEventKey*>(gdk_event);
-    DCHECK(key->type == GdkKeyPress() || key->type == GdkKeyRelease());
-    return {
-        .opcode = key->type == GdkKeyPress() ? x11::KeyEvent::Press
-                                             : x11::KeyEvent::Release,
-        .send_event = !!key->send_event,
-        .detail = static_cast<x11::KeyCode>(key->hardware_keycode),
-        .time = static_cast<x11::Time>(key->time),
-        .root = ui::GetX11RootWindow(),
-        .event = static_cast<x11::Window>(gdk_x11_window_get_xid(key->window)),
-        .state = BuildXkbStateFromGdkEvent(key->state, key->group),
-        .same_screen = true,
-    };
-  }
-
-  GdkKeymapKey* keys = nullptr;
-  guint* keyvals = nullptr;
-  gint n_entries = 0;
-  gdk_display_map_keycode(gdk_display_get_default(),
-                          gdk_key_event_get_keycode(gdk_event), &keys, &keyvals,
-                          &n_entries);
-  guint keyval = gdk_key_event_get_keyval(gdk_event);
-  GdkKeymapKey keymap_key{0, 0, 0};
-  if (keys) {
-    for (gint i = 0; i < n_entries; i++) {
-      if (keyvals[i] == keyval) {
-        keymap_key = keys[i];
-        break;
-      }
-    }
-    g_free(keys);
-    g_free(keyvals);
-  }
-
+  auto* key = reinterpret_cast<GdkEventKey*>(gdk_event);
+  DCHECK(key->type == GdkKeyPress() || key->type == GdkKeyRelease());
   return {
-      .opcode = gtk::GdkEventGetEventType(gdk_event) == GdkKeyPress()
-                    ? x11::KeyEvent::Press
-                    : x11::KeyEvent::Release,
-      .detail = static_cast<x11::KeyCode>(keymap_key.keycode),
-      .time = static_cast<x11::Time>(gtk::GdkEventGetTime(gdk_event)),
+      .opcode = key->type == GdkKeyPress() ? x11::KeyEvent::Press
+                                           : x11::KeyEvent::Release,
+      .send_event = !!key->send_event,
+      .detail = static_cast<x11::KeyCode>(key->hardware_keycode),
+      .time = static_cast<x11::Time>(key->time),
       .root = ui::GetX11RootWindow(),
-      .event = static_cast<x11::Window>(
-          gdk_x11_surface_get_xid(gdk_event_get_surface(gdk_event))),
-      .state = BuildXkbStateFromGdkEvent(
-          gdk_event_get_modifier_state(gdk_event), keymap_key.group),
+      .event = static_cast<x11::Window>(gdk_x11_drawable_get_xid(key->window)),
+      .state = BuildXkbStateFromGdkEvent(key->state, key->group),
       .same_screen = true,
   };
 }
@@ -86,9 +51,7 @@ void ProcessGdkEvent(GdkEvent* gdk_event) {
   // corresponding key event in the X event queue.  So we have to handle this
   // case.  ibus-gtk is used through gtk-immodule to support IMEs.
 
-  auto event_type = gtk::GtkCheckVersion(4)
-                        ? gtk::GdkEventGetEventType(gdk_event)
-                        : *reinterpret_cast<GdkEventType*>(gdk_event);
+  auto event_type = *reinterpret_cast<GdkEventType*>(gdk_event);
   if (event_type != GdkKeyPress() && event_type != GdkKeyRelease())
     return;
 
@@ -101,28 +64,12 @@ void ProcessGdkEvent(GdkEvent* gdk_event) {
 }  // namespace
 
 GtkEventLoopX11::GtkEventLoopX11(GtkWidget* widget) {
-  if (gtk::GtkCheckVersion(4)) {
-    surface_ = gtk_native_get_surface(gtk_widget_get_native(widget));
-    signal_id_ =
-        g_signal_connect(surface_, "event", G_CALLBACK(OnEventThunk), this);
-  } else {
-    gdk_event_handler_set(DispatchGdkEvent, nullptr, nullptr);
-  }
+  gdk_event_handler_set(DispatchGdkEvent, nullptr, nullptr);
 }
 
 GtkEventLoopX11::~GtkEventLoopX11() {
-  if (gtk::GtkCheckVersion(4)) {
-    g_signal_handler_disconnect(surface_, signal_id_);
-  } else {
-    gdk_event_handler_set(reinterpret_cast<GdkEventFunc>(gtk_main_do_event),
-                          nullptr, nullptr);
-  }
-}
-
-gboolean GtkEventLoopX11::OnEvent(GdkEvent* gdk_event) {
-  DCHECK(gtk::GtkCheckVersion(4));
-  ProcessGdkEvent(gdk_event);
-  return false;
+  gdk_event_handler_set(reinterpret_cast<GdkEventFunc>(gtk_main_do_event),
+                        nullptr, nullptr);
 }
 
 // static
diff --git a/ui/gtk/x/gtk_event_loop_x11.h b/ui/gtk/x/gtk_event_loop_x11.h
index a6e9251ea3ed0..14c9edf91481b 100644
--- a/ui/gtk/x/gtk_event_loop_x11.h
+++ b/ui/gtk/x/gtk_event_loop_x11.h
@@ -20,15 +20,7 @@ class GtkEventLoopX11 {
   GtkEventLoopX11& operator=(const GtkEventLoopX11&) = delete;
 
  private:
-  // This state is only used on GTK4.
-  GdkSurface* surface_ = nullptr;
-  gulong signal_id_ = 0;
-
-  // Only called on GTK3.
   static void DispatchGdkEvent(GdkEvent* gdk_event, gpointer);
-
-  // Only called on GTK4.
-  CHROMEG_CALLBACK_0(GtkEventLoopX11, gboolean, OnEvent, GdkEvent*);
 };
 
 }  // namespace gtk
diff --git a/ui/gtk/x/gtk_ui_platform_x11.cc b/ui/gtk/x/gtk_ui_platform_x11.cc
index 3699ae0c97337..59d7cbd0684ba 100644
--- a/ui/gtk/x/gtk_ui_platform_x11.cc
+++ b/ui/gtk/x/gtk_ui_platform_x11.cc
@@ -23,10 +23,6 @@
 namespace gtk {
 
 GtkUiPlatformX11::GtkUiPlatformX11() : connection_(x11::Connection::Get()) {
-  gdk_set_allowed_backends("x11");
-  // GDK_BACKEND takes precedence over gdk_set_allowed_backends(), so override
-  // it to ensure we get the x11 backend.
-  base::Environment::Create()->SetVar("GDK_BACKEND", "x11");
   x11::InitXlib();
 }
 
@@ -71,10 +67,7 @@ bool GtkUiPlatformX11::ExportWindowHandle(
 bool GtkUiPlatformX11::SetGtkWidgetTransientFor(GtkWidget* widget,
                                                 gfx::AcceleratedWidget parent) {
   auto x11_window = static_cast<x11::Window>(
-      gtk::GtkCheckVersion(4)
-          ? gdk_x11_surface_get_xid(
-                gtk_native_get_surface(gtk_widget_get_native(widget)))
-          : gdk_x11_window_get_xid(gtk_widget_get_window(widget)));
+    gdk_x11_drawable_get_xid(gtk_widget_get_window(widget)));
   SetProperty(x11_window, x11::Atom::WM_TRANSIENT_FOR, x11::Atom::WINDOW,
               parent);
   SetProperty(x11_window, x11::GetAtom("_NET_WM_WINDOW_TYPE"), x11::Atom::ATOM,
