diff --git a/build/config/linux/gtk/gtk.gni b/build/config/linux/gtk/gtk.gni
index 0a3f35db9642..1a766e558ff4 100644
--- a/build/config/linux/gtk/gtk.gni
+++ b/build/config/linux/gtk/gtk.gni
@@ -9,7 +9,7 @@ declare_args() {
   use_gtk = is_desktop_linux && !is_chromecast
 
   # The (major) version of GTK to build against.
-  gtk_version = 3
+  gtk_version = 2
 }
 
-assert(gtk_version >= 3 && gtk_version <= 4)
+assert(gtk_version >= 2 && gtk_version <= 2)
diff --git a/chrome/browser/ui/gtk/BUILD.gn b/chrome/browser/ui/gtk/BUILD.gn
index 6b4cbfe2b82c..aff541a8e9eb 100644
--- a/chrome/browser/ui/gtk/BUILD.gn
+++ b/chrome/browser/ui/gtk/BUILD.gn
@@ -12,6 +12,10 @@ import("//ui/ozone/ozone.gni")
 
 jumbo_component("gtk") {
   sources = [
+    "chrome_gtk_frame.cc",
+    "chrome_gtk_frame.h",
+    "chrome_gtk_menu_subclasses.cc",
+    "chrome_gtk_menu_subclasses.h",
     "gtk_key_bindings_handler.cc",
     "gtk_key_bindings_handler.h",
     "gtk_ui.cc",
@@ -22,8 +26,6 @@ jumbo_component("gtk") {
     "input_method_context_impl_gtk.h",
     "native_theme_gtk.cc",
     "native_theme_gtk.h",
-    "nav_button_provider_gtk.cc",
-    "nav_button_provider_gtk.h",
     "print_dialog_gtk.cc",
     "print_dialog_gtk.h",
     "printing_gtk_util.cc",
@@ -34,8 +36,8 @@ jumbo_component("gtk") {
     "select_file_dialog_impl_gtk.h",
     "select_file_dialog_impl_kde.cc",
     "settings_provider.h",
-    "settings_provider_gtk.cc",
-    "settings_provider_gtk.h",
+    "skia_utils_gtk.cc",
+    "skia_utils_gtk.h",
   ]
 
   configs += [ "//build/config/linux/pangocairo" ]
diff --git a/chrome/browser/ui/gtk/chrome_gtk_frame.cc b/chrome/browser/ui/gtk/chrome_gtk_frame.cc
new file mode 100644
index 000000000000..68be852d1562
--- /dev/null
+++ b/chrome/browser/ui/gtk/chrome_gtk_frame.cc
@@ -0,0 +1,154 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/gtk/chrome_gtk_frame.h"
+
+G_GNUC_BEGIN_IGNORE_DEPRECATIONS
+
+G_BEGIN_DECLS
+
+// MetaFrames declaration
+G_DEFINE_TYPE(MetaFrames, meta_frames, GTK_TYPE_WINDOW)
+
+static void meta_frames_class_init(MetaFramesClass* frames_class) {
+  // Noop since we don't declare anything.
+}
+
+static void meta_frames_init(MetaFrames* button) {
+}
+
+
+// ChromeGtkFrame declaration
+G_DEFINE_TYPE(ChromeGtkFrame, chrome_gtk_frame, meta_frames_get_type())
+
+static void chrome_gtk_frame_class_init(ChromeGtkFrameClass* frame_class) {
+  GtkWidgetClass* widget_class = reinterpret_cast<GtkWidgetClass*>(frame_class);
+
+  // Frame tints:
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "frame-color",
+          "Frame Color",
+          "The color that the chrome frame will be. (If unspecified, "
+            " Chrome will take ChromeGtkFrame::bg[SELECTED] and slightly darken"
+            " it.)",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "inactive-frame-color",
+          "Inactive Frame Color",
+          "The color that the inactive chrome frame will be. (If"
+            " unspecified, Chrome will take ChromeGtkFrame::bg[INSENSITIVE]"
+            " and slightly darken it.)",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "incognito-frame-color",
+          "Incognito Frame Color",
+          "The color that the incognito frame will be. (If unspecified,"
+            " Chrome will take the frame color and tint it by Chrome's default"
+            " incognito tint.)",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "incognito-inactive-frame-color",
+          "Incognito Inactive Frame Color",
+          "The color that the inactive incognito frame will be. (If"
+            " unspecified, Chrome will take the frame color and tint it by"
+            " Chrome's default incognito tint.)",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+
+  // Frame gradient control:
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_int(
+          "frame-gradient-size",
+          "Chrome Frame Gradient Size",
+          "The size of the gradient on top of the frame image. Specify 0 to"
+            " make the frame a solid color.",
+          0,      // 0 disables the gradient
+          128,    // The frame image is only up to 128 pixels tall.
+          16,     // By default, gradients are 16 pixels high.
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "frame-gradient-color",
+          "Frame Gradient Color",
+          "The top color of the chrome frame gradient. (If unspecified,"
+            " chrome will create a lighter tint of frame-color",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "inactive-frame-gradient-color",
+          "Inactive Frame Gradient Color",
+          "The top color of the inactive chrome frame gradient. (If"
+            " unspecified, chrome will create a lighter tint of frame-color",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "incognito-frame-gradient-color",
+          "Incognito Frame Gradient Color",
+          "The top color of the incognito chrome frame gradient. (If"
+            " unspecified, chrome will create a lighter tint of frame-color",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "incognito-inactive-frame-gradient-color",
+          "Incognito Inactive Frame Gradient Color",
+          "The top color of the incognito inactive chrome frame gradient. (If"
+            " unspecified, chrome will create a lighter tint of frame-color",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+
+  // Scrollbar color properties:
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "scrollbar-slider-prelight-color",
+          "Scrollbar Slider Prelight Color",
+          "The color applied to the mouse is above the tab",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "scrollbar-slider-normal-color",
+          "Scrollbar Slider Normal Color",
+          "The color applied to the slider normally",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+  gtk_widget_class_install_style_property(
+      widget_class,
+      g_param_spec_boxed(
+          "scrollbar-trough-color",
+          "Scrollbar Trough Color",
+          "The background color of the slider track",
+          GDK_TYPE_COLOR,
+          G_PARAM_READABLE));
+}
+
+static void chrome_gtk_frame_init(ChromeGtkFrame* frame) {
+}
+
+GtkWidget* chrome_gtk_frame_new(void) {
+  return GTK_WIDGET(g_object_new(chrome_gtk_frame_get_type(), "type",
+                                 GTK_WINDOW_TOPLEVEL, nullptr));
+}
+
+G_END_DECLS
diff --git a/chrome/browser/ui/gtk/chrome_gtk_frame.h b/chrome/browser/ui/gtk/chrome_gtk_frame.h
new file mode 100644
index 000000000000..2d783453ced0
--- /dev/null
+++ b/chrome/browser/ui/gtk/chrome_gtk_frame.h
@@ -0,0 +1,54 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_UI_LIBGTKUI_CHROME_GTK_FRAME_H_
+#define CHROME_BROWSER_UI_LIBGTKUI_CHROME_GTK_FRAME_H_
+
+#include <gtk/gtk.h>
+
+G_BEGIN_DECLS
+
+// This file declares two subclasses of GtkWindow for easier gtk+ theme
+// integration.
+//
+// The first is "MetaFrames," which is (was?) the name of a gobject class in
+// the metacity window manager. To actually get at those values, we need to
+// have an object whose gobject class name string matches the definitions in
+// the gtkrc file. MetaFrames derives from GtkWindow.
+//
+// Metaframes can not be instantiated. It has no constructor; instantiate
+// ChromeGtkFrame instead.
+typedef struct _MetaFrames       MetaFrames;
+typedef struct _MetaFramesClass  MetaFramesClass;
+
+struct _MetaFrames {
+  GtkWindow window;
+};
+
+struct _MetaFramesClass {
+  GtkWindowClass parent_class;
+};
+
+
+// The second is ChromeGtkFrame, which defines a number of optional style
+// properties so theme authors can control how chromium appears in gtk-theme
+// mode.  It derives from MetaFrames in chrome so older themes that declare a
+// MetaFrames theme will still work. New themes should target this class.
+typedef struct _ChromeGtkFrame       ChromeGtkFrame;
+typedef struct _ChromeGtkFrameClass  ChromeGtkFrameClass;
+
+struct _ChromeGtkFrame {
+  MetaFrames frames;
+};
+
+struct _ChromeGtkFrameClass {
+  MetaFramesClass frames_class;
+};
+
+// Creates a GtkWindow object the the class name "ChromeGtkFrame".
+GtkWidget* chrome_gtk_frame_new();
+
+G_END_DECLS
+
+#endif  // CHROME_BROWSER_UI_LIBGTKUI_CHROME_GTK_FRAME_H_
diff --git a/chrome/browser/ui/gtk/chrome_gtk_menu_subclasses.cc b/chrome/browser/ui/gtk/chrome_gtk_menu_subclasses.cc
new file mode 100644
index 000000000000..df8ee7bf0203
--- /dev/null
+++ b/chrome/browser/ui/gtk/chrome_gtk_menu_subclasses.cc
@@ -0,0 +1,29 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/gtk/chrome_gtk_menu_subclasses.h"
+
+G_DEFINE_TYPE(GtkCustomMenu, gtk_custom_menu, GTK_TYPE_MENU)
+
+static void gtk_custom_menu_init(GtkCustomMenu* menu) {
+}
+
+static void gtk_custom_menu_class_init(GtkCustomMenuClass* klass) {
+}
+
+GtkWidget* gtk_custom_menu_new() {
+  return GTK_WIDGET(g_object_new(gtk_custom_menu_get_type(), nullptr));
+}
+
+G_DEFINE_TYPE(GtkCustomMenuItem, gtk_custom_menu_item, GTK_TYPE_MENU_ITEM)
+
+static void gtk_custom_menu_item_init(GtkCustomMenuItem* item) {
+}
+
+static void gtk_custom_menu_item_class_init(GtkCustomMenuItemClass* klass) {
+}
+
+GtkWidget* gtk_custom_menu_item_new() {
+  return GTK_WIDGET(g_object_new(gtk_custom_menu_item_get_type(), nullptr));
+}
diff --git a/chrome/browser/ui/gtk/chrome_gtk_menu_subclasses.h b/chrome/browser/ui/gtk/chrome_gtk_menu_subclasses.h
new file mode 100644
index 000000000000..fd999576543a
--- /dev/null
+++ b/chrome/browser/ui/gtk/chrome_gtk_menu_subclasses.h
@@ -0,0 +1,47 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_UI_LIBGTKUI_CHROME_GTK_MENU_SUBCLASSES_H_
+#define CHROME_BROWSER_UI_LIBGTKUI_CHROME_GTK_MENU_SUBCLASSES_H_
+
+#include <gtk/gtk.h>
+
+// This file declares two subclasses of Gtk's menu classes. We do this because
+// when we were a GTK app proper, we had classes with the same names, and gtk
+// theme authors started writing themes and styling chrome's menus by targeting
+// these classes. We have to fetch our colors from these theme classes in
+// specific because several newer GTK+2 themes are pixmap based and they
+// specifically give real colors only to these classes.
+
+G_BEGIN_DECLS
+
+typedef struct _GtkCustomMenu GtkCustomMenu;
+typedef struct _GtkCustomMenuClass GtkCustomMenuClass;
+
+struct _GtkCustomMenu {
+  GtkMenu menu;
+};
+
+struct _GtkCustomMenuClass {
+  GtkMenuClass parent_class;
+};
+
+GtkWidget* gtk_custom_menu_new();
+
+typedef struct _GtkCustomMenuItem GtkCustomMenuItem;
+typedef struct _GtkCustomMenuItemClass GtkCustomMenuItemClass;
+
+struct _GtkCustomMenuItem {
+  GtkMenuItem menu_item;
+};
+
+struct _GtkCustomMenuItemClass {
+  GtkMenuItemClass parent_class;
+};
+
+GtkWidget* gtk_custom_menu_item_new();
+
+G_END_DECLS
+
+#endif  // CHROME_BROWSER_UI_LIBGTKUI_CHROME_GTK_MENU_SUBCLASSES_H_
diff --git a/chrome/browser/ui/gtk/gtk_key_bindings_handler.cc b/chrome/browser/ui/gtk/gtk_key_bindings_handler.cc
index b65938b48a86..a67ec92716aa 100644
--- a/chrome/browser/ui/gtk/gtk_key_bindings_handler.cc
+++ b/chrome/browser/ui/gtk/gtk_key_bindings_handler.cc
@@ -67,7 +67,7 @@ bool GtkKeyBindingsHandler::MatchEvent(
   // If this key event matches a predefined key binding, corresponding signal
   // will be emitted.
 
-  gtk_bindings_activate_event(G_OBJECT(handler_), &gdk_event->key);
+  gtk_bindings_activate_event(GTK_OBJECT(handler_), &gdk_event->key);
   gdk_event_free(gdk_event);
 
   bool matched = !edit_commands_.empty();
diff --git a/chrome/browser/ui/gtk/gtk_ui.cc b/chrome/browser/ui/gtk/gtk_ui.cc
index 8b9af0a354ba..40b3de915587 100644
--- a/chrome/browser/ui/gtk/gtk_ui.cc
+++ b/chrome/browser/ui/gtk/gtk_ui.cc
@@ -25,13 +25,13 @@
 #include "chrome/browser/themes/theme_properties.h"
 #include "chrome/browser/ui/gtk/gtk_key_bindings_handler.h"
 #include "chrome/browser/ui/gtk/gtk_util.h"
+#include "chrome/browser/ui/gtk/chrome_gtk_frame.h"
 #include "chrome/browser/ui/gtk/input_method_context_impl_gtk.h"
 #include "chrome/browser/ui/gtk/native_theme_gtk.h"
-#include "chrome/browser/ui/gtk/nav_button_provider_gtk.h"
 #include "chrome/browser/ui/gtk/print_dialog_gtk.h"
 #include "chrome/browser/ui/gtk/printing_gtk_util.h"
 #include "chrome/browser/ui/gtk/select_file_dialog_impl.h"
-#include "chrome/browser/ui/gtk/settings_provider_gtk.h"
+#include "chrome/browser/ui/gtk/skia_utils_gtk.h"
 #include "chrome/common/pref_names.h"
 #include "components/prefs/pref_service.h"
 #include "printing/buildflags/buildflags.h"
@@ -133,51 +133,47 @@ class GtkButtonImageSource : public gfx::ImageSkiaSource {
         width, height, width * 4);
     cairo_t* cr = cairo_create(surface);
 
-    ScopedStyleContext context = GetStyleContextFromCss("GtkButton#button");
-    GtkStateFlags state_flags = StateToStateFlags(state_);
-    if (focus_) {
-      state_flags =
-          static_cast<GtkStateFlags>(state_flags | GTK_STATE_FLAG_FOCUSED);
+    // Create a temporary GTK button to snapshot
+    GtkWidget* window = gtk_offscreen_window_new();
+    GtkWidget* button = gtk_toggle_button_new();
+
+    if (state_ == ui::NativeTheme::kPressed)
+      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), true);
+    else if (state_ == ui::NativeTheme::kDisabled)
+      gtk_widget_set_sensitive(button, false);
+
+    gtk_widget_set_size_request(button, width, height);
+    gtk_container_add(GTK_CONTAINER(window), button);
+
+    // if (is_blue_)
+    //   TurnButtonBlue(button);
+
+    gtk_widget_show_all(window);
+
+    if (focus_)
+      GTK_WIDGET_SET_FLAGS(button, GTK_HAS_FOCUS);
+
+    int w, h;
+    GdkPixmap* pixmap;
+
+    {
+      // http://crbug.com/346740
+      ANNOTATE_SCOPED_MEMORY_LEAK;
+      pixmap = gtk_widget_get_snapshot(button, nullptr);
     }
-    gtk_style_context_set_state(context, state_flags);
-    gtk_render_background(context, cr, 0, 0, width, height);
-    gtk_render_frame(context, cr, 0, 0, width, height);
-    if (focus_) {
-      gfx::Rect focus_rect(width, height);
 
-#if !GTK_CHECK_VERSION(3, 90, 0)
-      if (!GtkVersionCheck(3, 14)) {
-        gint focus_pad;
-        gtk_style_context_get_style(context, "focus-padding", &focus_pad,
-                                    nullptr);
-        focus_rect.Inset(focus_pad, focus_pad);
+    gdk_drawable_get_size(GDK_DRAWABLE(pixmap), &w, &h);
+    GdkColormap* colormap = gdk_drawable_get_colormap(pixmap);
+    GdkPixbuf* pixbuf = gdk_pixbuf_get_from_drawable(
+        nullptr, GDK_DRAWABLE(pixmap), colormap, 0, 0, 0, 0, w, h);
 
-        if (state_ == ui::NativeTheme::kPressed) {
-          gint child_displacement_x, child_displacement_y;
-          gboolean displace_focus;
-          gtk_style_context_get_style(
-              context, "child-displacement-x", &child_displacement_x,
-              "child-displacement-y", &child_displacement_y, "displace-focus",
-              &displace_focus, nullptr);
-          if (displace_focus)
-            focus_rect.Offset(child_displacement_x, child_displacement_y);
-        }
-      }
-#endif
+    gdk_cairo_set_source_pixbuf(cr, pixbuf, 0, 0);
+    cairo_paint(cr);
 
-      if (!GtkVersionCheck(3, 20)) {
-        GtkBorder border;
-#if GTK_CHECK_VERSION(3, 90, 0)
-        gtk_style_context_get_border(context, &border);
-#else
-        gtk_style_context_get_border(context, state_flags, &border);
-#endif
-        focus_rect.Inset(border.left, border.top, border.right, border.bottom);
-      }
+    g_object_unref(pixbuf);
+    g_object_unref(pixmap);
 
-      gtk_render_focus(context, cr, focus_rect.x(), focus_rect.y(),
-                       focus_rect.width(), focus_rect.height());
-    }
+    gtk_widget_destroy(window);
 
     cairo_destroy(cr);
     cairo_surface_destroy(surface);
@@ -239,8 +235,6 @@ int indicators_count;
 const char kUnknownContentType[] = "application/octet-stream";
 
 std::unique_ptr<SettingsProvider> CreateSettingsProvider(GtkUi* gtk_ui) {
-  if (GtkVersionCheck(3, 14))
-    return std::make_unique<SettingsProviderGtk>(gtk_ui);
 #if defined(USE_GIO)
   return std::make_unique<SettingsProviderGSettings>(gtk_ui);
 #else
@@ -298,8 +292,6 @@ gfx::FontRenderParams GetGtkFontRenderParams() {
 }
 
 views::LinuxUI::WindowFrameAction GetDefaultMiddleClickAction() {
-  if (GtkVersionCheck(3, 14))
-    return views::LinuxUI::WindowFrameAction::kNone;
   std::unique_ptr<base::Environment> env(base::Environment::Create());
   switch (base::nix::GetDesktopEnvironment(env.get())) {
     case base::nix::DESKTOP_ENVIRONMENT_KDE4:
@@ -392,25 +384,13 @@ GtkUi::GtkUi() {
       {ActionSource::kMiddleClick, GetDefaultMiddleClickAction()},
       {ActionSource::kRightClick, Action::kMenu}};
 
-#if defined(USE_X11)
-  // Force Gtk to use Xwayland (in case a Wayland compositor is being used).
-  gdk_set_allowed_backends("x11");
-#elif defined(USE_OZONE)
-  // TODO(crbug.com/1002674): This is a temporary layering violation, supported
-  // during X11 migration to Ozone. Once LinuxUI/GtkUi is reworked to be more
-  // aligned with Ozone design, this will be moved into ozone backend code.
-  std::string ozone_platform{ui::OzonePlatform::GetPlatformName()};
-  if (ozone_platform == "x11" || ozone_platform == "wayland")
-    gdk_set_allowed_backends(ozone_platform.c_str());
-#endif
-
   // Avoid GTK initializing atk-bridge, and let AuraLinux implementation
   // do it once it is ready.
   std::unique_ptr<base::Environment> env(base::Environment::Create());
   env->SetVar("NO_AT_BRIDGE", "1");
   GtkInitFromCommandLine(*base::CommandLine::ForCurrentProcess());
   native_theme_ = NativeThemeGtk::instance();
-  fake_window_ = gtk_window_new(GTK_WINDOW_TOPLEVEL);
+  fake_window_ = chrome_gtk_frame_new();
   gtk_widget_realize(fake_window_);
 }
 
@@ -843,7 +823,7 @@ void GtkUi::OnThemeChanged(GtkSettings* settings, GtkParamSpec* param) {
   colors_.clear();
   custom_frame_colors_.clear();
   native_frame_colors_.clear();
-  native_theme_->OnThemeChanged(settings, param);
+  //native_theme_->OnThemeChanged(settings, param);
   LoadGtkValues();
   native_theme_->NotifyObservers();
 }
@@ -870,6 +850,19 @@ void GtkUi::OnDeviceScaleFactorMaybeChanged(void*, GParamSpec*) {
   UpdateDeviceScaleFactor();
 }
 
+bool GtkUi::GetChromeStyleColor(const char* style_property,
+                                SkColor* ret_color) const {
+  GdkColor* style_color = nullptr;
+  gtk_widget_style_get(fake_window_, style_property, &style_color, nullptr);
+  if (style_color) {
+    *ret_color = GdkColorToSkColor(*style_color);
+    gdk_color_free(style_color);
+    return true;
+  }
+
+  return false;
+}
+
 void GtkUi::LoadGtkValues() {
   // TODO(thomasanderson): GtkThemeService had a comment here about having to
   // muck with the raw Prefs object to remove prefs::kCurrentThemeImages or else
@@ -880,49 +873,70 @@ void GtkUi::LoadGtkValues() {
 }
 
 void GtkUi::UpdateColors() {
-  SkColor location_bar_border = GetBorderColor("GtkEntry#entry");
-  if (SkColorGetA(location_bar_border))
-    colors_[ThemeProperties::COLOR_LOCATION_BAR_BORDER] = location_bar_border;
+  const color_utils::HSL kDefaultFrameShift = {-1, -1, 0.4};
+  SkColor frame_color =
+      native_theme_->GetSystemColor(ui::NativeTheme::kColorId_WindowBackground);
+  frame_color = color_utils::HSLShift(frame_color, kDefaultFrameShift);
+  GetChromeStyleColor("frame-color", &frame_color);
+  colors_[ThemeProperties::COLOR_FRAME] = frame_color;
 
-  inactive_selection_bg_color_ = GetSelectionBgColor(
-      GtkVersionCheck(3, 20) ? "GtkTextView#textview.view:backdrop "
-                               "#text:backdrop #selection:backdrop"
-                             : "GtkTextView.view:selected:backdrop");
-  inactive_selection_fg_color_ =
-      GetFgColor(GtkVersionCheck(3, 20) ? "GtkTextView#textview.view:backdrop "
-                                          "#text:backdrop #selection:backdrop"
-                                        : "GtkTextView.view:selected:backdrop");
+  GtkStyle* style = gtk_rc_get_style(fake_window_);
+  SkColor temp_color = color_utils::HSLShift(
+      GdkColorToSkColor(style->bg[GTK_STATE_INSENSITIVE]), kDefaultFrameShift);
+  GetChromeStyleColor("inactive-frame-color", &temp_color);
+  colors_[ThemeProperties::COLOR_FRAME_INACTIVE] = temp_color;
 
-  SkColor tab_border = GetBorderColor("GtkButton#button");
-  // Separates the toolbar from the bookmark bar or butter bars.
-  colors_[ThemeProperties::COLOR_TOOLBAR_CONTENT_AREA_SEPARATOR] = tab_border;
-  // Separates entries in the downloads bar.
-  colors_[ThemeProperties::COLOR_TOOLBAR_VERTICAL_SEPARATOR] = tab_border;
+  temp_color = color_utils::HSLShift(frame_color, kDefaultTintFrameIncognito);
+  GetChromeStyleColor("incognito-frame-color", &temp_color);
+  colors_[ThemeProperties::COLOR_FRAME_INCOGNITO] = temp_color;
 
+  temp_color =
+      color_utils::HSLShift(frame_color, kDefaultTintFrameIncognito);
+  GetChromeStyleColor("incognito-inactive-frame-color", &temp_color);
+  colors_[ThemeProperties::COLOR_FRAME_INCOGNITO_INACTIVE] = temp_color;
+
+  SkColor tab_color =
+      native_theme_->GetSystemColor(ui::NativeTheme::kColorId_DialogBackground);
+  SkColor label_color = native_theme_->GetSystemColor(
+      ui::NativeTheme::kColorId_LabelEnabledColor);
+
+  colors_[ThemeProperties::COLOR_TOOLBAR_BUTTON_ICON] =
+      color_utils::DeriveDefaultIconColor(label_color);
+
+  colors_[ThemeProperties::COLOR_TAB_TEXT] = label_color;
+  colors_[ThemeProperties::COLOR_BOOKMARK_TEXT] = label_color;
+  colors_[ThemeProperties::COLOR_BACKGROUND_TAB_TEXT] = label_color;
+
+  inactive_selection_bg_color_ = native_theme_->GetSystemColor(
+      ui::NativeTheme::kColorId_TextfieldReadOnlyBackground);
+  inactive_selection_fg_color_ = native_theme_->GetSystemColor(
+      ui::NativeTheme::kColorId_TextfieldReadOnlyColor);
+
+  // We pick the text and background colors for the NTP out of the
+  // colors for a GtkEntry. We do this because GtkEntries background
+  // color is never the same as |tab_color|, is usually a white,
+  // and when it isn't a white, provides sufficient contrast to
+  // |tab_color|. Try this out with Darklooks, HighContrastInverse
+  // or ThinIce.
   colors_[ThemeProperties::COLOR_NTP_BACKGROUND] =
       native_theme_->GetSystemColor(
           ui::NativeTheme::kColorId_TextfieldDefaultBackground);
   colors_[ThemeProperties::COLOR_NTP_TEXT] = native_theme_->GetSystemColor(
       ui::NativeTheme::kColorId_TextfieldDefaultColor);
+  // The NTP header is the color that surrounds the current active
+  // thumbnail on the NTP, and acts as the border of the "Recent
+  // Links" box. It would be awesome if they were separated so we
+  // could use GetBorderColor() for the border around the "Recent
+  // Links" section, but matching the frame color is more important.
   colors_[ThemeProperties::COLOR_NTP_HEADER] =
-      GetBorderColor("GtkButton#button");
+      colors_[ThemeProperties::COLOR_FRAME];
 
-  SkColor tab_text_color = GetFgColor("GtkLabel");
-  colors_[ThemeProperties::COLOR_TOOLBAR_BUTTON_ICON] = tab_text_color;
-  colors_[ThemeProperties::COLOR_TAB_TEXT] = tab_text_color;
-  colors_[ThemeProperties::COLOR_BOOKMARK_TEXT] = tab_text_color;
-
-  colors_[ThemeProperties::COLOR_BACKGROUND_TAB] = SK_ColorTRANSPARENT;
-  colors_[ThemeProperties::COLOR_BACKGROUND_TAB_INACTIVE] = SK_ColorTRANSPARENT;
-  colors_[ThemeProperties::COLOR_BACKGROUND_TAB_INCOGNITO] =
-      SK_ColorTRANSPARENT;
-  colors_[ThemeProperties::COLOR_BACKGROUND_TAB_INCOGNITO_INACTIVE] =
-      SK_ColorTRANSPARENT;
+  colors_[ThemeProperties::COLOR_TOOLBAR] = tab_color;
+  //colors_[ThemeProperties::COLOR_CONTROL_BACKGROUND] = tab_color;
 
   colors_[ThemeProperties::COLOR_NTP_LINK] = native_theme_->GetSystemColor(
       ui::NativeTheme::kColorId_TextfieldSelectionBackgroundFocused);
 
-  // Generate the colors that we pass to Blink.
   focus_ring_color_ = native_theme_->GetSystemColor(
       ui::NativeTheme::kColorId_FocusedBorderColor);
 
@@ -939,107 +953,6 @@ void GtkUi::UpdateColors() {
   colors_[ThemeProperties::COLOR_TAB_THROBBER_WAITING] =
       native_theme_->GetSystemColor(
           ui::NativeTheme::kColorId_ThrobberWaitingColor);
-
-  // Generate colors that depend on whether or not a custom window frame is
-  // used.  These colors belong in |color_map| below, not |colors_|.
-  for (bool custom_frame : {false, true}) {
-    ColorMap& color_map =
-        custom_frame ? custom_frame_colors_ : native_frame_colors_;
-    const std::string header_selector =
-        custom_frame ? "#headerbar.header-bar.titlebar" : "GtkMenuBar#menubar";
-    const std::string header_selector_inactive = header_selector + ":backdrop";
-    const SkColor frame_color =
-        SkColorSetA(GetBgColor(header_selector), SK_AlphaOPAQUE);
-    const SkColor frame_color_incognito =
-        color_utils::HSLShift(frame_color, kDefaultTintFrameIncognito);
-    const SkColor frame_color_inactive =
-        SkColorSetA(GetBgColor(header_selector_inactive), SK_AlphaOPAQUE);
-    const SkColor frame_color_incognito_inactive =
-        color_utils::HSLShift(frame_color_inactive, kDefaultTintFrameIncognito);
-
-    color_map[ThemeProperties::COLOR_FRAME] = frame_color;
-    color_map[ThemeProperties::COLOR_FRAME_INACTIVE] = frame_color_inactive;
-    color_map[ThemeProperties::COLOR_FRAME_INCOGNITO] = frame_color_incognito;
-    color_map[ThemeProperties::COLOR_FRAME_INCOGNITO_INACTIVE] =
-        frame_color_incognito_inactive;
-
-    // Compose the window color on the frame color to ensure the resulting tab
-    // color is opaque.
-    SkColor tab_color =
-        color_utils::GetResultingPaintColor(GetBgColor(""), frame_color);
-
-    color_map[ThemeProperties::COLOR_TOOLBAR] = tab_color;
-    color_map[ThemeProperties::COLOR_DOWNLOAD_SHELF] = tab_color;
-    color_map[ThemeProperties::COLOR_INFOBAR] = tab_color;
-    color_map[ThemeProperties::COLOR_STATUS_BUBBLE] = tab_color;
-
-    const SkColor background_tab_text_color =
-        GetFgColor(header_selector + " GtkLabel.title");
-    const SkColor background_tab_text_color_inactive =
-        GetFgColor(header_selector_inactive + " GtkLabel.title");
-
-    color_map[ThemeProperties::COLOR_BACKGROUND_TAB_TEXT] =
-        background_tab_text_color;
-    color_map[ThemeProperties::COLOR_BACKGROUND_TAB_TEXT_INCOGNITO] =
-        color_utils::BlendForMinContrast(
-            color_utils::HSLShift(background_tab_text_color,
-                                  kDefaultTintFrameIncognito),
-            frame_color_incognito)
-            .color;
-    color_map[ThemeProperties::COLOR_BACKGROUND_TAB_TEXT_INACTIVE] =
-        background_tab_text_color_inactive;
-    color_map[ThemeProperties::COLOR_BACKGROUND_TAB_TEXT_INCOGNITO_INACTIVE] =
-        color_utils::BlendForMinContrast(
-            color_utils::HSLShift(background_tab_text_color_inactive,
-                                  kDefaultTintFrameIncognito),
-            frame_color_incognito_inactive)
-            .color;
-
-    color_map[ThemeProperties::COLOR_OMNIBOX_TEXT] =
-        native_theme_->GetSystemColor(
-            ui::NativeTheme::kColorId_TextfieldDefaultColor);
-    color_map[ThemeProperties::COLOR_OMNIBOX_BACKGROUND] =
-        native_theme_->GetSystemColor(
-            ui::NativeTheme::kColorId_TextfieldDefaultBackground);
-
-    // These colors represent the border drawn around tabs and between
-    // the tabstrip and toolbar.
-    SkColor toolbar_top_separator = GetBorderColor(
-        header_selector + " GtkSeparator#separator.vertical.titlebutton");
-    SkColor toolbar_top_separator_inactive =
-        GetBorderColor(header_selector +
-                       ":backdrop GtkSeparator#separator.vertical.titlebutton");
-
-    auto toolbar_top_separator_has_good_contrast = [&]() {
-      // This constant is copied from chrome/browser/themes/theme_service.cc.
-      const float kMinContrastRatio = 2.f;
-
-      SkColor active = color_utils::GetResultingPaintColor(
-          toolbar_top_separator, frame_color);
-      SkColor inactive = color_utils::GetResultingPaintColor(
-          toolbar_top_separator_inactive, frame_color_inactive);
-      return color_utils::GetContrastRatio(frame_color, active) >=
-                 kMinContrastRatio &&
-             color_utils::GetContrastRatio(frame_color_inactive, inactive) >=
-                 kMinContrastRatio;
-    };
-
-    if (!toolbar_top_separator_has_good_contrast()) {
-      toolbar_top_separator =
-          GetBorderColor(header_selector + " GtkButton#button");
-      toolbar_top_separator_inactive =
-          GetBorderColor(header_selector + ":backdrop GtkButton#button");
-    }
-
-    // If we can't get a contrasting stroke from the theme, have ThemeService
-    // provide a stroke color for us.
-    if (toolbar_top_separator_has_good_contrast()) {
-      color_map[ThemeProperties::COLOR_TOOLBAR_TOP_SEPARATOR] =
-          toolbar_top_separator;
-      color_map[ThemeProperties::COLOR_TOOLBAR_TOP_SEPARATOR_INACTIVE] =
-          toolbar_top_separator_inactive;
-    }
-  }
 }
 
 void GtkUi::UpdateDefaultFont() {
@@ -1092,12 +1005,10 @@ float GtkUi::GetRawDeviceScaleFactor() {
   if (display::Display::HasForceDeviceScaleFactor())
     return display::Display::GetForcedDeviceScaleFactor();
 
-  GdkScreen* screen = gdk_screen_get_default();
-  gint scale = gtk_widget_get_scale_factor(fake_window_);
-  DCHECK_GT(scale, 0);
-  gdouble resolution = gdk_screen_get_resolution(screen);
-  const float scale_factor =
-      resolution <= 0 ? scale : resolution * scale / kDefaultDPI;
+  GtkSettings* gtk_settings = gtk_settings_get_default();
+  gint gtk_dpi = -1;
+  g_object_get(gtk_settings, "gtk-xft-dpi", &gtk_dpi, nullptr);
+  const float scale_factor = gtk_dpi / (1024 * kDefaultDPI);
 
   // Blacklist scaling factors <120% (crbug.com/484400) and round
   // to 1 decimal to prevent rendering problems (crbug.com/485183).
diff --git a/chrome/browser/ui/gtk/gtk_ui.h b/chrome/browser/ui/gtk/gtk_ui.h
index 73de1b731655..0c519f302e9a 100644
--- a/chrome/browser/ui/gtk/gtk_ui.h
+++ b/chrome/browser/ui/gtk/gtk_ui.h
@@ -145,6 +145,10 @@ class GtkUi : public views::LinuxUI {
   // Updates |default_font_*|.
   void UpdateDefaultFont();
 
+  // Gets a ChromeGtkFrame theme color; returns true on success.  No-op on gtk3.
+  bool GetChromeStyleColor(const char* sytle_property,
+                           SkColor* ret_color) const;
+
   float GetRawDeviceScaleFactor();
 
   NativeThemeGtk* native_theme_;
diff --git a/chrome/browser/ui/gtk/gtk_util.cc b/chrome/browser/ui/gtk/gtk_util.cc
index 2bd955b42932..d0f03fc6458c 100644
--- a/chrome/browser/ui/gtk/gtk_util.cc
+++ b/chrome/browser/ui/gtk/gtk_util.cc
@@ -194,397 +194,6 @@ void ParseButtonLayout(const std::string& button_string,
   }
 }
 
-namespace {
-
-float GetDeviceScaleFactor() {
-  views::LinuxUI* linux_ui = views::LinuxUI::instance();
-  return linux_ui ? linux_ui->GetDeviceScaleFactor() : 1;
-}
-
-}  // namespace
-
-void* GetGtkSharedLibrary() {
-  std::string lib_name =
-      "libgtk-" + base::NumberToString(GTK_MAJOR_VERSION) + ".so.0";
-  static void* gtk_lib = dlopen(lib_name.c_str(), RTLD_LAZY);
-  DCHECK(gtk_lib);
-  return gtk_lib;
-}
-
-CairoSurface::CairoSurface(SkBitmap& bitmap)
-    : surface_(cairo_image_surface_create_for_data(
-          static_cast<unsigned char*>(bitmap.getAddr(0, 0)),
-          CAIRO_FORMAT_ARGB32,
-          bitmap.width(),
-          bitmap.height(),
-          cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32, bitmap.width()))),
-      cairo_(cairo_create(surface_)) {}
-
-CairoSurface::CairoSurface(const gfx::Size& size)
-    : surface_(cairo_image_surface_create(CAIRO_FORMAT_ARGB32,
-                                          size.width(),
-                                          size.height())),
-      cairo_(cairo_create(surface_)) {
-  DCHECK(cairo_surface_status(surface_) == CAIRO_STATUS_SUCCESS);
-  // Clear the surface.
-  cairo_save(cairo_);
-  cairo_set_source_rgba(cairo_, 0, 0, 0, 0);
-  cairo_set_operator(cairo_, CAIRO_OPERATOR_SOURCE);
-  cairo_paint(cairo_);
-  cairo_restore(cairo_);
-}
-
-CairoSurface::~CairoSurface() {
-  cairo_destroy(cairo_);
-  cairo_surface_destroy(surface_);
-}
-
-SkColor CairoSurface::GetAveragePixelValue(bool frame) {
-  cairo_surface_flush(surface_);
-  SkColor* data =
-      reinterpret_cast<SkColor*>(cairo_image_surface_get_data(surface_));
-  int width = cairo_image_surface_get_width(surface_);
-  int height = cairo_image_surface_get_height(surface_);
-  DCHECK(4 * width == cairo_image_surface_get_stride(surface_));
-  long a = 0, r = 0, g = 0, b = 0;
-  unsigned int max_alpha = 0;
-  for (int i = 0; i < width * height; i++) {
-    SkColor color = data[i];
-    max_alpha = std::max(SkColorGetA(color), max_alpha);
-    a += SkColorGetA(color);
-    r += SkColorGetR(color);
-    g += SkColorGetG(color);
-    b += SkColorGetB(color);
-  }
-  if (a == 0)
-    return SK_ColorTRANSPARENT;
-  return SkColorSetARGB(frame ? max_alpha : a / (width * height), r * 255 / a,
-                        g * 255 / a, b * 255 / a);
-}
-
-bool GtkVersionCheck(int major, int minor, int micro) {
-  static int actual_major = gtk_get_major_version();
-  if (actual_major > major)
-    return true;
-  else if (actual_major < major)
-    return false;
-
-  static int actual_minor = gtk_get_minor_version();
-  if (actual_minor > minor)
-    return true;
-  else if (actual_minor < minor)
-    return false;
-
-  static int actual_micro = gtk_get_micro_version();
-  if (actual_micro >= micro)
-    return true;
-  else
-    return false;
-}
-
-GtkStateFlags StateToStateFlags(ui::NativeTheme::State state) {
-  switch (state) {
-    case ui::NativeTheme::kDisabled:
-      return GTK_STATE_FLAG_INSENSITIVE;
-    case ui::NativeTheme::kHovered:
-      return GTK_STATE_FLAG_PRELIGHT;
-    case ui::NativeTheme::kNormal:
-      return GTK_STATE_FLAG_NORMAL;
-    case ui::NativeTheme::kPressed:
-      return static_cast<GtkStateFlags>(GTK_STATE_FLAG_PRELIGHT |
-                                        GTK_STATE_FLAG_ACTIVE);
-    default:
-      NOTREACHED();
-      return GTK_STATE_FLAG_NORMAL;
-  }
-}
-
-NO_SANITIZE("cfi-icall")
-ScopedStyleContext AppendCssNodeToStyleContext(GtkStyleContext* context,
-                                               const std::string& css_node) {
-  GtkWidgetPath* path =
-      context ? gtk_widget_path_copy(gtk_style_context_get_path(context))
-              : gtk_widget_path_new();
-
-  enum {
-    CSS_TYPE,
-    CSS_NAME,
-    CSS_CLASS,
-    CSS_PSEUDOCLASS,
-  } part_type = CSS_TYPE;
-  static const struct {
-    const char* name;
-    GtkStateFlags state_flag;
-  } pseudo_classes[] = {
-      {"active", GTK_STATE_FLAG_ACTIVE},
-      {"hover", GTK_STATE_FLAG_PRELIGHT},
-      {"selected", GTK_STATE_FLAG_SELECTED},
-      {"disabled", GTK_STATE_FLAG_INSENSITIVE},
-      {"indeterminate", GTK_STATE_FLAG_INCONSISTENT},
-      {"focus", GTK_STATE_FLAG_FOCUSED},
-      {"backdrop", GTK_STATE_FLAG_BACKDROP},
-      {"link", GTK_STATE_FLAG_LINK},
-      {"visited", GTK_STATE_FLAG_VISITED},
-      {"checked", GTK_STATE_FLAG_CHECKED},
-  };
-  GtkStateFlags state = GTK_STATE_FLAG_NORMAL;
-  base::StringTokenizer t(css_node, ".:#");
-  t.set_options(base::StringTokenizer::RETURN_DELIMS);
-  while (t.GetNext()) {
-    if (t.token_is_delim()) {
-      if (t.token_begin() == css_node.begin()) {
-        // Special case for the first token.
-        gtk_widget_path_append_type(path, G_TYPE_NONE);
-      }
-      switch (*t.token_begin()) {
-        case '#':
-          part_type = CSS_NAME;
-          break;
-        case '.':
-          part_type = CSS_CLASS;
-          break;
-        case ':':
-          part_type = CSS_PSEUDOCLASS;
-          break;
-        default:
-          NOTREACHED();
-      }
-    } else {
-      using GtkSetObjectName = void (*)(GtkWidgetPath*, gint, const char*);
-      static GtkSetObjectName _gtk_widget_path_iter_set_object_name =
-          reinterpret_cast<GtkSetObjectName>(dlsym(
-              GetGtkSharedLibrary(), "gtk_widget_path_iter_set_object_name"));
-      switch (part_type) {
-        case CSS_NAME: {
-          if (GtkVersionCheck(3, 20)) {
-            _gtk_widget_path_iter_set_object_name(path, -1, t.token().c_str());
-          } else {
-            gtk_widget_path_iter_add_class(path, -1, t.token().c_str());
-          }
-          break;
-        }
-        case CSS_TYPE: {
-          GType type = g_type_from_name(t.token().c_str());
-          DCHECK(type);
-          gtk_widget_path_append_type(path, type);
-          if (GtkVersionCheck(3, 20)) {
-            if (t.token() == "GtkLabel")
-              _gtk_widget_path_iter_set_object_name(path, -1, "label");
-          }
-          break;
-        }
-        case CSS_CLASS: {
-          gtk_widget_path_iter_add_class(path, -1, t.token().c_str());
-          break;
-        }
-        case CSS_PSEUDOCLASS: {
-          GtkStateFlags state_flag = GTK_STATE_FLAG_NORMAL;
-          for (const auto& pseudo_class_entry : pseudo_classes) {
-            if (strcmp(pseudo_class_entry.name, t.token().c_str()) == 0) {
-              state_flag = pseudo_class_entry.state_flag;
-              break;
-            }
-          }
-          state = static_cast<GtkStateFlags>(state | state_flag);
-          break;
-        }
-      }
-    }
-  }
-
-  // Always add a "chromium" class so that themes can style chromium
-  // widgets specially if they want to.
-  gtk_widget_path_iter_add_class(path, -1, "chromium");
-
-  if (GtkVersionCheck(3, 14)) {
-    using GtkSetState = void (*)(GtkWidgetPath*, gint, GtkStateFlags);
-    static GtkSetState _gtk_widget_path_iter_set_state =
-        reinterpret_cast<GtkSetState>(
-            dlsym(GetGtkSharedLibrary(), "gtk_widget_path_iter_set_state"));
-    DCHECK(_gtk_widget_path_iter_set_state);
-    _gtk_widget_path_iter_set_state(path, -1, state);
-  }
-
-  ScopedStyleContext child_context(gtk_style_context_new());
-  gtk_style_context_set_path(child_context, path);
-  if (GtkVersionCheck(3, 14)) {
-    gtk_style_context_set_state(child_context, state);
-  } else {
-    GtkStateFlags child_state = state;
-    if (context) {
-      child_state = static_cast<GtkStateFlags>(
-          child_state | gtk_style_context_get_state(context));
-    }
-    gtk_style_context_set_state(child_context, child_state);
-  }
-  gtk_style_context_set_scale(child_context, std::ceil(GetDeviceScaleFactor()));
-  gtk_style_context_set_parent(child_context, context);
-  gtk_widget_path_unref(path);
-  return child_context;
-}
-
-ScopedStyleContext GetStyleContextFromCss(const std::string& css_selector) {
-  // Prepend a window node to the selector since all widgets must live
-  // in a window, but we don't want to specify that every time.
-  auto context =
-      AppendCssNodeToStyleContext(nullptr, "GtkWindow#window.background");
-
-  for (const auto& widget_type :
-       base::SplitString(css_selector, base::kWhitespaceASCII,
-                         base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY)) {
-    context = AppendCssNodeToStyleContext(context, widget_type);
-  }
-  return context;
-}
-
-SkColor GdkRgbaToSkColor(const GdkRGBA& color) {
-  return SkColorSetARGB(color.alpha * 255, color.red * 255, color.green * 255,
-                        color.blue * 255);
-}
-
-SkColor GetFgColorFromStyleContext(GtkStyleContext* context) {
-  GdkRGBA color;
-#if GTK_CHECK_VERSION(3, 90, 0)
-  gtk_style_context_get_color(context, &color);
-#else
-  gtk_style_context_get_color(context, gtk_style_context_get_state(context),
-                              &color);
-#endif
-  return GdkRgbaToSkColor(color);
-}
-
-SkColor GetBgColorFromStyleContext(GtkStyleContext* context) {
-  // Backgrounds are more general than solid colors (eg. gradients),
-  // but chromium requires us to boil this down to one color.  We
-  // cannot use the background-color here because some themes leave it
-  // set to a garbage color because a background-image will cover it
-  // anyway.  So we instead render the background into a 24x24 bitmap,
-  // removing any borders, and hope that we get a good color.
-  ApplyCssToContext(context,
-                    "* {"
-                    "border-radius: 0px;"
-                    "border-style: none;"
-                    "box-shadow: none;"
-                    "}");
-  gfx::Size size(24, 24);
-  CairoSurface surface(size);
-  RenderBackground(size, surface.cairo(), context);
-  return surface.GetAveragePixelValue(false);
-}
-
-SkColor GetFgColor(const std::string& css_selector) {
-  return GetFgColorFromStyleContext(GetStyleContextFromCss(css_selector));
-}
-
-ScopedCssProvider GetCssProvider(const std::string& css) {
-  GtkCssProvider* provider = gtk_css_provider_new();
-#if GTK_CHECK_VERSION(3, 90, 0)
-  gtk_css_provider_load_from_data(provider, css.c_str(), -1);
-#else
-  GError* error = nullptr;
-  gtk_css_provider_load_from_data(provider, css.c_str(), -1, &error);
-  DCHECK(!error);
-#endif
-  return ScopedCssProvider(provider);
-}
-
-void ApplyCssProviderToContext(GtkStyleContext* context,
-                               GtkCssProvider* provider) {
-  while (context) {
-    gtk_style_context_add_provider(context, GTK_STYLE_PROVIDER(provider),
-                                   G_MAXUINT);
-    context = gtk_style_context_get_parent(context);
-  }
-}
-
-void ApplyCssToContext(GtkStyleContext* context, const std::string& css) {
-  auto provider = GetCssProvider(css);
-  ApplyCssProviderToContext(context, provider);
-}
-
-void RenderBackground(const gfx::Size& size,
-                      cairo_t* cr,
-                      GtkStyleContext* context) {
-  if (!context)
-    return;
-  RenderBackground(size, cr, gtk_style_context_get_parent(context));
-  gtk_render_background(context, cr, 0, 0, size.width(), size.height());
-}
-
-SkColor GetBgColor(const std::string& css_selector) {
-  return GetBgColorFromStyleContext(GetStyleContextFromCss(css_selector));
-}
-
-SkColor GetBorderColor(const std::string& css_selector) {
-  // Borders have the same issue as backgrounds, due to the
-  // border-image property.
-  auto context = GetStyleContextFromCss(css_selector);
-  gfx::Size size(24, 24);
-  CairoSurface surface(size);
-  gtk_render_frame(context, surface.cairo(), 0, 0, size.width(), size.height());
-  return surface.GetAveragePixelValue(true);
-}
-
-SkColor GetSelectionBgColor(const std::string& css_selector) {
-  auto context = GetStyleContextFromCss(css_selector);
-  if (GtkVersionCheck(3, 20))
-    return GetBgColorFromStyleContext(context);
-  // This is verbatim how Gtk gets the selection color on versions before 3.20.
-  GdkRGBA selection_color;
-  G_GNUC_BEGIN_IGNORE_DEPRECATIONS;
-#if GTK_CHECK_VERSION(3, 90, 0)
-  gtk_style_context_get_background_color(context, &selection_color);
-#else
-  gtk_style_context_get_background_color(
-      context, gtk_style_context_get_state(context), &selection_color);
-#endif
-  G_GNUC_END_IGNORE_DEPRECATIONS;
-  return GdkRgbaToSkColor(selection_color);
-}
-
-bool ContextHasClass(GtkStyleContext* context, const std::string& style_class) {
-  return gtk_style_context_has_class(context, style_class.c_str()) ||
-         gtk_widget_path_iter_has_class(gtk_style_context_get_path(context), -1,
-                                        style_class.c_str());
-}
-
-SkColor GetSeparatorColor(const std::string& css_selector) {
-  if (!GtkVersionCheck(3, 20))
-    return GetFgColor(css_selector);
-
-  auto context = GetStyleContextFromCss(css_selector);
-  int w = 1, h = 1;
-  GtkBorder border, padding;
-#if GTK_CHECK_VERSION(3, 90, 0)
-  gtk_style_context_get(context, "min-width", &w, "min-height", &h, nullptr);
-  gtk_style_context_get_border(context, &border);
-  gtk_style_context_get_padding(context, &padding);
-#else
-  gtk_style_context_get(context, gtk_style_context_get_state(context),
-                        "min-width", &w, "min-height", &h, nullptr);
-  GtkStateFlags state = gtk_style_context_get_state(context);
-  gtk_style_context_get_border(context, state, &border);
-  gtk_style_context_get_padding(context, state, &padding);
-#endif
-  w += border.left + padding.left + padding.right + border.right;
-  h += border.top + padding.top + padding.bottom + border.bottom;
-
-  bool horizontal = ContextHasClass(context, "horizontal");
-  if (horizontal) {
-    w = 24;
-    h = std::max(h, 1);
-  } else {
-    DCHECK(ContextHasClass(context, "vertical"));
-    h = 24;
-    w = std::max(w, 1);
-  }
-
-  CairoSurface surface(gfx::Size(w, h));
-  gtk_render_background(context, surface.cairo(), 0, 0, w, h);
-  gtk_render_frame(context, surface.cairo(), 0, 0, w, h);
-  return surface.GetAveragePixelValue(false);
-}
-
 std::string GetGtkSettingsStringProperty(GtkSettings* settings,
                                          const gchar* prop_name) {
   GValue layout = G_VALUE_INIT;
@@ -624,12 +233,12 @@ GdkEvent* GdkEventFromKeyEvent(const ui::KeyEvent& key_event) {
 
   // Get keyval and state
   GdkModifierType state = ExtractGdkEventStateFromKeyEvent(key_event);
-  guint keyval = GDK_KEY_VoidSymbol;
+  guint keyval = 0;
   GdkModifierType consumed;
   gdk_keymap_translate_keyboard_state(keymap, hw_code, state, group, &keyval,
                                       nullptr, nullptr, &consumed);
   gdk_keymap_add_virtual_modifiers(keymap, &state);
-  DCHECK(keyval != GDK_KEY_VoidSymbol);
+  DCHECK(keyval != 0);
 
   // Build GdkEvent
   GdkEvent* gdk_event = gdk_event_new(event_type);
diff --git a/chrome/browser/ui/gtk/gtk_util.h b/chrome/browser/ui/gtk/gtk_util.h
index e8f6a1bd938a..e06540f98f3d 100644
--- a/chrome/browser/ui/gtk/gtk_util.h
+++ b/chrome/browser/ui/gtk/gtk_util.h
@@ -54,121 +54,6 @@ void ParseButtonLayout(const std::string& button_string,
                        std::vector<views::FrameButton>* leading_buttons,
                        std::vector<views::FrameButton>* trailing_buttons);
 
-void* GetGtkSharedLibrary();
-
-class CairoSurface {
- public:
-  // Attaches a cairo surface to an SkBitmap so that GTK can render
-  // into it.  |bitmap| must outlive this CairoSurface.
-  explicit CairoSurface(SkBitmap& bitmap);
-
-  // Creates a new cairo surface with the given size.  The memory for
-  // this surface is deallocated when this CairoSurface is destroyed.
-  explicit CairoSurface(const gfx::Size& size);
-
-  ~CairoSurface();
-
-  // Get the drawing context for GTK to use.
-  cairo_t* cairo() { return cairo_; }
-
-  // Returns the average of all pixels in the surface.  If |frame| is
-  // true, the resulting alpha will be the average alpha, otherwise it
-  // will be the max alpha across all pixels.
-  SkColor GetAveragePixelValue(bool frame);
-
- private:
-  cairo_surface_t* surface_;
-  cairo_t* cairo_;
-};
-
-// Returns true iff the runtime version of Gtk used meets
-// |major|.|minor|.|micro|.
-bool GtkVersionCheck(int major, int minor = 0, int micro = 0);
-
-using ScopedStyleContext = ScopedGObject<GtkStyleContext>;
-using ScopedCssProvider = ScopedGObject<GtkCssProvider>;
-
-}  // namespace gtk
-
-// Template override cannot be in the gtk namespace.
-template <>
-inline void gtk::ScopedStyleContext::Unref() {
-  // Versions of GTK earlier than 3.15.4 had a bug where a g_assert
-  // would be triggered when trying to free a GtkStyleContext that had
-  // a parent whose only reference was the child context in question.
-  // This is a hack to work around that case.  See GTK commit
-  // "gtkstylecontext: Don't try to emit a signal when finalizing".
-  GtkStyleContext* context = obj_;
-  while (context) {
-    GtkStyleContext* parent = gtk_style_context_get_parent(context);
-    if (parent && G_OBJECT(context)->ref_count == 1 &&
-        !gtk::GtkVersionCheck(3, 15, 4)) {
-      g_object_ref(parent);
-      gtk_style_context_set_parent(context, nullptr);
-      g_object_unref(context);
-    } else {
-      g_object_unref(context);
-      return;
-    }
-    context = parent;
-  }
-}
-
-namespace gtk {
-
-// Converts ui::NativeTheme::State to GtkStateFlags.
-GtkStateFlags StateToStateFlags(ui::NativeTheme::State state);
-
-// If |context| is nullptr, creates a new top-level style context
-// specified by parsing |css_node|.  Otherwise, creates the child
-// context with |context| as the parent.
-ScopedStyleContext AppendCssNodeToStyleContext(GtkStyleContext* context,
-                                               const std::string& css_node);
-
-// Parses |css_selector| into a GtkStyleContext.  The format is a
-// sequence of whitespace-separated objects.  Each object may have at
-// most one object name at the beginning of the string, and any number
-// of '.'-prefixed classes and ':'-prefixed pseudoclasses.  An example
-// is "GtkButton.button.suggested-action:hover:active".  The caller
-// must g_object_unref() the returned context.
-ScopedStyleContext GetStyleContextFromCss(const std::string& css_selector);
-
-SkColor GetFgColorFromStyleContext(GtkStyleContext* context);
-
-SkColor GetBgColorFromStyleContext(GtkStyleContext* context);
-
-// Overrides properties on |context| and all its parents with those
-// provided by |css|.
-void ApplyCssToContext(GtkStyleContext* context, const std::string& css);
-
-// Get the 'color' property from the style context created by
-// GetStyleContextFromCss(|css_selector|).
-SkColor GetFgColor(const std::string& css_selector);
-
-ScopedCssProvider GetCssProvider(const std::string& css);
-
-// Renders the backgrounds of all ancestors of |context|, then renders
-// the background for |context| itself.
-void RenderBackground(const gfx::Size& size,
-                      cairo_t* cr,
-                      GtkStyleContext* context);
-
-// Renders a background from the style context created by
-// GetStyleContextFromCss(|css_selector|) into a 24x24 bitmap and
-// returns the average color.
-SkColor GetBgColor(const std::string& css_selector);
-
-// Renders the border from the style context created by
-// GetStyleContextFromCss(|css_selector|) into a 24x24 bitmap and
-// returns the average color.
-SkColor GetBorderColor(const std::string& css_selector);
-
-// On Gtk3.20 or later, behaves like GetBgColor.  Otherwise, returns
-// the background-color property.
-SkColor GetSelectionBgColor(const std::string& css_selector);
-
-// Get the color of the GtkSeparator specified by |css_selector|.
-SkColor GetSeparatorColor(const std::string& css_selector);
 
 // Get a GtkSettings property as a C++ string.
 std::string GetGtkSettingsStringProperty(GtkSettings* settings,
diff --git a/chrome/browser/ui/gtk/input_method_context_impl_gtk.cc b/chrome/browser/ui/gtk/input_method_context_impl_gtk.cc
index 848f213b1667..a308b966d747 100644
--- a/chrome/browser/ui/gtk/input_method_context_impl_gtk.cc
+++ b/chrome/browser/ui/gtk/input_method_context_impl_gtk.cc
@@ -117,7 +117,7 @@ bool InputMethodContextImplGtk::DispatchKeyEvent(
   gint win_y = 0;
   gdk_window_get_origin(target_window, &win_x, &win_y);
 
-  gint factor = gdk_window_get_scale_factor(target_window);
+  gint factor = 1; // fuck HiDPI
   gint caret_x = last_caret_bounds_.x() / factor;
   gint caret_y = last_caret_bounds_.y() / factor;
   gint caret_w = last_caret_bounds_.width() / factor;
diff --git a/chrome/browser/ui/gtk/input_method_context_impl_gtk.h b/chrome/browser/ui/gtk/input_method_context_impl_gtk.h
index fc09a5b79379..0a9d9dba088f 100644
--- a/chrome/browser/ui/gtk/input_method_context_impl_gtk.h
+++ b/chrome/browser/ui/gtk/input_method_context_impl_gtk.h
@@ -12,7 +12,7 @@
 #include "ui/base/ime/linux/linux_input_method_context.h"
 #include "ui/gfx/geometry/rect.h"
 
-typedef struct _GdkWindow GdkWindow;
+typedef struct _GdkDrawable GdkWindow;
 typedef struct _GtkIMContext GtkIMContext;
 
 namespace gtk {
diff --git a/chrome/browser/ui/gtk/native_theme_gtk.cc b/chrome/browser/ui/gtk/native_theme_gtk.cc
index 26f1842494bd..efe383e94a2d 100644
--- a/chrome/browser/ui/gtk/native_theme_gtk.cc
+++ b/chrome/browser/ui/gtk/native_theme_gtk.cc
@@ -1,4 +1,4 @@
-// Copyright 2016 The Chromium Authors. All rights reserved.
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
@@ -6,334 +6,54 @@
 
 #include <gtk/gtk.h>
 
+#include "chrome/browser/ui/gtk/chrome_gtk_frame.h"
+#include "chrome/browser/ui/gtk/chrome_gtk_menu_subclasses.h"
+#include "chrome/browser/ui/gtk/gtk_ui.h"
 #include "chrome/browser/ui/gtk/gtk_util.h"
+#include "chrome/browser/ui/gtk/skia_utils_gtk.h"
+#include "third_party/skia/include/core/SkColor.h"
 #include "ui/gfx/color_palette.h"
 #include "ui/gfx/color_utils.h"
 #include "ui/gfx/geometry/rect.h"
-#include "ui/gfx/skbitmap_operations.h"
+#include "ui/gfx/geometry/size.h"
 #include "ui/gfx/skia_util.h"
+#include "ui/native_theme/common_theme.h"
+#include "ui/native_theme/native_theme_aura.h"
 #include "ui/native_theme/native_theme_dark_aura.h"
 
 namespace gtk {
 
 namespace {
 
-enum BackgroundRenderMode {
-  BG_RENDER_NORMAL,
-  BG_RENDER_NONE,
-  BG_RENDER_RECURSIVE,
+enum WidgetState {
+  NORMAL = 0,
+  ACTIVE = 1,
+  PRELIGHT = 2,
+  SELECTED = 3,
+  INSENSITIVE = 4,
 };
 
-ScopedStyleContext GetTooltipContext() {
-  return AppendCssNodeToStyleContext(
-      nullptr, GtkVersionCheck(3, 20) ? "#tooltip.background"
-                                      : "GtkWindow#window.background.tooltip");
+// Same order as enum WidgetState above
+const GtkStateType stateMap[] = {
+    GTK_STATE_NORMAL,   GTK_STATE_ACTIVE,      GTK_STATE_PRELIGHT,
+    GTK_STATE_SELECTED, GTK_STATE_INSENSITIVE,
+};
+
+SkColor GetFgColor(GtkWidget* widget, WidgetState state) {
+  return GdkColorToSkColor(gtk_rc_get_style(widget)->fg[stateMap[state]]);
+}
+SkColor GetBgColor(GtkWidget* widget, WidgetState state) {
+  return GdkColorToSkColor(gtk_rc_get_style(widget)->bg[stateMap[state]]);
 }
 
-SkBitmap GetWidgetBitmap(const gfx::Size& size,
-                         GtkStyleContext* context,
-                         BackgroundRenderMode bg_mode,
-                         bool render_frame) {
-  DCHECK(bg_mode != BG_RENDER_NONE || render_frame);
-  SkBitmap bitmap;
-  bitmap.allocN32Pixels(size.width(), size.height());
-  bitmap.eraseColor(0);
-
-  CairoSurface surface(bitmap);
-  cairo_t* cr = surface.cairo();
-
-  switch (bg_mode) {
-    case BG_RENDER_NORMAL:
-      gtk_render_background(context, cr, 0, 0, size.width(), size.height());
-      break;
-    case BG_RENDER_RECURSIVE:
-      RenderBackground(size, cr, context);
-      break;
-    case BG_RENDER_NONE:
-      break;
-  }
-  if (render_frame)
-    gtk_render_frame(context, cr, 0, 0, size.width(), size.height());
-  bitmap.setImmutable();
-  return bitmap;
+SkColor GetTextColor(GtkWidget* widget, WidgetState state) {
+  return GdkColorToSkColor(gtk_rc_get_style(widget)->text[stateMap[state]]);
 }
-
-void PaintWidget(cc::PaintCanvas* canvas,
-                 const gfx::Rect& rect,
-                 GtkStyleContext* context,
-                 BackgroundRenderMode bg_mode,
-                 bool render_frame) {
-  canvas->drawImage(cc::PaintImage::CreateFromBitmap(GetWidgetBitmap(
-                        rect.size(), context, bg_mode, render_frame)),
-                    rect.x(), rect.y());
+SkColor GetTextAAColor(GtkWidget* widget, WidgetState state) {
+  return GdkColorToSkColor(gtk_rc_get_style(widget)->text_aa[stateMap[state]]);
 }
-
-SkColor SkColorFromColorId(ui::NativeTheme::ColorId color_id) {
-  switch (color_id) {
-    // Windows
-    case ui::NativeTheme::kColorId_WindowBackground:
-    // Dialogs
-    case ui::NativeTheme::kColorId_DialogBackground:
-    case ui::NativeTheme::kColorId_BubbleBackground:
-      return GetBgColor("");
-    case ui::NativeTheme::kColorId_DialogForeground:
-      return GetFgColor("GtkLabel");
-    case ui::NativeTheme::kColorId_BubbleFooterBackground:
-      return GetBgColor("#statusbar");
-
-    // FocusableBorder
-    case ui::NativeTheme::kColorId_FocusedBorderColor:
-      // GetBorderColor("GtkEntry#entry:focus") is correct here.  The focus ring
-      // around widgets is usually a lighter version of the "canonical theme
-      // color" - orange on Ambiance, blue on Adwaita, etc.  However, Chrome
-      // lightens the color we give it, so it would look wrong if we give it an
-      // already-lightened color.  This workaround returns the theme color
-      // directly, taken from a selected table row.  This has matched the theme
-      // color on every theme that I've tested.
-      return GetBgColor(
-          "GtkTreeView#treeview.view "
-          "GtkTreeView#treeview.view.cell:selected:focus");
-    case ui::NativeTheme::kColorId_UnfocusedBorderColor:
-      return GetBorderColor("GtkEntry#entry");
-
-    // Menu
-    case ui::NativeTheme::kColorId_MenuBackgroundColor:
-      return GetBgColor("GtkMenu#menu");
-    case ui::NativeTheme::kColorId_MenuBorderColor:
-      return GetBorderColor("GtkMenu#menu");
-    case ui::NativeTheme::kColorId_FocusedMenuItemBackgroundColor:
-      return GetBgColor("GtkMenu#menu GtkMenuItem#menuitem:hover");
-    case ui::NativeTheme::kColorId_EnabledMenuItemForegroundColor:
-    case ui::NativeTheme::kColorId_MenuDropIndicator:
-      return GetFgColor("GtkMenu#menu GtkMenuItem#menuitem GtkLabel");
-    case ui::NativeTheme::kColorId_SelectedMenuItemForegroundColor:
-      return GetFgColor("GtkMenu#menu GtkMenuItem#menuitem:hover GtkLabel");
-    case ui::NativeTheme::kColorId_DisabledMenuItemForegroundColor:
-      return GetFgColor("GtkMenu#menu GtkMenuItem#menuitem:disabled GtkLabel");
-    case ui::NativeTheme::kColorId_MenuItemMinorTextColor:
-      if (GtkVersionCheck(3, 20)) {
-        return GetFgColor("GtkMenu#menu GtkMenuItem#menuitem #accelerator");
-      }
-      return GetFgColor(
-          "GtkMenu#menu GtkMenuItem#menuitem GtkLabel.accelerator");
-    case ui::NativeTheme::kColorId_MenuSeparatorColor:
-      if (GtkVersionCheck(3, 20)) {
-        return GetSeparatorColor(
-            "GtkMenu#menu GtkSeparator#separator.horizontal");
-      }
-      return GetFgColor("GtkMenu#menu GtkMenuItem#menuitem.separator");
-    // Fallback to the same colors as Aura.
-    case ui::NativeTheme::kColorId_HighlightedMenuItemBackgroundColor:
-    case ui::NativeTheme::kColorId_HighlightedMenuItemForegroundColor:
-    case ui::NativeTheme::kColorId_MenuItemAlertBackgroundColor:
-      return ui::NativeTheme::GetInstanceForNativeUi()->GetSystemColor(
-          color_id);
-
-    // Label
-    case ui::NativeTheme::kColorId_LabelEnabledColor:
-      return GetFgColor("GtkLabel");
-    case ui::NativeTheme::kColorId_LabelDisabledColor:
-    case ui::NativeTheme::kColorId_LabelSecondaryColor:
-      return GetFgColor("GtkLabel:disabled");
-    case ui::NativeTheme::kColorId_LabelTextSelectionColor:
-      return GetFgColor(GtkVersionCheck(3, 20) ? "GtkLabel #selection"
-                                               : "GtkLabel:selected");
-    case ui::NativeTheme::kColorId_LabelTextSelectionBackgroundFocused:
-      return GetSelectionBgColor(GtkVersionCheck(3, 20) ? "GtkLabel #selection"
-                                                        : "GtkLabel:selected");
-
-    // Link
-    case ui::NativeTheme::kColorId_LinkDisabled:
-      return SkColorSetA(
-          SkColorFromColorId(ui::NativeTheme::kColorId_LinkEnabled), 0xBB);
-    case ui::NativeTheme::kColorId_LinkPressed:
-      if (GtkVersionCheck(3, 12))
-        return GetFgColor("GtkLabel.link:link:hover:active");
-      FALLTHROUGH;
-    case ui::NativeTheme::kColorId_LinkEnabled: {
-      if (GtkVersionCheck(3, 12))
-        return GetFgColor("GtkLabel.link:link");
-#if !GTK_CHECK_VERSION(3, 90, 0)
-      auto link_context = GetStyleContextFromCss("GtkLabel.view");
-      GdkColor* color;
-      gtk_style_context_get_style(link_context, "link-color", &color, nullptr);
-      if (color) {
-        SkColor ret_color =
-            SkColorSetRGB(color->red >> 8, color->green >> 8, color->blue >> 8);
-        // gdk_color_free() was deprecated in Gtk3.14.  This code path is only
-        // taken on versions earlier than Gtk3.12, but the compiler doesn't know
-        // that, so silence the deprecation warnings.
-        G_GNUC_BEGIN_IGNORE_DEPRECATIONS;
-        gdk_color_free(color);
-        G_GNUC_END_IGNORE_DEPRECATIONS;
-        return ret_color;
-      }
-#endif
-      // Default color comes from gtklinkbutton.c.
-      return SkColorSetRGB(0x00, 0x00, 0xEE);
-    }
-
-    // Scrollbar
-    case ui::NativeTheme::kColorId_OverlayScrollbarThumbBackground:
-      return GetBgColor("#GtkScrollbar#scrollbar #trough");
-    case ui::NativeTheme::kColorId_OverlayScrollbarThumbForeground:
-      return GetBgColor("#GtkScrollbar#scrollbar #slider");
-
-    // Slider
-    case ui::NativeTheme::kColorId_SliderThumbDefault:
-      return GetBgColor("GtkScale#scale #highlight");
-    case ui::NativeTheme::kColorId_SliderTroughDefault:
-      return GetBgColor("GtkScale#scale #trough");
-    case ui::NativeTheme::kColorId_SliderThumbMinimal:
-      return GetBgColor("GtkScale#scale:disabled #highlight");
-    case ui::NativeTheme::kColorId_SliderTroughMinimal:
-      return GetBgColor("GtkScale#scale:disabled #trough");
-
-    // Separator
-    case ui::NativeTheme::kColorId_SeparatorColor:
-      return GetSeparatorColor("GtkSeparator#separator.horizontal");
-
-    // Button
-    case ui::NativeTheme::kColorId_ButtonEnabledColor:
-    case ui::NativeTheme::kColorId_ButtonUncheckedColor:
-      return GetFgColor("GtkButton#button.text-button GtkLabel");
-    case ui::NativeTheme::kColorId_ButtonDisabledColor:
-      return GetFgColor("GtkButton#button.text-button:disabled GtkLabel");
-    case ui::NativeTheme::kColorId_ButtonPressedShade:
-      return SK_ColorTRANSPARENT;
-
-    // ProminentButton
-    case ui::NativeTheme::kColorId_ProminentButtonColor:
-    case ui::NativeTheme::kColorId_ProminentButtonFocusedColor:
-      return GetBgColor(
-          "GtkTreeView#treeview.view "
-          "GtkTreeView#treeview.view.cell:selected:focus");
-    case ui::NativeTheme::kColorId_TextOnProminentButtonColor:
-      return GetFgColor(
-          "GtkTreeView#treeview.view "
-          "GtkTreeView#treeview.view.cell:selected:focus GtkLabel");
-    case ui::NativeTheme::kColorId_ProminentButtonDisabledColor:
-      return GetBgColor("GtkButton#button.text-button:disabled");
-    case ui::NativeTheme::kColorId_ButtonBorderColor:
-      return GetBorderColor("GtkButton#button.text-button");
-
-    // TabbedPane
-    case ui::NativeTheme::kColorId_TabTitleColorActive:
-      return GetFgColor("GtkLabel");
-    case ui::NativeTheme::kColorId_TabTitleColorInactive:
-      return GetFgColor("GtkLabel:disabled");
-    case ui::NativeTheme::kColorId_TabBottomBorder:
-      return GetBorderColor(GtkVersionCheck(3, 20) ? "GtkFrame#frame #border"
-                                                   : "GtkFrame#frame");
-    case ui::NativeTheme::kColorId_TabHighlightBackground:
-      return GetBgColor("GtkNotebook#notebook #tab:checked");
-    case ui::NativeTheme::kColorId_TabHighlightFocusedBackground:
-      return GetBgColor("GtkNotebook#notebook:focus #tab:checked");
-
-    // Textfield
-    case ui::NativeTheme::kColorId_TextfieldDefaultColor:
-      return GetFgColor(GtkVersionCheck(3, 20)
-                            ? "GtkTextView#textview.view #text"
-                            : "GtkTextView.view");
-    case ui::NativeTheme::kColorId_TextfieldDefaultBackground:
-      return GetBgColor(GtkVersionCheck(3, 20) ? "GtkTextView#textview.view"
-                                               : "GtkTextView.view");
-    case ui::NativeTheme::kColorId_TextfieldReadOnlyColor:
-      return GetFgColor(GtkVersionCheck(3, 20)
-                            ? "GtkTextView#textview.view:disabled #text"
-                            : "GtkTextView.view:disabled");
-    case ui::NativeTheme::kColorId_TextfieldReadOnlyBackground:
-      return GetBgColor(GtkVersionCheck(3, 20)
-                            ? "GtkTextView#textview.view:disabled"
-                            : "GtkTextView.view:disabled");
-    case ui::NativeTheme::kColorId_TextfieldSelectionColor:
-      return GetFgColor(GtkVersionCheck(3, 20)
-                            ? "GtkTextView#textview.view #text #selection"
-                            : "GtkTextView.view:selected");
-    case ui::NativeTheme::kColorId_TextfieldSelectionBackgroundFocused:
-      return GetSelectionBgColor(
-          GtkVersionCheck(3, 20) ? "GtkTextView#textview.view #text #selection"
-                                 : "GtkTextView.view:selected");
-
-    // Tooltips
-    case ui::NativeTheme::kColorId_TooltipBackground:
-      return GetBgColorFromStyleContext(GetTooltipContext());
-    case ui::NativeTheme::kColorId_TooltipIcon:
-      return GetFgColor("GtkButton#button.image-button");
-    case ui::NativeTheme::kColorId_TooltipIconHovered:
-      return GetFgColor("GtkButton#button.image-button:hover");
-    case ui::NativeTheme::kColorId_TooltipText: {
-      auto context = GetTooltipContext();
-      context = AppendCssNodeToStyleContext(context, "GtkLabel");
-      return GetFgColorFromStyleContext(context);
-    }
-
-    // Trees and Tables (implemented on GTK using the same class)
-    case ui::NativeTheme::kColorId_TableBackground:
-    case ui::NativeTheme::kColorId_TreeBackground:
-      return GetBgColor(
-          "GtkTreeView#treeview.view GtkTreeView#treeview.view.cell");
-    case ui::NativeTheme::kColorId_TableText:
-    case ui::NativeTheme::kColorId_TreeText:
-    case ui::NativeTheme::kColorId_TableGroupingIndicatorColor:
-      return GetFgColor(
-          "GtkTreeView#treeview.view GtkTreeView#treeview.view.cell GtkLabel");
-    case ui::NativeTheme::kColorId_TableSelectedText:
-    case ui::NativeTheme::kColorId_TableSelectedTextUnfocused:
-    case ui::NativeTheme::kColorId_TreeSelectedText:
-    case ui::NativeTheme::kColorId_TreeSelectedTextUnfocused:
-      return GetFgColor(
-          "GtkTreeView#treeview.view "
-          "GtkTreeView#treeview.view.cell:selected:focus GtkLabel");
-    case ui::NativeTheme::kColorId_TableSelectionBackgroundFocused:
-    case ui::NativeTheme::kColorId_TableSelectionBackgroundUnfocused:
-    case ui::NativeTheme::kColorId_TreeSelectionBackgroundFocused:
-    case ui::NativeTheme::kColorId_TreeSelectionBackgroundUnfocused:
-      return GetBgColor(
-          "GtkTreeView#treeview.view "
-          "GtkTreeView#treeview.view.cell:selected:focus");
-
-    // Table Header
-    case ui::NativeTheme::kColorId_TableHeaderText:
-      return GetFgColor("GtkTreeView#treeview.view GtkButton#button GtkLabel");
-    case ui::NativeTheme::kColorId_TableHeaderBackground:
-      return GetBgColor("GtkTreeView#treeview.view GtkButton#button");
-    case ui::NativeTheme::kColorId_TableHeaderSeparator:
-      return GetBorderColor("GtkTreeView#treeview.view GtkButton#button");
-
-    // Throbber
-    // TODO(thomasanderson): Render GtkSpinner directly.
-    case ui::NativeTheme::kColorId_ThrobberSpinningColor:
-      return GetFgColor("GtkSpinner#spinner");
-    case ui::NativeTheme::kColorId_ThrobberWaitingColor:
-    case ui::NativeTheme::kColorId_ThrobberLightColor:
-      return GetFgColor("GtkSpinner#spinner:disabled");
-
-    // Alert icons
-    // Fallback to the same colors as Aura.
-    case ui::NativeTheme::kColorId_AlertSeverityLow:
-    case ui::NativeTheme::kColorId_AlertSeverityMedium:
-    case ui::NativeTheme::kColorId_AlertSeverityHigh: {
-      // Alert icons appear on the toolbar, so use the toolbar BG
-      // color (the GTK window bg color) to determine if the dark Aura
-      // theme should be used.
-      ui::NativeTheme* fallback_theme =
-          color_utils::IsDark(GetBgColor(""))
-              ? ui::NativeThemeDarkAura::instance()
-              : ui::NativeTheme::GetInstanceForNativeUi();
-      return fallback_theme->GetSystemColor(color_id);
-    }
-
-    case ui::NativeTheme::kColorId_DefaultIconColor:
-      if (GtkVersionCheck(3, 20))
-        return GetFgColor("GtkMenu#menu GtkMenuItem#menuitem #radio");
-      return GetFgColor("GtkMenu#menu GtkMenuItem#menuitem.radio");
-
-    case ui::NativeTheme::kColorId_NumColors:
-      NOTREACHED();
-      break;
-  }
-  return gfx::kPlaceholderColor;
+SkColor GetBaseColor(GtkWidget* widget, WidgetState state) {
+  return GdkColorToSkColor(gtk_rc_get_style(widget)->base[stateMap[state]]);
 }
 
 }  // namespace
@@ -344,187 +64,35 @@ NativeThemeGtk* NativeThemeGtk::instance() {
   return s_native_theme.get();
 }
 
-NativeThemeGtk::NativeThemeGtk() {
-  // These types are needed by g_type_from_name(), but may not be registered at
-  // this point.  We need the g_type_class magic to make sure the compiler
-  // doesn't optimize away this code.
-  g_type_class_unref(g_type_class_ref(gtk_button_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_entry_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_frame_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_header_bar_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_image_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_info_bar_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_label_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_menu_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_menu_bar_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_menu_item_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_range_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_scrollbar_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_scrolled_window_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_separator_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_spinner_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_text_view_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_toggle_button_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_tree_view_get_type()));
-  g_type_class_unref(g_type_class_ref(gtk_window_get_type()));
-
-  OnThemeChanged(gtk_settings_get_default(), nullptr);
-}
-
-NativeThemeGtk::~NativeThemeGtk() {
-  NOTREACHED();
-}
-
-void NativeThemeGtk::SetThemeCssOverride(ScopedCssProvider provider) {
-  if (theme_css_override_) {
-    gtk_style_context_remove_provider_for_screen(
-        gdk_screen_get_default(),
-        GTK_STYLE_PROVIDER(theme_css_override_.get()));
-  }
-  theme_css_override_ = std::move(provider);
-  if (theme_css_override_) {
-    gtk_style_context_add_provider_for_screen(
-        gdk_screen_get_default(), GTK_STYLE_PROVIDER(theme_css_override_.get()),
-        GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
-  }
-}
-
-void NativeThemeGtk::OnThemeChanged(GtkSettings* settings,
-                                    GtkParamSpec* param) {
-  SetThemeCssOverride(ScopedCssProvider());
-  for (auto& color : color_cache_)
-    color = base::nullopt;
-
-  // Hack to workaround a bug on GNOME standard themes which would
-  // cause black patches to be rendered on GtkFileChooser dialogs.
-  std::string theme_name =
-      GetGtkSettingsStringProperty(settings, "gtk-theme-name");
-  if (!GtkVersionCheck(3, 14)) {
-    if (theme_name == "Adwaita") {
-      SetThemeCssOverride(GetCssProvider(
-          "GtkFileChooser GtkPaned { background-color: @theme_bg_color; }"));
-    } else if (theme_name == "HighContrast") {
-      SetThemeCssOverride(GetCssProvider(
-          "GtkFileChooser GtkPaned { background-color: @theme_base_color; }"));
-    }
-  }
-
-  // GTK has a dark mode setting called "gtk-application-prefer-dark-theme", but
-  // this is really only used for themes that have a dark or light variant that
-  // gets toggled based on this setting (eg. Adwaita).  Most dark themes do not
-  // have a light variant and aren't affected by the setting.  Because of this,
-  // experimentally check if the theme is dark by checking if the window
-  // background color is dark.
-  set_use_dark_colors(
-      color_utils::IsDark(GetSystemColor(kColorId_WindowBackground)));
-  set_preferred_color_scheme(CalculatePreferredColorScheme());
-
-  // GTK doesn't have a native high contrast setting.  Rather, it's implied by
-  // the theme name.  The only high contrast GTK themes that I know of are
-  // HighContrast (GNOME) and ContrastHighInverse (MATE).  So infer the contrast
-  // based on if the theme name contains both "high" and "contrast",
-  // case-insensitive.
-  std::transform(theme_name.begin(), theme_name.end(), theme_name.begin(),
-                 ::tolower);
-  set_high_contrast(theme_name.find("high") != std::string::npos &&
-                    theme_name.find("contrast") != std::string::npos);
-
-  NotifyObservers();
-}
-
-SkColor NativeThemeGtk::GetSystemColor(ColorId color_id,
-                                       ColorScheme color_scheme) const {
-  if (color_cache_[color_id])
-    return color_cache_[color_id].value();
-
-  SkColor color = SkColorFromColorId(color_id);
-  color_cache_[color_id] = color;
-  return color;
-}
-
-void NativeThemeGtk::PaintArrowButton(
-    cc::PaintCanvas* canvas,
-    const gfx::Rect& rect,
-    Part direction,
-    State state,
-    ColorScheme color_scheme,
-    const ScrollbarArrowExtraParams& arrow) const {
-  auto context = GetStyleContextFromCss(
-      GtkVersionCheck(3, 20)
-          ? "GtkScrollbar#scrollbar #contents GtkButton#button"
-          : "GtkRange.scrollbar.button");
-  GtkStateFlags state_flags = StateToStateFlags(state);
-  gtk_style_context_set_state(context, state_flags);
-
-  switch (direction) {
-    case kScrollbarUpArrow:
-      gtk_style_context_add_class(context, GTK_STYLE_CLASS_TOP);
-      break;
-    case kScrollbarRightArrow:
-      gtk_style_context_add_class(context, GTK_STYLE_CLASS_RIGHT);
-      break;
-    case kScrollbarDownArrow:
-      gtk_style_context_add_class(context, GTK_STYLE_CLASS_BOTTOM);
-      break;
-    case kScrollbarLeftArrow:
-      gtk_style_context_add_class(context, GTK_STYLE_CLASS_LEFT);
-      break;
-    default:
-      NOTREACHED();
-  }
-
-  PaintWidget(canvas, rect, context, BG_RENDER_NORMAL, true);
-  PaintArrow(canvas, rect, direction, GetFgColorFromStyleContext(context));
-}
-
-void NativeThemeGtk::PaintScrollbarTrack(
-    cc::PaintCanvas* canvas,
-    Part part,
-    State state,
-    const ScrollbarTrackExtraParams& extra_params,
-    const gfx::Rect& rect,
-    ColorScheme color_scheme) const {
-  PaintWidget(
-      canvas, rect,
-      GetStyleContextFromCss(GtkVersionCheck(3, 20)
-                                 ? "GtkScrollbar#scrollbar #contents #trough"
-                                 : "GtkScrollbar.scrollbar.trough"),
-      BG_RENDER_NORMAL, true);
-}
-
-void NativeThemeGtk::PaintScrollbarThumb(
-    cc::PaintCanvas* canvas,
-    Part part,
-    State state,
-    const gfx::Rect& rect,
-    NativeTheme::ScrollbarOverlayColorTheme theme,
-    ColorScheme color_scheme) const {
-  auto context = GetStyleContextFromCss(
-      GtkVersionCheck(3, 20)
-          ? "GtkScrollbar#scrollbar #contents #trough #slider"
-          : "GtkScrollbar.scrollbar.slider");
-  gtk_style_context_set_state(context, StateToStateFlags(state));
-  PaintWidget(canvas, rect, context, BG_RENDER_NORMAL, true);
-}
-
-void NativeThemeGtk::PaintScrollbarCorner(cc::PaintCanvas* canvas,
-                                          State state,
-                                          const gfx::Rect& rect,
-                                          ColorScheme color_scheme) const {
-  auto context = GetStyleContextFromCss(
-      GtkVersionCheck(3, 19, 2)
-          ? "GtkScrolledWindow#scrolledwindow #junction"
-          : "GtkScrolledWindow.scrolledwindow.scrollbars-junction");
-  PaintWidget(canvas, rect, context, BG_RENDER_NORMAL, true);
-}
+// Constructors automatically called
+NativeThemeGtk::NativeThemeGtk() {}
+// This doesn't actually get called
+NativeThemeGtk::~NativeThemeGtk() {}
 
 void NativeThemeGtk::PaintMenuPopupBackground(
     cc::PaintCanvas* canvas,
     const gfx::Size& size,
     const MenuBackgroundExtraParams& menu_background,
     ColorScheme color_scheme) const {
-  PaintWidget(canvas, gfx::Rect(size), GetStyleContextFromCss("GtkMenu#menu"),
-              BG_RENDER_RECURSIVE, false);
+  if (menu_background.corner_radius > 0) {
+    cc::PaintFlags flags;
+    flags.setStyle(cc::PaintFlags::kFill_Style);
+    flags.setAntiAlias(true);
+    flags.setColor(GetSystemColor(kColorId_MenuBackgroundColor));
+
+    SkPath path;
+    SkRect rect = SkRect::MakeWH(SkIntToScalar(size.width()),
+                                 SkIntToScalar(size.height()));
+    SkScalar radius = SkIntToScalar(menu_background.corner_radius);
+    SkScalar radii[8] = {radius, radius, radius, radius,
+                         radius, radius, radius, radius};
+    path.addRoundRect(rect, radii);
+
+    canvas->drawPath(path, flags);
+  } else {
+    canvas->drawColor(GetSystemColor(kColorId_MenuBackgroundColor),
+                      SkBlendMode::kSrc);
+  }
 }
 
 void NativeThemeGtk::PaintMenuItemBackground(
@@ -533,117 +101,326 @@ void NativeThemeGtk::PaintMenuItemBackground(
     const gfx::Rect& rect,
     const MenuItemExtraParams& menu_item,
     ColorScheme color_scheme) const {
-  auto context = GetStyleContextFromCss("GtkMenu#menu GtkMenuItem#menuitem");
-  gtk_style_context_set_state(context, StateToStateFlags(state));
-  PaintWidget(canvas, rect, context, BG_RENDER_NORMAL, true);
-}
-
-void NativeThemeGtk::PaintMenuSeparator(
-    cc::PaintCanvas* canvas,
-    State state,
-    const gfx::Rect& rect,
-    const MenuSeparatorExtraParams& menu_separator,
-    ColorScheme color_scheme) const {
-  // TODO(estade): use GTK to draw vertical separators too. See
-  // crbug.com/710183
-  if (menu_separator.type == ui::VERTICAL_SEPARATOR) {
-    cc::PaintFlags paint;
-    paint.setStyle(cc::PaintFlags::kFill_Style);
-    paint.setColor(GetSystemColor(ui::NativeTheme::kColorId_MenuSeparatorColor,
-                                  color_scheme));
-    canvas->drawRect(gfx::RectToSkRect(rect), paint);
+  SkColor color;
+  cc::PaintFlags flags;
+  switch (state) {
+    case NativeTheme::kNormal:
+    case NativeTheme::kDisabled:
+      color = GetSystemColor(NativeTheme::kColorId_MenuBackgroundColor);
+      flags.setColor(color);
+      break;
+    case NativeTheme::kHovered:
+      color =
+          GetSystemColor(NativeTheme::kColorId_FocusedMenuItemBackgroundColor);
+      flags.setColor(color);
+      break;
+    default:
+      NOTREACHED() << "Invalid state " << state;
+      break;
+  }
+  if (menu_item.corner_radius > 0) {
+    const SkScalar radius = SkIntToScalar(menu_item.corner_radius);
+    canvas->drawRoundRect(gfx::RectToSkRect(rect), radius, radius, flags);
     return;
   }
-
-  auto separator_offset = [&](int separator_thickness) {
-    switch (menu_separator.type) {
-      case ui::LOWER_SEPARATOR:
-        return rect.height() - separator_thickness;
-      case ui::UPPER_SEPARATOR:
-        return 0;
-      default:
-        return (rect.height() - separator_thickness) / 2;
-    }
-  };
-  if (GtkVersionCheck(3, 20)) {
-    auto context = GetStyleContextFromCss(
-        "GtkMenu#menu GtkSeparator#separator.horizontal");
-    GtkBorder margin, border, padding;
-    int min_height = 1;
-#if GTK_CHECK_VERSION(3, 90, 0)
-    gtk_style_context_get_margin(context, &margin);
-    gtk_style_context_get_border(context, &border);
-    gtk_style_context_get_padding(context, &padding);
-    gtk_style_context_get(context, "min-height", &min_height, nullptr);
-#else
-    GtkStateFlags state = gtk_style_context_get_state(context);
-    gtk_style_context_get_margin(context, state, &margin);
-    gtk_style_context_get_border(context, state, &border);
-    gtk_style_context_get_padding(context, state, &padding);
-    gtk_style_context_get(context, state, "min-height", &min_height, nullptr);
-#endif
-    int w = rect.width() - margin.left - margin.right;
-    int h = std::max(
-        min_height + padding.top + padding.bottom + border.top + border.bottom,
-        1);
-    int x = margin.left;
-    int y = separator_offset(h);
-    PaintWidget(canvas, gfx::Rect(x, y, w, h), context, BG_RENDER_NORMAL, true);
-  } else {
-#if !GTK_CHECK_VERSION(3, 90, 0)
-    auto context = GetStyleContextFromCss(
-        "GtkMenu#menu GtkMenuItem#menuitem.separator.horizontal");
-    gboolean wide_separators = false;
-    gint separator_height = 0;
-    gtk_style_context_get_style(context, "wide-separators", &wide_separators,
-                                "separator-height", &separator_height, nullptr);
-    // This code was adapted from gtk/gtkmenuitem.c.  For some reason,
-    // padding is used as the margin.
-    GtkBorder padding;
-    gtk_style_context_get_padding(context, gtk_style_context_get_state(context),
-                                  &padding);
-    int w = rect.width() - padding.left - padding.right;
-    int x = rect.x() + padding.left;
-    int h = wide_separators ? separator_height : 1;
-    int y = rect.y() + separator_offset(h);
-    if (wide_separators) {
-      PaintWidget(canvas, gfx::Rect(x, y, w, h), context, BG_RENDER_NONE, true);
-    } else {
-      cc::PaintFlags flags;
-      flags.setColor(GetFgColorFromStyleContext(context));
-      flags.setAntiAlias(true);
-      flags.setStrokeWidth(1);
-      canvas->drawLine(x + 0.5f, y + 0.5f, x + w + 0.5f, y + 0.5f, flags);
-    }
-#endif
-  }
+  canvas->drawRect(gfx::RectToSkRect(rect), flags);
 }
 
-void NativeThemeGtk::PaintFrameTopArea(
-    cc::PaintCanvas* canvas,
-    State state,
-    const gfx::Rect& rect,
-    const FrameTopAreaExtraParams& frame_top_area,
-    ColorScheme color_scheme) const {
-  auto context = GetStyleContextFromCss(frame_top_area.use_custom_frame
-                                            ? "#headerbar.header-bar.titlebar"
-                                            : "GtkMenuBar#menubar");
-  ApplyCssToContext(context, "* { border-radius: 0px; border-style: none; }");
-  gtk_style_context_set_state(context, frame_top_area.is_active
-                                           ? GTK_STATE_FLAG_NORMAL
-                                           : GTK_STATE_FLAG_BACKDROP);
+SkColor NativeThemeGtk::GetSystemColor(ColorId color_id, ColorScheme color_scheme) const {
+  switch (color_id) {
+    // Windows
+    case kColorId_WindowBackground:
+      return GetBgColor(GetWindow(), SELECTED);
 
-  SkBitmap bitmap =
-      GetWidgetBitmap(rect.size(), context, BG_RENDER_RECURSIVE, false);
+    // Dialogs
+    case kColorId_DialogBackground:
+    case kColorId_BubbleBackground:
+      return GetBgColor(GetWindow(), NORMAL);
 
-  if (frame_top_area.incognito) {
-    bitmap = SkBitmapOperations::CreateHSLShiftedBitmap(
-        bitmap, kDefaultTintFrameIncognito);
-    bitmap.setImmutable();
+    // FocusableBorder
+    case kColorId_FocusedBorderColor:
+      return GetBgColor(GetEntry(), SELECTED);
+    case kColorId_UnfocusedBorderColor:
+      return GetTextAAColor(GetEntry(), NORMAL);
+
+    // MenuItem
+    case kColorId_SelectedMenuItemForegroundColor:
+      return GetTextColor(GetMenuItem(), SELECTED);
+    case kColorId_FocusedMenuItemBackgroundColor:
+      return GetBgColor(GetMenuItem(), SELECTED);
+
+    case kColorId_EnabledMenuItemForegroundColor:
+    case kColorId_MenuDropIndicator:
+      return GetTextColor(GetMenuItem(), NORMAL);
+    case kColorId_MenuItemMinorTextColor:
+    case kColorId_DisabledMenuItemForegroundColor:
+      return GetTextColor(GetMenuItem(), INSENSITIVE);
+    case kColorId_MenuBorderColor:
+    case kColorId_MenuSeparatorColor:
+      return GetTextColor(GetMenuItem(), INSENSITIVE);
+    case kColorId_MenuBackgroundColor:
+      return GetBgColor(GetMenu(), NORMAL);
+
+    // Label
+    case kColorId_LabelEnabledColor:
+      return GetTextColor(GetEntry(), NORMAL);
+    case kColorId_LabelDisabledColor:
+    case kColorId_LabelSecondaryColor:
+      return GetTextColor(GetLabel(), INSENSITIVE);
+    case kColorId_LabelTextSelectionColor:
+      return GetTextColor(GetLabel(), SELECTED);
+    case kColorId_LabelTextSelectionBackgroundFocused:
+      return GetBaseColor(GetLabel(), SELECTED);
+
+    // Link
+    case kColorId_LinkDisabled:
+      return SkColorSetA(GetSystemColor(kColorId_LinkEnabled), 0xBB);
+    case kColorId_LinkEnabled: {
+      SkColor link_color = SK_ColorTRANSPARENT;
+      GdkColor* style_color = nullptr;
+      gtk_widget_style_get(GetWindow(), "link-color", &style_color, nullptr);
+      if (style_color) {
+        link_color = GdkColorToSkColor(*style_color);
+        gdk_color_free(style_color);
+      }
+      if (link_color != SK_ColorTRANSPARENT)
+        return link_color;
+      // Default color comes from gtklinkbutton.c.
+      return SkColorSetRGB(0x00, 0x00, 0xEE);
+    }
+    case kColorId_LinkPressed:
+      return SK_ColorRED;
+
+    // Separator
+    case kColorId_SeparatorColor:
+    case kColorId_ButtonBorderColor:
+      return GetFgColor(GetSeparator(), INSENSITIVE);
+
+    // Button
+    case kColorId_ButtonEnabledColor:
+    case kColorId_ButtonUncheckedColor:
+      return GetTextColor(GetButton(), NORMAL);
+    case kColorId_ButtonDisabledColor:
+    case kColorId_ProminentButtonDisabledColor:
+      return GetTextColor(GetButton(), INSENSITIVE);
+    case kColorId_ProminentButtonColor:
+    case kColorId_ProminentButtonFocusedColor:
+      return GetSystemColor(kColorId_LinkEnabled);
+    case kColorId_TextOnProminentButtonColor:
+      return GetTextColor(GetLabel(), SELECTED);
+    case kColorId_ButtonPressedShade:
+      return SK_ColorTRANSPARENT;
+
+    // TabbedPane
+    case ui::NativeTheme::kColorId_TabTitleColorActive:
+      return GetTextColor(GetEntry(), NORMAL);
+    case ui::NativeTheme::kColorId_TabTitleColorInactive:
+      return GetTextColor(GetLabel(), INSENSITIVE);
+    case ui::NativeTheme::kColorId_TabBottomBorder:
+      return GetTextColor(GetEntry(), NORMAL);
+    case kColorId_TabHighlightBackground:
+      return GetBgColor(GetEntry(), NORMAL);
+    case kColorId_TabHighlightFocusedBackground:
+      return GetBgColor(GetEntry(), PRELIGHT);
+
+    // Textfield
+    case kColorId_TextfieldDefaultColor:
+      return GetTextColor(GetEntry(), NORMAL);
+    case kColorId_TextfieldDefaultBackground:
+      return GetBaseColor(GetEntry(), NORMAL);
+
+    case kColorId_TextfieldReadOnlyColor:
+      return GetTextColor(GetEntry(), ACTIVE);
+    case kColorId_TextfieldReadOnlyBackground:
+      return GetBaseColor(GetEntry(), ACTIVE);
+    case kColorId_TextfieldSelectionColor:
+      return GetTextColor(GetEntry(), SELECTED);
+    case kColorId_TextfieldSelectionBackgroundFocused:
+      return GetBaseColor(GetEntry(), SELECTED);
+
+    // Tooltips
+    case kColorId_TooltipBackground:
+      return GetBgColor(GetTooltip(), NORMAL);
+    case kColorId_TooltipText:
+    case kColorId_TooltipIcon:
+      return GetFgColor(GetTooltip(), NORMAL);
+    case kColorId_TooltipIconHovered:
+      return GetFgColor(GetTooltip(), PRELIGHT);
+
+    // Trees and Tables (implemented on GTK using the same class)
+    case kColorId_TableBackground:
+    case kColorId_TreeBackground:
+      return GetBgColor(GetTree(), NORMAL);
+    case kColorId_TableText:
+    case kColorId_TreeText:
+      return GetTextColor(GetTree(), NORMAL);
+    case kColorId_TableSelectedText:
+    case kColorId_TableSelectedTextUnfocused:
+    case kColorId_TreeSelectedText:
+    case kColorId_TreeSelectedTextUnfocused:
+      return GetTextColor(GetTree(), SELECTED);
+    case kColorId_TableSelectionBackgroundFocused:
+    case kColorId_TableSelectionBackgroundUnfocused:
+    case kColorId_TreeSelectionBackgroundFocused:
+    case kColorId_TreeSelectionBackgroundUnfocused:
+      return GetBgColor(GetTree(), SELECTED);
+    case kColorId_TableGroupingIndicatorColor:
+      return GetTextAAColor(GetTree(), NORMAL);
+
+    // Table Headers
+    case kColorId_TableHeaderText:
+      return GetTextColor(GetTree(), NORMAL);
+    case kColorId_TableHeaderBackground:
+      return GetBgColor(GetTree(), NORMAL);
+    case kColorId_TableHeaderSeparator:
+      return GetFgColor(GetSeparator(), INSENSITIVE);
+
+    // Throbber
+    case kColorId_ThrobberSpinningColor:
+    case kColorId_ThrobberLightColor:
+      return GetSystemColor(kColorId_TextfieldSelectionBackgroundFocused);
+
+    case kColorId_ThrobberWaitingColor:
+      return color_utils::AlphaBlend(
+          GetSystemColor(kColorId_TextfieldSelectionBackgroundFocused),
+          GetBgColor(GetWindow(), NORMAL), SkAlpha(0x80));
+
+    // new shit
+    case kColorId_DialogForeground:
+      return GetFgColor(GetLabel(), NORMAL);
+    case kColorId_BubbleFooterBackground: // ??
+      return GetBgColor(GetWindow(), NORMAL);
+    case kColorId_OverlayScrollbarThumbBackground:
+      return GetBgColor(GetButton(), NORMAL);
+    case kColorId_OverlayScrollbarThumbForeground:
+    case kColorId_SliderThumbDefault:
+    case kColorId_SliderTroughDefault:
+    case kColorId_SliderThumbMinimal:
+    case kColorId_SliderTroughMinimal:
+      return GetBgColor(GetButton(), PRELIGHT);
+
+
+    // Fallback to the same colors as Aura.
+    case kColorId_HighlightedMenuItemBackgroundColor:
+    case kColorId_HighlightedMenuItemForegroundColor:
+    case kColorId_MenuItemAlertBackgroundColor:
+      return ui::NativeTheme::GetInstanceForNativeUi()->GetSystemColor(
+          color_id);
+
+    // Alert icons
+    // Just fall back to the same colors as Aura.
+    case kColorId_AlertSeverityLow:
+    case kColorId_AlertSeverityMedium:
+    case kColorId_AlertSeverityHigh:
+    case kColorId_DefaultIconColor:
+    {
+      ui::NativeTheme* fallback_theme =
+          color_utils::IsDark(GetTextColor(GetEntry(), NORMAL))
+              ? ui::NativeTheme::GetInstanceForNativeUi()
+              : ui::NativeThemeDarkAura::instance();
+      return fallback_theme->GetSystemColor(color_id);
+    }
+
+    case kColorId_NumColors:
+      NOTREACHED();
+      break;
   }
 
-  canvas->drawImage(cc::PaintImage::CreateFromBitmap(std::move(bitmap)),
-                    rect.x(), rect.y());
+  return gfx::kPlaceholderColor;
 }
 
-}  // namespace gtk
+GtkWidget* NativeThemeGtk::GetWindow() const {
+  static GtkWidget* fake_window = nullptr;
+
+  if (!fake_window) {
+    fake_window = chrome_gtk_frame_new();
+    gtk_widget_realize(fake_window);
+  }
+
+  return fake_window;
+}
+
+GtkWidget* NativeThemeGtk::GetEntry() const {
+  static GtkWidget* fake_entry = nullptr;
+
+  if (!fake_entry) {
+    fake_entry = gtk_entry_new();
+
+    // The fake entry needs to be in the window so it can be realized so we can
+    // use the computed parts of the style.
+    gtk_container_add(GTK_CONTAINER(GetWindow()), fake_entry);
+    gtk_widget_realize(fake_entry);
+  }
+
+  return fake_entry;
+}
+
+GtkWidget* NativeThemeGtk::GetLabel() const {
+  static GtkWidget* fake_label = nullptr;
+
+  if (!fake_label)
+    fake_label = gtk_label_new("");
+
+  return fake_label;
+}
+
+GtkWidget* NativeThemeGtk::GetButton() const {
+  static GtkWidget* fake_button = nullptr;
+
+  if (!fake_button)
+    fake_button = gtk_button_new();
+
+  return fake_button;
+}
+
+GtkWidget* NativeThemeGtk::GetTree() const {
+  static GtkWidget* fake_tree = nullptr;
+
+  if (!fake_tree)
+    fake_tree = gtk_tree_view_new();
+
+  return fake_tree;
+}
+
+GtkWidget* NativeThemeGtk::GetTooltip() const {
+  static GtkWidget* fake_tooltip = nullptr;
+
+  if (!fake_tooltip) {
+    fake_tooltip = gtk_window_new(GTK_WINDOW_TOPLEVEL);
+    gtk_widget_set_name(fake_tooltip, "gtk-tooltip");
+    gtk_widget_realize(fake_tooltip);
+  }
+
+  return fake_tooltip;
+}
+
+GtkWidget* NativeThemeGtk::GetMenu() const {
+  static GtkWidget* fake_menu = nullptr;
+
+  if (!fake_menu)
+    fake_menu = gtk_custom_menu_new();
+
+  return fake_menu;
+}
+
+GtkWidget* NativeThemeGtk::GetMenuItem() const {
+  static GtkWidget* fake_menu_item = nullptr;
+
+  if (!fake_menu_item) {
+    fake_menu_item = gtk_custom_menu_item_new();
+    gtk_menu_shell_append(GTK_MENU_SHELL(GetMenu()), fake_menu_item);
+  }
+
+  return fake_menu_item;
+}
+
+GtkWidget* NativeThemeGtk::GetSeparator() const {
+  static GtkWidget* fake_separator = nullptr;
+
+  if (!fake_separator)
+    fake_separator = gtk_hseparator_new();
+
+  return fake_separator;
+}
+
+}  // namespace libgtkui
diff --git a/chrome/browser/ui/gtk/native_theme_gtk.h b/chrome/browser/ui/gtk/native_theme_gtk.h
index b52e5d65828c..7e52ad682cfd 100644
--- a/chrome/browser/ui/gtk/native_theme_gtk.h
+++ b/chrome/browser/ui/gtk/native_theme_gtk.h
@@ -12,14 +12,10 @@
 #include "ui/base/glib/scoped_gobject.h"
 #include "ui/native_theme/native_theme_base.h"
 
-typedef struct _GtkCssProvider GtkCssProvider;
-typedef struct _GtkParamSpec GtkParamSpec;
-typedef struct _GtkSettings GtkSettings;
+typedef struct _GtkWidget GtkWidget;
 
 namespace gtk {
 
-using ScopedCssProvider = ScopedGObject<GtkCssProvider>;
-
 // A version of NativeTheme that uses GTK-rendered widgets.
 class NativeThemeGtk : public ui::NativeThemeBase {
  public:
@@ -29,50 +25,16 @@ class NativeThemeGtk : public ui::NativeThemeBase {
   SkColor GetSystemColor(
       ColorId color_id,
       ColorScheme color_scheme = ColorScheme::kDefault) const override;
-  void PaintArrowButton(cc::PaintCanvas* canvas,
-                        const gfx::Rect& rect,
-                        Part direction,
-                        State state,
-                        ColorScheme color_scheme,
-                        const ScrollbarArrowExtraParams& arrow) const override;
-  void PaintScrollbarTrack(cc::PaintCanvas* canvas,
-                           Part part,
-                           State state,
-                           const ScrollbarTrackExtraParams& extra_params,
-                           const gfx::Rect& rect,
-                           ColorScheme color_scheme) const override;
-  void PaintScrollbarThumb(cc::PaintCanvas* canvas,
-                           Part part,
-                           State state,
-                           const gfx::Rect& rect,
-                           NativeTheme::ScrollbarOverlayColorTheme theme,
-                           ColorScheme color_scheme) const override;
-  void PaintScrollbarCorner(cc::PaintCanvas* canvas,
-                            State state,
-                            const gfx::Rect& rect,
-                            ColorScheme color_scheme) const override;
   void PaintMenuPopupBackground(
       cc::PaintCanvas* canvas,
       const gfx::Size& size,
       const MenuBackgroundExtraParams& menu_background,
       ColorScheme color_scheme) const override;
-  void PaintMenuSeparator(cc::PaintCanvas* canvas,
-                          State state,
-                          const gfx::Rect& rect,
-                          const MenuSeparatorExtraParams& menu_separator,
-                          ColorScheme color_scheme) const override;
   void PaintMenuItemBackground(cc::PaintCanvas* canvas,
                                State state,
                                const gfx::Rect& rect,
                                const MenuItemExtraParams& menu_item,
                                ColorScheme color_scheme) const override;
-  void PaintFrameTopArea(cc::PaintCanvas* canvas,
-                         State state,
-                         const gfx::Rect& rect,
-                         const FrameTopAreaExtraParams& frame_top_area,
-                         ColorScheme color_scheme) const override;
-
-  void OnThemeChanged(GtkSettings* settings, GtkParamSpec* param);
 
  private:
   friend class base::NoDestructor<NativeThemeGtk>;
@@ -80,11 +42,16 @@ class NativeThemeGtk : public ui::NativeThemeBase {
   NativeThemeGtk();
   ~NativeThemeGtk() override;
 
-  void SetThemeCssOverride(ScopedCssProvider provider);
-
-  mutable base::Optional<SkColor> color_cache_[kColorId_NumColors];
-
-  ScopedCssProvider theme_css_override_;
+  // Returns various widgets for theming use.
+  GtkWidget* GetWindow() const;
+  GtkWidget* GetEntry() const;
+  GtkWidget* GetLabel() const;
+  GtkWidget* GetButton() const;
+  GtkWidget* GetTree() const;
+  GtkWidget* GetTooltip() const;
+  GtkWidget* GetMenu() const;
+  GtkWidget* GetMenuItem() const;
+  GtkWidget* GetSeparator() const;
 
   DISALLOW_COPY_AND_ASSIGN(NativeThemeGtk);
 };
diff --git a/chrome/browser/ui/gtk/print_dialog_gtk.cc b/chrome/browser/ui/gtk/print_dialog_gtk.cc
index bdbba42dbc38..875d21e875b3 100644
--- a/chrome/browser/ui/gtk/print_dialog_gtk.cc
+++ b/chrome/browser/ui/gtk/print_dialog_gtk.cc
@@ -484,7 +484,7 @@ void PrintDialogGtk::OnResponse(GtkWidget* dialog, int response_id) {
 
 static void OnJobCompletedThunk(GtkPrintJob* print_job,
                                 gpointer user_data,
-                                const GError* error) {
+                                GError* error) {
   static_cast<PrintDialogGtk*>(user_data)->OnJobCompleted(print_job, error);
 }
 void PrintDialogGtk::SendDocumentToPrinter(
diff --git a/chrome/browser/ui/gtk/skia_utils_gtk.cc b/chrome/browser/ui/gtk/skia_utils_gtk.cc
new file mode 100644
index 000000000000..8311bbe225f9
--- /dev/null
+++ b/chrome/browser/ui/gtk/skia_utils_gtk.cc
@@ -0,0 +1,129 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/gtk/skia_utils_gtk.h"
+
+#include <gdk/gdk.h>
+
+#include "base/logging.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "third_party/skia/include/core/SkUnPreMultiply.h"
+
+namespace gtk {
+
+// GDK_COLOR_RGB multiplies by 257 (= 0x10001) to distribute the bits evenly
+// See: http://www.mindcontrol.org/~hplus/graphics/expand-bits.html
+// To get back, we can just right shift by eight
+// (or, formulated differently, i == (i*257)/256 for all i < 256).
+
+#if !GTK_CHECK_VERSION(3, 90, 0)
+SkColor GdkColorToSkColor(GdkColor color) {
+  return SkColorSetRGB(color.red >> 8, color.green >> 8, color.blue >> 8);
+}
+
+GdkColor SkColorToGdkColor(SkColor color) {
+  GdkColor gdk_color = {
+      0, static_cast<guint16>(SkColorGetR(color) * kSkiaToGDKMultiplier),
+      static_cast<guint16>(SkColorGetG(color) * kSkiaToGDKMultiplier),
+      static_cast<guint16>(SkColorGetB(color) * kSkiaToGDKMultiplier)};
+  return gdk_color;
+}
+#endif
+
+const SkBitmap GdkPixbufToImageSkia(GdkPixbuf* pixbuf) {
+  // TODO(erg): What do we do in the case where the pixbuf fails these dchecks?
+  // I would prefer to use our gtk based canvas, but that would require
+  // recompiling half of our skia extensions with gtk support, which we can't
+  // do in this build.
+  DCHECK_EQ(GDK_COLORSPACE_RGB, gdk_pixbuf_get_colorspace(pixbuf));
+
+  int n_channels = gdk_pixbuf_get_n_channels(pixbuf);
+  int w = gdk_pixbuf_get_width(pixbuf);
+  int h = gdk_pixbuf_get_height(pixbuf);
+
+  SkBitmap ret;
+  ret.allocN32Pixels(w, h);
+  ret.eraseColor(0);
+
+  uint32_t* skia_data = static_cast<uint32_t*>(ret.getAddr(0, 0));
+
+  if (n_channels == 4) {
+    int total_length = w * h;
+    guchar* gdk_pixels = gdk_pixbuf_get_pixels(pixbuf);
+
+    // Now here's the trick: we need to convert the gdk data (which is RGBA and
+    // isn't premultiplied) to skia (which can be anything and premultiplied).
+    for (int i = 0; i < total_length; ++i, gdk_pixels += 4) {
+      const unsigned char& red = gdk_pixels[0];
+      const unsigned char& green = gdk_pixels[1];
+      const unsigned char& blue = gdk_pixels[2];
+      const unsigned char& alpha = gdk_pixels[3];
+
+      skia_data[i] = SkPreMultiplyARGB(alpha, red, green, blue);
+    }
+  } else if (n_channels == 3) {
+    // Because GDK makes rowstrides word aligned, we need to do something a bit
+    // more complex when a pixel isn't perfectly a word of memory.
+    int rowstride = gdk_pixbuf_get_rowstride(pixbuf);
+    guchar* gdk_pixels = gdk_pixbuf_get_pixels(pixbuf);
+    for (int y = 0; y < h; ++y) {
+      int row = y * rowstride;
+
+      for (int x = 0; x < w; ++x) {
+        guchar* pixel = gdk_pixels + row + (x * 3);
+        const unsigned char& red = pixel[0];
+        const unsigned char& green = pixel[1];
+        const unsigned char& blue = pixel[2];
+
+        skia_data[y * w + x] = SkPreMultiplyARGB(255, red, green, blue);
+      }
+    }
+  } else {
+    NOTREACHED();
+  }
+
+  return ret;
+}
+
+GdkPixbuf* GdkPixbufFromSkBitmap(const SkBitmap& bitmap) {
+  if (bitmap.isNull())
+    return nullptr;
+
+  int width = bitmap.width();
+  int height = bitmap.height();
+
+  GdkPixbuf* pixbuf =
+      gdk_pixbuf_new(GDK_COLORSPACE_RGB,  // The only colorspace gtk supports.
+                     TRUE,                // There is an alpha channel.
+                     8, width, height);
+
+  // SkBitmaps are premultiplied, we need to unpremultiply them.
+  const int kBytesPerPixel = 4;
+  uint8_t* divided = gdk_pixbuf_get_pixels(pixbuf);
+
+  for (int y = 0, i = 0; y < height; y++) {
+    for (int x = 0; x < width; x++) {
+      uint32_t pixel = bitmap.getAddr32(0, y)[x];
+
+      int alpha = SkColorGetA(pixel);
+      if (alpha != 0 && alpha != 255) {
+        SkColor unmultiplied = SkUnPreMultiply::PMColorToColor(pixel);
+        divided[i + 0] = SkColorGetR(unmultiplied);
+        divided[i + 1] = SkColorGetG(unmultiplied);
+        divided[i + 2] = SkColorGetB(unmultiplied);
+        divided[i + 3] = alpha;
+      } else {
+        divided[i + 0] = SkColorGetR(pixel);
+        divided[i + 1] = SkColorGetG(pixel);
+        divided[i + 2] = SkColorGetB(pixel);
+        divided[i + 3] = alpha;
+      }
+      i += kBytesPerPixel;
+    }
+  }
+
+  return pixbuf;
+}
+
+}  // namespace libgtkui
diff --git a/chrome/browser/ui/gtk/skia_utils_gtk.h b/chrome/browser/ui/gtk/skia_utils_gtk.h
new file mode 100644
index 000000000000..a6a46cb14f12
--- /dev/null
+++ b/chrome/browser/ui/gtk/skia_utils_gtk.h
@@ -0,0 +1,55 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_UI_LIBGTKUI_SKIA_UTILS_GTK_H_
+#define CHROME_BROWSER_UI_LIBGTKUI_SKIA_UTILS_GTK_H_
+
+#include <gtk/gtk.h>
+#include <stdint.h>
+
+#include "third_party/skia/include/core/SkColor.h"
+
+#if !GTK_CHECK_VERSION(3, 90, 0)
+typedef struct _GdkColor GdkColor;
+#endif
+typedef struct _GdkPixbuf GdkPixbuf;
+
+class SkBitmap;
+
+#if !GTK_CHECK_VERSION(3, 90, 0)
+// Define a macro for creating GdkColors from RGB values.  This is a macro to
+// allow static construction of literals, etc.  Use this like:
+//   GdkColor white = GDK_COLOR_RGB(0xff, 0xff, 0xff);
+#define GDK_COLOR_RGB(r, g, b)               \
+  {                                          \
+    0,                                       \
+    r * ::libgtkui::kSkiaToGDKMultiplier,    \
+    g * ::libgtkui::kSkiaToGDKMultiplier,    \
+    b * ::libgtkui::kSkiaToGDKMultiplier,    \
+  }
+#endif
+
+namespace gtk {
+
+#if !GTK_CHECK_VERSION(3, 90, 0)
+// Multiply uint8_t color components by this.
+const int kSkiaToGDKMultiplier = 257;
+
+// Converts GdkColors to the ARGB layout Skia expects.
+SkColor GdkColorToSkColor(GdkColor color);
+
+// Converts ARGB to GdkColor.
+GdkColor SkColorToGdkColor(SkColor color);
+#endif
+
+const SkBitmap GdkPixbufToImageSkia(GdkPixbuf* pixbuf);
+
+// Convert and copy a SkBitmap to a GdkPixbuf. NOTE: this uses BGRAToRGBA, so
+// it is an expensive operation.  The returned GdkPixbuf will have a refcount of
+// 1, and the caller is responsible for unrefing it when done.
+GdkPixbuf* GdkPixbufFromSkBitmap(const SkBitmap& bitmap);
+
+}  // namespace libgtkui
+
+#endif  // CHROME_BROWSER_UI_LIBGTKUI_SKIA_UTILS_GTK_H_
diff --git a/ui/views/features.gni b/ui/views/features.gni
index 31a5d26f186e..a42c74c96c37 100644
--- a/ui/views/features.gni
+++ b/ui/views/features.gni
@@ -11,5 +11,5 @@ enable_desktop_aura = use_aura && !is_chromeos && !is_chromecast
 declare_args() {
   # Whether we should draw the minimize, maximize/restore, and close
   # buttons using the system theme.  Only used on Linux.
-  enable_native_window_nav_buttons = enable_desktop_aura && is_linux
+  enable_native_window_nav_buttons = false
 }
